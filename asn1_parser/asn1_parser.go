// Code generated from asn1.g4 by ANTLR 4.10.1. DO NOT EDIT.

package asn1_parser // asn1
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type asn1Parser struct {
	*antlr.BaseParser
}

var asn1ParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	literalNames           []string
	symbolicNames          []string
	ruleNames              []string
	predictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func asn1ParserInit() {
	staticData := &asn1ParserStaticData
	staticData.literalNames = []string{
		"", "'ABSENT'", "'ABSTRACT-SYNTAX'", "'ALL'", "'APPLICATION'", "'AUTOMATIC'",
		"'BEGIN'", "'BIT'", "'BMPString'", "'BOOLEAN'", "'BY'", "'CHARACTER'",
		"'CHOICE'", "'CLASS'", "'COMPONENT'", "'COMPONENTS'", "'CONSTRAINED'",
		"'CONTAINING'", "'DATE'", "'DATE-TIME'", "'DEFAULT'", "'DEFINITIONS'",
		"'DURATION'", "'EMBEDDED'", "'ENCODED'", "'ENCODING-CONTROL'", "'END'",
		"'ENUMERATED'", "'EXCEPT'", "'EXPLICIT'", "'EXPORTS'", "'EXTENSIBILITY'",
		"'EXTERNAL'", "'FALSE'", "'FROM'", "'GeneralizedTime'", "'GeneralString'",
		"'GraphicString'", "'IA5String'", "'IDENTIFIER'", "'IMPLICIT'", "'IMPLIED'",
		"'IMPORTS'", "'INCLUDES'", "'INSTANCE'", "'INSTRUCTIONS'", "'INTEGER'",
		"'INTERSECTION'", "'ISO646String'", "'MAX'", "'MIN'", "'MINUS-INFINITY'",
		"'NOT-A-NUMBER'", "'NULL'", "'NumericString'", "'OBJECT'", "'ObjectDescriptor'",
		"'OCTET'", "'OF'", "'OID-IRI'", "'OPTIONAL'", "'PATTERN'", "'PDV'",
		"'PLUS-INFINITY'", "'PRESENT'", "'PrintableString'", "'PRIVATE'", "'REAL'",
		"'RELATIVE-OID'", "'RELATIVE-OID-IRI'", "'SEQUENCE'", "'SET'", "'SETTINGS'",
		"'SIZE'", "'STRING'", "'SYNTAX'", "'T61String'", "'TAGS'", "'TeletexString'",
		"'TIME'", "'TIME-OF-DAY'", "'TRUE'", "'TYPE-IDENTIFIER'", "'UNION'",
		"'UNIQUE'", "'UNIVERSAL'", "'UniversalString'", "'UTCTime'", "'UTF8String'",
		"'VideotexString'", "'VisibleString'", "'WITH'", "'TAG'", "'XER'", "'PER'",
		"'::='", "'...'", "'..'", "'[['", "']]'", "'--'", "'/*'", "'*/'", "'&'",
		"'{'", "'}'", "'['", "']'", "'('", "')'", "':'", "'>'", "'<'", "','",
		"'/'", "'|'", "'!'", "'@'", "'^'", "';'", "'.'", "'='", "'-'", "'''",
		"'\"'",
	}
	staticData.symbolicNames = []string{
		"", "ABSENT_SYM", "ABSTRACT_SYNTAX_SYM", "ALL_SYM", "APPLICATION_SYM",
		"AUTOMATIC_SYM", "BEGIN_SYM", "BIT_SYM", "BMP_STRING_SYM", "BOOLEAN_SYM",
		"BY_SYM", "CHARACTER_SYM", "CHOICE_SYM", "CLASS_SYM", "COMPONENT_SYM",
		"COMPONENTS_SYM", "CONSTRAINED_SYM", "CONTAINING_SYM", "DATE_SYM", "DATE_TIME_SYM",
		"DEFAULT_SYM", "DEFINITIONS_SYM", "DURATION_SYM", "EMBEDDED_SYM", "ENCODED_SYM",
		"ENCODING_CONTROL_SYM", "END_SYM", "ENUMERATED_SYM", "EXCEPT_SYM", "EXPLICIT_SYM",
		"EXPORTS_SYM", "EXTENSIBILITY_SYM", "EXTERNAL_SYM", "FALSE_SYM", "FROM_SYM",
		"GENERALIZED_TIME_SYM", "GENERAL_STRING_SYM", "GRAPHIC_STRING_SYM",
		"IA5_STRING_SYM", "IDENTIFIER_SYM", "IMPLICIT_SYM", "IMPLIED_SYM", "IMPORTS_SYM",
		"INCLUDES_SYM", "INSTANCE_SYM", "INSTRUCTIONS_SYM", "INTEGER_SYM", "INTERSECTION_SYM",
		"ISO646_STRING_SYM", "MAX_SYM", "MIN_SYM", "MINUS_INFINITY_SYM", "NOT_A_NUMBER_SYM",
		"NULL_SYM", "NUMERIC_STRING_SYM", "OBJECT_SYM", "OBJECT_DESCRIPTOR_SYM",
		"OCTET_SYM", "OF_SYM", "OID_IRI_SYM", "OPTIONAL_SYM", "PATTERN_SYM",
		"PDV_SYM", "PLUS_INFINITY_SYM", "PRESENT_SYM", "PRINTABLE_STRING_SYM",
		"PRIVATE_SYM", "REAL_SYM", "RELATIVE_OID_SYM", "RELATIVE_OID_IRI_SYM",
		"SEQUENCE_SYM", "SET_SYM", "SETTINGS_SYM", "SIZE_SYM", "STRING_SYM",
		"SYNTAX_SYM", "T61_STRING_SYM", "TAGS_SYM", "TELETEX_STRING_SYM", "TIME_SYM",
		"TIME_OF_DAY_SYM", "TRUE_SYM", "TYPE_IDENTIFIER_SYM", "UNION_SYM", "UNIQUE_SYM",
		"UNIVERSAL_SYM", "UNIVERSAL_STRING_SYM", "UTC_TIME_SYM", "UTF8_STRING_SYM",
		"VIDEOTEX_STRING_SYM", "VISIBLE_STRING_SYM", "WITH_SYM", "TAG_SYM",
		"XER_SYM", "PER_SYM", "ASSIGNMENT", "ELLIPSIS", "RANGE", "VERSION_START",
		"VERSION_END", "DASH_COMMENT", "BLOCK_START", "BLOCK_END", "AND", "CURLY_START",
		"CURLY_END", "SQUARE_START", "SQUARE_END", "ROUND_START", "ROUND_END",
		"COLON", "GREATER", "LESS", "COMMA", "SLASH", "PIPE", "EXCLAMATION",
		"AT", "CARAT", "SEMI_COMMA", "DOT", "EQUALS", "MINUS", "SINGLE_QUOTE",
		"DOUBLE_QUOTE", "FLOAT", "NUMBER", "HEX_STRING", "BIN_STRING", "CHAR_STRING",
		"WHITESPACE", "UCASE_ID", "LCASE_ID", "LINE_COMMENT", "BLOCK_COMMENT",
	}
	staticData.ruleNames = []string{
		"start", "ruleModules", "ruleModuleDefinition", "ruleModuleReference",
		"ruleModuleIdentifier", "ruleDefinitiveIdentification", "ruleDefinitiveOID",
		"ruleDefinitiveObjIdComponentList", "ruleDefinitiveObjIdComponent",
		"ruleNameForm", "ruleDefinitiveNumberForm", "ruleDefinitiveNameAndNumberForm",
		"ruleDefinitiveOIDAndIRI", "ruleFirstArcIdentifier", "ruleSubsequentArcIdentifier",
		"ruleIRIValue", "ruleEncodingReferenceDefault", "ruleTagDefault", "ruleExtensionDefault",
		"ruleModuleBody", "ruleExports", "ruleSymbolsExported", "ruleSymbolList",
		"ruleSymbol", "ruleReference", "ruleIdentifier", "ruleTypeReference",
		"ruleValueReference", "ruleObjectReference", "ruleObjectClassReference",
		"ruleObjectSetReference", "ruleParameterizedReference", "ruleExternalTypeReference",
		"ruleExternalValueReference", "ruleExternalObjectClassReference", "ruleExternalObjectReference",
		"ruleExternalObjectSetReference", "ruleTypeFieldReference", "ruleValueFieldReference",
		"ruleValueSetFieldReference", "ruleObjectFieldReference", "ruleObjectSetFieldReference",
		"ruleUsefulObjectClassReference", "ruleImports", "ruleSymbolsImported",
		"ruleSymbolsFromModuleList", "ruleSymbolsFromModule", "ruleGlobalModuleReference",
		"ruleAssignedIdentifier", "ruleAssignmentList", "ruleAssignment", "ruleTypeAssignment",
		"ruleValueAssignment", "ruleXMLValueAssignment", "ruleValueSetTypeAssignment",
		"ruleObjectAssignment", "ruleObjectClassAssignment", "ruleObjectSetAssignment",
		"ruleParameterizedAssignment", "ruleObjectIdentifierValue", "ruleObjIdComponentsList",
		"ruleObjIdComponents", "ruleNumberForm", "ruleNameAndNumberForm", "ruleDefinedValue",
		"ruleNamedBit", "ruleNamedBitList", "ruleRestrictedCharacterStringType",
		"ruleUnrestrictedCharacterStringType", "ruleAlternativeTypeList", "ruleRootAlternativeTypeList",
		"ruleVersionNumber", "ruleExtensionAdditionAlternativesGroup", "ruleExtensionAdditionAlternative",
		"ruleExtensionAdditionAlternativesList", "ruleExtensionAdditionAlternatives",
		"ruleEnumerationItem", "ruleEnumeration", "ruleRootEnumeration", "ruleAdditionalEnumeration",
		"ruleAlternativeTypeLists", "ruleEnumerations", "ruleNamedNumber", "ruleNamedNumberList",
		"ruleComponentType", "ruleExtensionAdditionGroup", "ruleExtensionAddition",
		"ruleComponentTypeList", "ruleExtensionAdditionList", "ruleRootComponentTypeList",
		"ruleExtensionAdditions", "ruleExtensionEndMarker", "ruleComponentTypeLists",
		"ruleExtensionAndException", "ruleOptionalExtensionMarker", "ruleEncodingReference",
		"ruleClass", "ruleClassNumber", "ruleEncodingInstruction", "ruleTag",
		"ruleEncodingPrefix", "ruleTaggedType", "ruleEncodingPrefixedType",
		"ruleBitStringType", "ruleBooleanType", "ruleCharacterStringType", "ruleChoiceType",
		"ruleDateType", "ruleDateTimeType", "ruleDurationType", "ruleEmbeddedPDVType",
		"ruleEnumeratedType", "ruleExternalType", "ruleInstanceOfType", "ruleIntegerType",
		"ruleIRIType", "ruleNullType", "ruleObjectClassFieldType", "ruleObjectIdentifierType",
		"ruleOctetStringType", "ruleRealType", "ruleRelativeIRIType", "ruleRelativeOIDType",
		"ruleSequenceType", "ruleSequenceOfType", "ruleSetType", "ruleSetOfType",
		"rulePrefixedType", "ruleTimeType", "ruleTimeOfDayType", "ruleBuiltinType",
		"ruleSimpleDefinedType", "ruleParameterizedType", "ruleParameterizedValueSetType",
		"ruleDefinedType", "ruleUsefulType", "ruleSelectionType", "ruleTypeFromObject",
		"ruleValueSetFromObjects", "ruleReferencedType", "ruleTypeForConstraint",
		"ruleNamedType", "ruleTypeWithConstraint", "ruleConstrainedType", "ruleType",
		"ruleIdentifierList", "ruleCharsDefn", "ruleCharSyms", "ruleGroup",
		"rulePlane", "ruleRow", "ruleCell", "ruleTableColumn", "ruleTableRow",
		"ruleCharacterStringList", "ruleQuadruple", "ruleTuple", "ruleRestrictedCharacterStringValue",
		"ruleUnrestrictedCharacterStringValue", "ruleNumericRealValue", "ruleSpecialRealValue",
		"ruleRelativeOIDComponents", "ruleRelativeOIDComponentsList", "ruleComponentValueList",
		"ruleValueList", "ruleNamedValue", "ruleNamedValueList", "ruleBitStringValue",
		"ruleBooleanValue", "ruleCharacterStringValue", "ruleChoiceValue", "ruleEmbeddedPDVValue",
		"ruleEnumeratedValue", "ruleExternalValue", "ruleInstanceOfValue", "ruleIntegerValue",
		"ruleNullValue", "ruleOctetStringValue", "ruleRealValue", "ruleRelativeIRIValue",
		"ruleRelativeOIDValue", "ruleSequenceValue", "ruleSequenceOfValue",
		"ruleSetValue", "ruleSetOfValue", "rulePrefixedValue", "ruleTimeValue",
		"ruleBuiltinValue", "ruleValueFromObject", "ruleReferencedValue", "ruleOpenTypeFieldVal",
		"ruleFixedTypeFieldVal", "ruleObjectClassFieldValue", "ruleValue", "ruleValueSet",
		"ruleDefinedObjectClass", "ruleObject", "ruleDefinedObject", "ruleDefinedObjectSet",
		"ruleObjectDefn", "ruleDefaultSyntax", "ruleDefinedSyntax", "ruleDefinedSyntaxTokenList",
		"ruleDefinedSyntaxToken", "ruleLiteral", "ruleWord", "ruleFieldSettingList",
		"ruleFieldSetting", "rulePrimitiveFieldName", "ruleSetting", "ruleObjectFromObject",
		"ruleObjectSetFromObjects", "ruleReferencedObjects", "ruleFieldName",
		"ruleParameterizedObject", "ruleObjectClass", "ruleObjectClassDefn",
		"ruleFieldSpecList", "ruleFieldSpec", "ruleTypeFieldSpec", "ruleFixedTypeValueFieldSpec",
		"ruleUnique", "ruleVariableTypeValueFieldSpec", "ruleFixedTypeValueSetFieldSpec",
		"ruleVariableTypeValueSetFieldSpec", "ruleObjectFieldSpec", "ruleObjectSetFieldSpec",
		"ruleTypeOptionalitySpec", "ruleValueOptionalitySpec", "ruleValueSetOptionalitySpec",
		"ruleObjectOptionalitySpec", "ruleObjectSetOptionalitySpec", "ruleWithSyntaxSpec",
		"ruleSyntaxList", "ruleTokenOrGroupSpecList", "ruleTokenOrGroupSpec",
		"ruleRequiredToken", "ruleOptionalGroup", "ruleParameterizedObjectClass",
		"ruleObjectSet", "ruleObjectSetSpec", "ruleRootElementSetSpec", "ruleAdditionalElementSetSpec",
		"ruleElementSetSpecs", "ruleElementSetSpec", "ruleUnions", "ruleExclusions",
		"ruleIntersections", "ruleUElems", "ruleUnionMark", "ruleLowerEndValue",
		"ruleUpperEndValue", "ruleIncludes", "ruleLowerEndpoint", "ruleUpperEndpoint",
		"ruleLevel", "ruleComponentIdList", "ruleAtNotation", "ruleAtNotationList",
		"ruleUserDefinedConstraintParameter", "ruleUserDefinedConstraintParameterList",
		"ruleUserDefinedConstraint", "ruleSimpleTableConstraint", "ruleComponentRelationConstraint",
		"ruleTableConstraint", "ruleContentsConstraint", "ruleSubtypeConstraint",
		"ruleGeneralConstraint", "ruleConstraintSpec", "ruleSignedNumber", "ruleExceptionIdentification",
		"ruleExceptionSpec", "ruleConstraint", "ruleSingleTypeConstraint", "ruleValueConstraint",
		"rulePresenceConstraint", "ruleComponentConstraint", "ruleNamedConstraint",
		"ruleTypeConstraints", "ruleFullSpecification", "rulePartialSpecification",
		"ruleMultipleTypeConstraints", "ruleSimpleString", "ruleSingleValue",
		"ruleContainedSubtype", "ruleValueRange", "rulePermittedAlphabet", "ruleSizeConstraint",
		"ruleInnerTypeConstraints", "rulePatternConstraint", "rulePropertySettings",
		"ruleDurationRange", "ruleTimePointRange", "ruleRecurrenceRange", "ruleSubtypeElements",
		"ruleObjectSetElements", "ruleElements", "ruleElems", "ruleIntersectionElements",
		"ruleIElems", "ruleIntersectionMark", "ruleSimpleDefinedValue", "ruleActualParameterList",
		"ruleActualParameters", "ruleActualParameter", "ruleParameterizedObjectSet",
		"ruleParameterizedValue", "ruleParameterizedTypeAssignment", "ruleParameterizedValueAssignment",
		"ruleParameterizedValueSetTypeAssignment", "ruleParameterizedObjectClassAssignment",
		"ruleParameterizedObjectAssignment", "ruleParameterizedObjectSetAssignment",
		"ruleParameterList", "ruleParameters", "ruleParameter", "ruleParamGovernor",
		"ruleDummyReference", "ruleGovernor", "ruleDummyGovernor", "ruleEncodingControlSections",
	}
	staticData.predictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 134, 2433, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7,
		153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2,
		158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7,
		162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2,
		167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7,
		171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2,
		176, 7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7,
		180, 2, 181, 7, 181, 2, 182, 7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2,
		185, 7, 185, 2, 186, 7, 186, 2, 187, 7, 187, 2, 188, 7, 188, 2, 189, 7,
		189, 2, 190, 7, 190, 2, 191, 7, 191, 2, 192, 7, 192, 2, 193, 7, 193, 2,
		194, 7, 194, 2, 195, 7, 195, 2, 196, 7, 196, 2, 197, 7, 197, 2, 198, 7,
		198, 2, 199, 7, 199, 2, 200, 7, 200, 2, 201, 7, 201, 2, 202, 7, 202, 2,
		203, 7, 203, 2, 204, 7, 204, 2, 205, 7, 205, 2, 206, 7, 206, 2, 207, 7,
		207, 2, 208, 7, 208, 2, 209, 7, 209, 2, 210, 7, 210, 2, 211, 7, 211, 2,
		212, 7, 212, 2, 213, 7, 213, 2, 214, 7, 214, 2, 215, 7, 215, 2, 216, 7,
		216, 2, 217, 7, 217, 2, 218, 7, 218, 2, 219, 7, 219, 2, 220, 7, 220, 2,
		221, 7, 221, 2, 222, 7, 222, 2, 223, 7, 223, 2, 224, 7, 224, 2, 225, 7,
		225, 2, 226, 7, 226, 2, 227, 7, 227, 2, 228, 7, 228, 2, 229, 7, 229, 2,
		230, 7, 230, 2, 231, 7, 231, 2, 232, 7, 232, 2, 233, 7, 233, 2, 234, 7,
		234, 2, 235, 7, 235, 2, 236, 7, 236, 2, 237, 7, 237, 2, 238, 7, 238, 2,
		239, 7, 239, 2, 240, 7, 240, 2, 241, 7, 241, 2, 242, 7, 242, 2, 243, 7,
		243, 2, 244, 7, 244, 2, 245, 7, 245, 2, 246, 7, 246, 2, 247, 7, 247, 2,
		248, 7, 248, 2, 249, 7, 249, 2, 250, 7, 250, 2, 251, 7, 251, 2, 252, 7,
		252, 2, 253, 7, 253, 2, 254, 7, 254, 2, 255, 7, 255, 2, 256, 7, 256, 2,
		257, 7, 257, 2, 258, 7, 258, 2, 259, 7, 259, 2, 260, 7, 260, 2, 261, 7,
		261, 2, 262, 7, 262, 2, 263, 7, 263, 2, 264, 7, 264, 2, 265, 7, 265, 2,
		266, 7, 266, 2, 267, 7, 267, 2, 268, 7, 268, 2, 269, 7, 269, 2, 270, 7,
		270, 2, 271, 7, 271, 2, 272, 7, 272, 2, 273, 7, 273, 2, 274, 7, 274, 2,
		275, 7, 275, 2, 276, 7, 276, 2, 277, 7, 277, 2, 278, 7, 278, 2, 279, 7,
		279, 2, 280, 7, 280, 2, 281, 7, 281, 2, 282, 7, 282, 2, 283, 7, 283, 2,
		284, 7, 284, 2, 285, 7, 285, 2, 286, 7, 286, 2, 287, 7, 287, 2, 288, 7,
		288, 2, 289, 7, 289, 2, 290, 7, 290, 2, 291, 7, 291, 2, 292, 7, 292, 2,
		293, 7, 293, 2, 294, 7, 294, 2, 295, 7, 295, 2, 296, 7, 296, 2, 297, 7,
		297, 2, 298, 7, 298, 2, 299, 7, 299, 2, 300, 7, 300, 2, 301, 7, 301, 2,
		302, 7, 302, 2, 303, 7, 303, 2, 304, 7, 304, 2, 305, 7, 305, 2, 306, 7,
		306, 2, 307, 7, 307, 2, 308, 7, 308, 2, 309, 7, 309, 2, 310, 7, 310, 2,
		311, 7, 311, 2, 312, 7, 312, 2, 313, 7, 313, 2, 314, 7, 314, 2, 315, 7,
		315, 2, 316, 7, 316, 2, 317, 7, 317, 2, 318, 7, 318, 2, 319, 7, 319, 2,
		320, 7, 320, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 5, 1, 651,
		8, 1, 10, 1, 12, 1, 654, 9, 1, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 2,
		1, 2, 1, 2, 1, 2, 1, 2, 1, 3, 1, 3, 1, 4, 1, 4, 1, 4, 1, 5, 1, 5, 1, 5,
		3, 5, 675, 8, 5, 1, 6, 1, 6, 1, 6, 1, 6, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7,
		5, 7, 686, 8, 7, 10, 7, 12, 7, 689, 9, 7, 1, 8, 1, 8, 1, 8, 3, 8, 694,
		8, 8, 1, 9, 1, 9, 1, 10, 1, 10, 1, 11, 1, 11, 1, 11, 1, 11, 1, 11, 1, 12,
		1, 12, 1, 12, 1, 13, 1, 13, 1, 14, 1, 14, 1, 15, 1, 15, 1, 16, 1, 16, 1,
		16, 3, 16, 717, 8, 16, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17,
		3, 17, 726, 8, 17, 1, 18, 1, 18, 1, 18, 3, 18, 731, 8, 18, 1, 19, 1, 19,
		1, 19, 1, 19, 1, 19, 3, 19, 738, 8, 19, 1, 20, 1, 20, 1, 20, 1, 20, 1,
		20, 1, 20, 1, 20, 1, 20, 3, 20, 748, 8, 20, 1, 21, 1, 21, 3, 21, 752, 8,
		21, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 1, 22, 5, 22, 760, 8, 22, 10, 22,
		12, 22, 763, 9, 22, 1, 23, 1, 23, 3, 23, 767, 8, 23, 1, 24, 1, 24, 1, 24,
		1, 24, 1, 24, 3, 24, 774, 8, 24, 1, 25, 1, 25, 1, 26, 1, 26, 1, 27, 1,
		27, 1, 28, 1, 28, 1, 29, 1, 29, 1, 30, 1, 30, 1, 31, 1, 31, 1, 31, 1, 31,
		1, 31, 3, 31, 793, 8, 31, 1, 32, 1, 32, 1, 32, 1, 32, 1, 33, 1, 33, 1,
		33, 1, 33, 1, 34, 1, 34, 1, 34, 1, 34, 1, 35, 1, 35, 1, 35, 1, 35, 1, 36,
		1, 36, 1, 36, 1, 36, 1, 37, 1, 37, 1, 37, 1, 38, 1, 38, 1, 38, 1, 39, 1,
		39, 1, 39, 1, 40, 1, 40, 1, 40, 1, 41, 1, 41, 1, 41, 1, 42, 1, 42, 1, 43,
		1, 43, 1, 43, 1, 43, 1, 43, 3, 43, 837, 8, 43, 1, 44, 1, 44, 3, 44, 841,
		8, 44, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 5, 45, 848, 8, 45, 10, 45, 12,
		45, 851, 9, 45, 1, 46, 1, 46, 1, 46, 1, 46, 1, 47, 1, 47, 1, 47, 1, 48,
		1, 48, 1, 48, 3, 48, 863, 8, 48, 1, 49, 1, 49, 1, 49, 3, 49, 868, 8, 49,
		1, 49, 1, 49, 5, 49, 872, 8, 49, 10, 49, 12, 49, 875, 9, 49, 1, 50, 1,
		50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 3, 50, 884, 8, 50, 1, 51, 1, 51,
		1, 51, 1, 51, 1, 52, 1, 52, 1, 52, 1, 52, 1, 52, 1, 53, 1, 53, 1, 54, 1,
		54, 1, 54, 1, 54, 1, 54, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 56, 1, 56,
		1, 56, 1, 56, 1, 57, 1, 57, 1, 57, 1, 57, 1, 57, 1, 58, 1, 58, 1, 58, 1,
		58, 1, 58, 1, 58, 3, 58, 922, 8, 58, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59,
		1, 59, 1, 59, 1, 59, 1, 59, 3, 59, 933, 8, 59, 1, 60, 1, 60, 1, 60, 1,
		60, 1, 60, 5, 60, 940, 8, 60, 10, 60, 12, 60, 943, 9, 60, 1, 61, 1, 61,
		1, 61, 1, 61, 3, 61, 949, 8, 61, 1, 62, 1, 62, 3, 62, 953, 8, 62, 1, 63,
		1, 63, 1, 63, 1, 63, 1, 63, 1, 64, 1, 64, 1, 64, 3, 64, 963, 8, 64, 1,
		65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 3, 65,
		975, 8, 65, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 5, 66, 983, 8, 66,
		10, 66, 12, 66, 986, 9, 66, 1, 67, 1, 67, 1, 68, 1, 68, 1, 68, 1, 69, 1,
		69, 1, 69, 1, 69, 1, 69, 1, 69, 5, 69, 999, 8, 69, 10, 69, 12, 69, 1002,
		9, 69, 1, 70, 1, 70, 1, 71, 1, 71, 1, 71, 3, 71, 1009, 8, 71, 1, 72, 1,
		72, 1, 72, 1, 72, 1, 72, 1, 73, 1, 73, 3, 73, 1018, 8, 73, 1, 74, 1, 74,
		1, 74, 1, 74, 1, 74, 1, 74, 5, 74, 1026, 8, 74, 10, 74, 12, 74, 1029, 9,
		74, 1, 75, 1, 75, 1, 75, 3, 75, 1034, 8, 75, 1, 76, 1, 76, 3, 76, 1038,
		8, 76, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 1, 77, 5, 77, 1046, 8, 77, 10,
		77, 12, 77, 1049, 9, 77, 1, 78, 1, 78, 1, 79, 1, 79, 1, 80, 1, 80, 1, 80,
		1, 80, 1, 80, 1, 80, 1, 80, 3, 80, 1062, 8, 80, 1, 81, 1, 81, 1, 81, 1,
		81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 3, 81,
		1077, 8, 81, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1,
		82, 1, 82, 3, 82, 1089, 8, 82, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83,
		5, 83, 1097, 8, 83, 10, 83, 12, 83, 1100, 9, 83, 1, 84, 1, 84, 1, 84, 1,
		84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 3, 84, 1113, 8, 84,
		1, 85, 1, 85, 1, 85, 1, 85, 1, 85, 1, 86, 1, 86, 3, 86, 1122, 8, 86, 1,
		87, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 5, 87, 1130, 8, 87, 10, 87, 12,
		87, 1133, 9, 87, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 5, 88, 1141,
		8, 88, 10, 88, 12, 88, 1144, 9, 88, 1, 89, 1, 89, 1, 90, 1, 90, 1, 90,
		3, 90, 1151, 8, 90, 1, 91, 1, 91, 1, 91, 1, 92, 1, 92, 1, 92, 1, 92, 1,
		92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92,
		1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 3,
		92, 1181, 8, 92, 1, 93, 1, 93, 1, 93, 3, 93, 1186, 8, 93, 1, 94, 1, 94,
		1, 94, 3, 94, 1191, 8, 94, 1, 95, 1, 95, 1, 95, 3, 95, 1196, 8, 95, 1,
		96, 1, 96, 1, 96, 1, 96, 3, 96, 1202, 8, 96, 1, 97, 1, 97, 3, 97, 1206,
		8, 97, 1, 98, 1, 98, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 100,
		1, 100, 1, 100, 1, 100, 1, 100, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101,
		1, 101, 1, 101, 1, 101, 3, 101, 1229, 8, 101, 1, 102, 1, 102, 1, 102, 1,
		103, 1, 103, 1, 103, 1, 103, 1, 103, 1, 103, 1, 103, 1, 103, 3, 103, 1242,
		8, 103, 1, 104, 1, 104, 1, 105, 1, 105, 3, 105, 1248, 8, 105, 1, 106, 1,
		106, 1, 106, 1, 106, 1, 106, 1, 107, 1, 107, 1, 108, 1, 108, 1, 109, 1,
		109, 1, 110, 1, 110, 1, 110, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1,
		112, 1, 112, 1, 113, 1, 113, 1, 113, 1, 113, 1, 114, 1, 114, 1, 114, 1,
		114, 1, 114, 1, 114, 3, 114, 1281, 8, 114, 1, 115, 1, 115, 1, 116, 1, 116,
		1, 117, 1, 117, 1, 117, 1, 117, 1, 118, 1, 118, 1, 118, 1, 119, 1, 119,
		1, 119, 1, 120, 1, 120, 1, 121, 1, 121, 1, 122, 1, 122, 1, 123, 1, 123,
		1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123,
		1, 123, 1, 123, 1, 123, 3, 123, 1317, 8, 123, 1, 124, 1, 124, 1, 124, 1,
		124, 1, 124, 1, 124, 3, 124, 1325, 8, 124, 1, 125, 1, 125, 1, 125, 1, 125,
		1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125,
		1, 125, 3, 125, 1341, 8, 125, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 1,
		126, 3, 126, 1349, 8, 126, 1, 127, 1, 127, 3, 127, 1353, 8, 127, 1, 128,
		1, 128, 1, 129, 1, 129, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130,
		1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130,
		1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130,
		1, 130, 1, 130, 3, 130, 1385, 8, 130, 1, 131, 1, 131, 3, 131, 1389, 8,
		131, 1, 132, 1, 132, 1, 132, 1, 133, 1, 133, 1, 133, 1, 134, 1, 134, 1,
		134, 1, 134, 3, 134, 1401, 8, 134, 1, 135, 1, 135, 1, 136, 1, 136, 1, 136,
		1, 136, 1, 137, 1, 137, 1, 137, 1, 137, 1, 138, 1, 138, 1, 138, 1, 138,
		1, 139, 1, 139, 1, 139, 1, 139, 1, 139, 3, 139, 1422, 8, 139, 1, 140, 1,
		140, 3, 140, 1426, 8, 140, 1, 141, 1, 141, 1, 141, 1, 142, 1, 142, 1, 142,
		1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142,
		1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142,
		1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142,
		1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142, 1, 142,
		1, 142, 3, 142, 1471, 8, 142, 1, 143, 1, 143, 1, 143, 1, 143, 3, 143, 1477,
		8, 143, 1, 144, 1, 144, 1, 144, 3, 144, 1482, 8, 144, 1, 145, 1, 145, 1,
		145, 1, 145, 1, 145, 1, 145, 5, 145, 1490, 8, 145, 10, 145, 12, 145, 1493,
		9, 145, 1, 146, 1, 146, 1, 146, 1, 146, 3, 146, 1499, 8, 146, 1, 147, 1,
		147, 1, 147, 1, 147, 1, 147, 1, 147, 5, 147, 1507, 8, 147, 10, 147, 12,
		147, 1510, 9, 147, 1, 148, 1, 148, 1, 149, 1, 149, 1, 150, 1, 150, 1, 151,
		1, 151, 1, 152, 1, 152, 1, 153, 1, 153, 1, 154, 1, 154, 1, 154, 1, 154,
		1, 155, 1, 155, 1, 155, 1, 155, 1, 155, 1, 155, 1, 155, 1, 155, 1, 155,
		1, 155, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 156, 1, 157, 1, 157,
		1, 157, 1, 157, 3, 157, 1548, 8, 157, 1, 158, 1, 158, 1, 159, 1, 159, 1,
		159, 1, 159, 3, 159, 1556, 8, 159, 1, 160, 1, 160, 1, 161, 1, 161, 1, 161,
		3, 161, 1563, 8, 161, 1, 162, 1, 162, 1, 162, 1, 162, 1, 162, 5, 162, 1570,
		8, 162, 10, 162, 12, 162, 1573, 9, 162, 1, 163, 1, 163, 1, 163, 1, 163,
		1, 163, 1, 163, 5, 163, 1581, 8, 163, 10, 163, 12, 163, 1584, 9, 163, 1,
		164, 1, 164, 1, 164, 1, 164, 1, 164, 1, 164, 5, 164, 1592, 8, 164, 10,
		164, 12, 164, 1595, 9, 164, 1, 165, 1, 165, 1, 165, 1, 166, 1, 166, 1,
		166, 1, 166, 1, 166, 1, 166, 5, 166, 1606, 8, 166, 10, 166, 12, 166, 1609,
		9, 166, 1, 167, 1, 167, 1, 167, 1, 167, 1, 167, 1, 167, 1, 167, 1, 167,
		1, 167, 1, 167, 3, 167, 1621, 8, 167, 1, 168, 1, 168, 1, 169, 1, 169, 3,
		169, 1627, 8, 169, 1, 170, 1, 170, 1, 170, 1, 170, 1, 171, 1, 171, 1, 172,
		1, 172, 1, 173, 1, 173, 1, 174, 1, 174, 1, 175, 1, 175, 3, 175, 1643, 8,
		175, 1, 176, 1, 176, 1, 177, 1, 177, 1, 177, 1, 177, 3, 177, 1651, 8, 177,
		1, 178, 1, 178, 3, 178, 1655, 8, 178, 1, 179, 1, 179, 1, 180, 1, 180, 1,
		180, 1, 180, 1, 181, 1, 181, 1, 181, 1, 181, 1, 182, 1, 182, 1, 182, 1,
		182, 1, 182, 1, 182, 1, 182, 1, 182, 1, 182, 1, 182, 3, 182, 1677, 8, 182,
		1, 183, 1, 183, 1, 183, 1, 183, 1, 183, 1, 183, 3, 183, 1685, 8, 183, 1,
		184, 1, 184, 1, 184, 1, 184, 1, 184, 1, 184, 1, 184, 1, 184, 1, 184, 1,
		184, 3, 184, 1697, 8, 184, 1, 185, 1, 185, 1, 186, 1, 186, 1, 187, 1, 187,
		1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 1, 187,
		1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 1, 187, 3, 187, 1720, 8, 187, 1,
		188, 1, 188, 1, 188, 1, 188, 1, 189, 1, 189, 3, 189, 1728, 8, 189, 1, 190,
		1, 190, 1, 190, 1, 190, 1, 191, 1, 191, 3, 191, 1736, 8, 191, 1, 192, 1,
		192, 3, 192, 1740, 8, 192, 1, 193, 1, 193, 1, 193, 3, 193, 1745, 8, 193,
		1, 194, 1, 194, 1, 194, 1, 194, 1, 195, 1, 195, 1, 195, 3, 195, 1754, 8,
		195, 1, 196, 1, 196, 1, 196, 1, 196, 3, 196, 1760, 8, 196, 1, 197, 1, 197,
		3, 197, 1764, 8, 197, 1, 198, 1, 198, 3, 198, 1768, 8, 198, 1, 199, 1,
		199, 3, 199, 1772, 8, 199, 1, 200, 1, 200, 1, 200, 1, 200, 1, 201, 1, 201,
		1, 201, 1, 201, 1, 202, 1, 202, 1, 202, 3, 202, 1785, 8, 202, 1, 202, 1,
		202, 5, 202, 1789, 8, 202, 10, 202, 12, 202, 1792, 9, 202, 1, 203, 1, 203,
		3, 203, 1796, 8, 203, 1, 204, 1, 204, 3, 204, 1800, 8, 204, 1, 205, 1,
		205, 1, 206, 1, 206, 1, 206, 3, 206, 1807, 8, 206, 1, 206, 1, 206, 1, 206,
		5, 206, 1812, 8, 206, 10, 206, 12, 206, 1815, 9, 206, 1, 207, 1, 207, 1,
		207, 1, 208, 1, 208, 1, 208, 1, 208, 1, 208, 3, 208, 1825, 8, 208, 1, 209,
		1, 209, 1, 209, 1, 209, 1, 209, 3, 209, 1832, 8, 209, 1, 210, 1, 210, 1,
		210, 1, 210, 1, 211, 1, 211, 1, 211, 1, 211, 1, 212, 1, 212, 1, 212, 1,
		212, 3, 212, 1846, 8, 212, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213, 1, 213,
		5, 213, 1854, 8, 213, 10, 213, 12, 213, 1857, 9, 213, 1, 214, 1, 214, 1,
		214, 1, 215, 1, 215, 1, 215, 3, 215, 1865, 8, 215, 1, 216, 1, 216, 1, 216,
		1, 216, 1, 216, 1, 216, 1, 217, 1, 217, 1, 217, 1, 217, 1, 217, 1, 217,
		5, 217, 1879, 8, 217, 10, 217, 12, 217, 1882, 9, 217, 1, 218, 1, 218, 1,
		218, 1, 218, 1, 218, 1, 218, 1, 218, 3, 218, 1891, 8, 218, 1, 219, 1, 219,
		1, 219, 1, 220, 1, 220, 1, 220, 1, 220, 1, 220, 1, 221, 1, 221, 3, 221,
		1903, 8, 221, 1, 222, 1, 222, 1, 222, 1, 222, 1, 223, 1, 223, 1, 223, 1,
		223, 1, 224, 1, 224, 1, 224, 1, 224, 1, 225, 1, 225, 1, 225, 1, 225, 1,
		226, 1, 226, 1, 226, 1, 226, 1, 227, 1, 227, 1, 227, 3, 227, 1928, 8, 227,
		1, 228, 1, 228, 1, 228, 1, 228, 3, 228, 1934, 8, 228, 1, 229, 1, 229, 1,
		229, 1, 229, 3, 229, 1940, 8, 229, 1, 230, 1, 230, 1, 230, 1, 230, 3, 230,
		1946, 8, 230, 1, 231, 1, 231, 1, 231, 1, 231, 3, 231, 1952, 8, 231, 1,
		232, 1, 232, 1, 232, 1, 232, 1, 233, 1, 233, 1, 233, 1, 233, 1, 234, 1,
		234, 1, 234, 3, 234, 1965, 8, 234, 1, 234, 1, 234, 5, 234, 1969, 8, 234,
		10, 234, 12, 234, 1972, 9, 234, 1, 235, 1, 235, 3, 235, 1976, 8, 235, 1,
		236, 1, 236, 3, 236, 1980, 8, 236, 1, 237, 1, 237, 1, 237, 1, 237, 1, 238,
		1, 238, 1, 238, 1, 239, 1, 239, 1, 239, 1, 239, 1, 240, 1, 240, 1, 240,
		1, 240, 1, 240, 1, 240, 1, 240, 1, 240, 1, 240, 1, 240, 1, 240, 1, 240,
		1, 240, 1, 240, 1, 240, 3, 240, 2008, 8, 240, 1, 241, 1, 241, 1, 242, 1,
		242, 1, 243, 1, 243, 1, 243, 1, 243, 1, 243, 1, 243, 1, 243, 1, 243, 1,
		243, 1, 243, 1, 243, 3, 243, 2025, 8, 243, 1, 244, 1, 244, 1, 244, 3, 244,
		2030, 8, 244, 1, 245, 1, 245, 1, 245, 1, 245, 1, 245, 1, 245, 1, 245, 5,
		245, 2039, 8, 245, 10, 245, 12, 245, 2042, 9, 245, 1, 246, 1, 246, 1, 246,
		1, 247, 1, 247, 1, 247, 1, 247, 1, 247, 1, 247, 1, 247, 5, 247, 2054, 8,
		247, 10, 247, 12, 247, 2057, 9, 247, 1, 248, 1, 248, 1, 249, 1, 249, 1,
		250, 1, 250, 3, 250, 2065, 8, 250, 1, 251, 1, 251, 3, 251, 2069, 8, 251,
		1, 252, 1, 252, 3, 252, 2073, 8, 252, 1, 253, 1, 253, 1, 253, 1, 253, 3,
		253, 2079, 8, 253, 1, 254, 1, 254, 1, 254, 3, 254, 2084, 8, 254, 1, 255,
		1, 255, 1, 255, 3, 255, 2089, 8, 255, 1, 256, 1, 256, 1, 256, 1, 256, 1,
		256, 1, 256, 5, 256, 2097, 8, 256, 10, 256, 12, 256, 2100, 9, 256, 1, 257,
		1, 257, 1, 257, 1, 257, 1, 257, 1, 257, 1, 257, 3, 257, 2109, 8, 257, 1,
		258, 1, 258, 1, 258, 1, 258, 1, 258, 1, 258, 5, 258, 2117, 8, 258, 10,
		258, 12, 258, 2120, 9, 258, 1, 259, 1, 259, 1, 259, 1, 259, 1, 259, 1,
		259, 1, 259, 1, 259, 1, 259, 1, 259, 1, 259, 3, 259, 2133, 8, 259, 1, 260,
		1, 260, 1, 260, 3, 260, 2138, 8, 260, 1, 260, 1, 260, 1, 260, 5, 260, 2143,
		8, 260, 10, 260, 12, 260, 2146, 9, 260, 1, 261, 1, 261, 1, 261, 1, 261,
		1, 261, 1, 261, 1, 262, 1, 262, 1, 263, 1, 263, 1, 263, 1, 263, 1, 263,
		1, 263, 1, 263, 1, 264, 1, 264, 3, 264, 2165, 8, 264, 1, 265, 1, 265, 1,
		265, 1, 265, 1, 265, 1, 265, 1, 265, 1, 265, 1, 265, 1, 265, 1, 265, 3,
		265, 2178, 8, 265, 1, 266, 1, 266, 1, 267, 1, 267, 1, 267, 3, 267, 2185,
		8, 267, 1, 268, 1, 268, 3, 268, 2189, 8, 268, 1, 269, 1, 269, 1, 269, 3,
		269, 2194, 8, 269, 1, 270, 1, 270, 1, 270, 1, 270, 1, 270, 1, 270, 3, 270,
		2202, 8, 270, 1, 271, 1, 271, 1, 271, 3, 271, 2207, 8, 271, 1, 272, 1,
		272, 1, 272, 1, 272, 1, 272, 1, 273, 1, 273, 1, 274, 1, 274, 3, 274, 2218,
		8, 274, 1, 275, 1, 275, 1, 275, 1, 275, 3, 275, 2224, 8, 275, 1, 276, 1,
		276, 1, 276, 1, 277, 1, 277, 1, 277, 1, 278, 1, 278, 1, 278, 1, 278, 1,
		278, 1, 278, 5, 278, 2238, 8, 278, 10, 278, 12, 278, 2241, 9, 278, 1, 279,
		1, 279, 1, 279, 1, 279, 1, 280, 1, 280, 1, 280, 1, 280, 1, 280, 1, 280,
		1, 281, 1, 281, 3, 281, 2255, 8, 281, 1, 282, 1, 282, 1, 283, 1, 283, 1,
		284, 1, 284, 1, 284, 1, 285, 1, 285, 1, 285, 1, 285, 1, 286, 1, 286, 1,
		286, 1, 287, 1, 287, 1, 287, 1, 288, 1, 288, 1, 288, 1, 288, 1, 288, 1,
		288, 3, 288, 2280, 8, 288, 1, 289, 1, 289, 1, 289, 1, 290, 1, 290, 1, 290,
		1, 291, 1, 291, 1, 292, 1, 292, 1, 293, 1, 293, 1, 294, 1, 294, 1, 294,
		1, 294, 1, 294, 1, 294, 1, 294, 1, 294, 3, 294, 2302, 8, 294, 1, 295, 1,
		295, 1, 295, 1, 295, 3, 295, 2308, 8, 295, 1, 296, 1, 296, 1, 296, 1, 296,
		1, 296, 1, 296, 3, 296, 2316, 8, 296, 1, 297, 1, 297, 1, 298, 1, 298, 1,
		298, 1, 298, 3, 298, 2324, 8, 298, 1, 299, 1, 299, 1, 300, 1, 300, 1, 301,
		1, 301, 3, 301, 2332, 8, 301, 1, 302, 1, 302, 1, 302, 1, 302, 1, 303, 1,
		303, 1, 303, 1, 303, 1, 303, 1, 303, 5, 303, 2344, 8, 303, 10, 303, 12,
		303, 2347, 9, 303, 1, 304, 1, 304, 1, 304, 1, 304, 1, 304, 1, 304, 3, 304,
		2355, 8, 304, 1, 305, 1, 305, 1, 305, 1, 306, 1, 306, 1, 306, 1, 307, 1,
		307, 1, 307, 1, 307, 1, 307, 1, 308, 1, 308, 1, 308, 1, 308, 1, 308, 1,
		308, 1, 309, 1, 309, 1, 309, 1, 309, 1, 309, 1, 309, 1, 310, 1, 310, 1,
		310, 1, 310, 1, 310, 1, 311, 1, 311, 1, 311, 1, 311, 1, 311, 1, 311, 1,
		312, 1, 312, 1, 312, 1, 312, 1, 312, 1, 312, 1, 313, 1, 313, 1, 313, 1,
		313, 1, 314, 1, 314, 1, 314, 1, 314, 1, 314, 1, 314, 5, 314, 2407, 8, 314,
		10, 314, 12, 314, 2410, 9, 314, 1, 315, 1, 315, 1, 315, 1, 315, 1, 315,
		3, 315, 2417, 8, 315, 1, 316, 1, 316, 3, 316, 2421, 8, 316, 1, 317, 1,
		317, 1, 318, 1, 318, 3, 318, 2427, 8, 318, 1, 319, 1, 319, 1, 320, 1, 320,
		1, 320, 0, 32, 2, 14, 44, 90, 98, 120, 132, 138, 148, 154, 166, 174, 176,
		290, 294, 324, 326, 328, 332, 404, 412, 426, 434, 468, 490, 494, 512, 516,
		520, 556, 606, 628, 321, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24,
		26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60,
		62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96,
		98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126,
		128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156,
		158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186,
		188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216,
		218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246,
		248, 250, 252, 254, 256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276,
		278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306,
		308, 310, 312, 314, 316, 318, 320, 322, 324, 326, 328, 330, 332, 334, 336,
		338, 340, 342, 344, 346, 348, 350, 352, 354, 356, 358, 360, 362, 364, 366,
		368, 370, 372, 374, 376, 378, 380, 382, 384, 386, 388, 390, 392, 394, 396,
		398, 400, 402, 404, 406, 408, 410, 412, 414, 416, 418, 420, 422, 424, 426,
		428, 430, 432, 434, 436, 438, 440, 442, 444, 446, 448, 450, 452, 454, 456,
		458, 460, 462, 464, 466, 468, 470, 472, 474, 476, 478, 480, 482, 484, 486,
		488, 490, 492, 494, 496, 498, 500, 502, 504, 506, 508, 510, 512, 514, 516,
		518, 520, 522, 524, 526, 528, 530, 532, 534, 536, 538, 540, 542, 544, 546,
		548, 550, 552, 554, 556, 558, 560, 562, 564, 566, 568, 570, 572, 574, 576,
		578, 580, 582, 584, 586, 588, 590, 592, 594, 596, 598, 600, 602, 604, 606,
		608, 610, 612, 614, 616, 618, 620, 622, 624, 626, 628, 630, 632, 634, 636,
		638, 640, 0, 8, 1, 0, 131, 132, 2, 0, 2, 2, 82, 82, 9, 0, 8, 8, 36, 38,
		48, 48, 54, 54, 65, 65, 76, 76, 78, 78, 86, 86, 88, 90, 2, 0, 35, 35, 87,
		87, 2, 0, 51, 52, 63, 63, 2, 0, 33, 33, 81, 81, 2, 0, 83, 83, 115, 115,
		2, 0, 47, 47, 118, 118, 2412, 0, 642, 1, 0, 0, 0, 2, 645, 1, 0, 0, 0, 4,
		655, 1, 0, 0, 0, 6, 666, 1, 0, 0, 0, 8, 668, 1, 0, 0, 0, 10, 674, 1, 0,
		0, 0, 12, 676, 1, 0, 0, 0, 14, 680, 1, 0, 0, 0, 16, 693, 1, 0, 0, 0, 18,
		695, 1, 0, 0, 0, 20, 697, 1, 0, 0, 0, 22, 699, 1, 0, 0, 0, 24, 704, 1,
		0, 0, 0, 26, 707, 1, 0, 0, 0, 28, 709, 1, 0, 0, 0, 30, 711, 1, 0, 0, 0,
		32, 716, 1, 0, 0, 0, 34, 725, 1, 0, 0, 0, 36, 730, 1, 0, 0, 0, 38, 737,
		1, 0, 0, 0, 40, 747, 1, 0, 0, 0, 42, 751, 1, 0, 0, 0, 44, 753, 1, 0, 0,
		0, 46, 766, 1, 0, 0, 0, 48, 773, 1, 0, 0, 0, 50, 775, 1, 0, 0, 0, 52, 777,
		1, 0, 0, 0, 54, 779, 1, 0, 0, 0, 56, 781, 1, 0, 0, 0, 58, 783, 1, 0, 0,
		0, 60, 785, 1, 0, 0, 0, 62, 792, 1, 0, 0, 0, 64, 794, 1, 0, 0, 0, 66, 798,
		1, 0, 0, 0, 68, 802, 1, 0, 0, 0, 70, 806, 1, 0, 0, 0, 72, 810, 1, 0, 0,
		0, 74, 814, 1, 0, 0, 0, 76, 817, 1, 0, 0, 0, 78, 820, 1, 0, 0, 0, 80, 823,
		1, 0, 0, 0, 82, 826, 1, 0, 0, 0, 84, 829, 1, 0, 0, 0, 86, 836, 1, 0, 0,
		0, 88, 840, 1, 0, 0, 0, 90, 842, 1, 0, 0, 0, 92, 852, 1, 0, 0, 0, 94, 856,
		1, 0, 0, 0, 96, 862, 1, 0, 0, 0, 98, 867, 1, 0, 0, 0, 100, 883, 1, 0, 0,
		0, 102, 885, 1, 0, 0, 0, 104, 889, 1, 0, 0, 0, 106, 894, 1, 0, 0, 0, 108,
		896, 1, 0, 0, 0, 110, 901, 1, 0, 0, 0, 112, 906, 1, 0, 0, 0, 114, 910,
		1, 0, 0, 0, 116, 921, 1, 0, 0, 0, 118, 932, 1, 0, 0, 0, 120, 934, 1, 0,
		0, 0, 122, 948, 1, 0, 0, 0, 124, 952, 1, 0, 0, 0, 126, 954, 1, 0, 0, 0,
		128, 962, 1, 0, 0, 0, 130, 974, 1, 0, 0, 0, 132, 976, 1, 0, 0, 0, 134,
		987, 1, 0, 0, 0, 136, 989, 1, 0, 0, 0, 138, 992, 1, 0, 0, 0, 140, 1003,
		1, 0, 0, 0, 142, 1008, 1, 0, 0, 0, 144, 1010, 1, 0, 0, 0, 146, 1017, 1,
		0, 0, 0, 148, 1019, 1, 0, 0, 0, 150, 1033, 1, 0, 0, 0, 152, 1037, 1, 0,
		0, 0, 154, 1039, 1, 0, 0, 0, 156, 1050, 1, 0, 0, 0, 158, 1052, 1, 0, 0,
		0, 160, 1061, 1, 0, 0, 0, 162, 1076, 1, 0, 0, 0, 164, 1088, 1, 0, 0, 0,
		166, 1090, 1, 0, 0, 0, 168, 1112, 1, 0, 0, 0, 170, 1114, 1, 0, 0, 0, 172,
		1121, 1, 0, 0, 0, 174, 1123, 1, 0, 0, 0, 176, 1134, 1, 0, 0, 0, 178, 1145,
		1, 0, 0, 0, 180, 1150, 1, 0, 0, 0, 182, 1152, 1, 0, 0, 0, 184, 1180, 1,
		0, 0, 0, 186, 1185, 1, 0, 0, 0, 188, 1190, 1, 0, 0, 0, 190, 1195, 1, 0,
		0, 0, 192, 1201, 1, 0, 0, 0, 194, 1205, 1, 0, 0, 0, 196, 1207, 1, 0, 0,
		0, 198, 1209, 1, 0, 0, 0, 200, 1215, 1, 0, 0, 0, 202, 1228, 1, 0, 0, 0,
		204, 1230, 1, 0, 0, 0, 206, 1241, 1, 0, 0, 0, 208, 1243, 1, 0, 0, 0, 210,
		1247, 1, 0, 0, 0, 212, 1249, 1, 0, 0, 0, 214, 1254, 1, 0, 0, 0, 216, 1256,
		1, 0, 0, 0, 218, 1258, 1, 0, 0, 0, 220, 1260, 1, 0, 0, 0, 222, 1263, 1,
		0, 0, 0, 224, 1268, 1, 0, 0, 0, 226, 1270, 1, 0, 0, 0, 228, 1280, 1, 0,
		0, 0, 230, 1282, 1, 0, 0, 0, 232, 1284, 1, 0, 0, 0, 234, 1286, 1, 0, 0,
		0, 236, 1290, 1, 0, 0, 0, 238, 1293, 1, 0, 0, 0, 240, 1296, 1, 0, 0, 0,
		242, 1298, 1, 0, 0, 0, 244, 1300, 1, 0, 0, 0, 246, 1316, 1, 0, 0, 0, 248,
		1324, 1, 0, 0, 0, 250, 1340, 1, 0, 0, 0, 252, 1348, 1, 0, 0, 0, 254, 1352,
		1, 0, 0, 0, 256, 1354, 1, 0, 0, 0, 258, 1356, 1, 0, 0, 0, 260, 1384, 1,
		0, 0, 0, 262, 1388, 1, 0, 0, 0, 264, 1390, 1, 0, 0, 0, 266, 1393, 1, 0,
		0, 0, 268, 1400, 1, 0, 0, 0, 270, 1402, 1, 0, 0, 0, 272, 1404, 1, 0, 0,
		0, 274, 1408, 1, 0, 0, 0, 276, 1412, 1, 0, 0, 0, 278, 1421, 1, 0, 0, 0,
		280, 1425, 1, 0, 0, 0, 282, 1427, 1, 0, 0, 0, 284, 1470, 1, 0, 0, 0, 286,
		1476, 1, 0, 0, 0, 288, 1481, 1, 0, 0, 0, 290, 1483, 1, 0, 0, 0, 292, 1498,
		1, 0, 0, 0, 294, 1500, 1, 0, 0, 0, 296, 1511, 1, 0, 0, 0, 298, 1513, 1,
		0, 0, 0, 300, 1515, 1, 0, 0, 0, 302, 1517, 1, 0, 0, 0, 304, 1519, 1, 0,
		0, 0, 306, 1521, 1, 0, 0, 0, 308, 1523, 1, 0, 0, 0, 310, 1527, 1, 0, 0,
		0, 312, 1537, 1, 0, 0, 0, 314, 1547, 1, 0, 0, 0, 316, 1549, 1, 0, 0, 0,
		318, 1555, 1, 0, 0, 0, 320, 1557, 1, 0, 0, 0, 322, 1562, 1, 0, 0, 0, 324,
		1564, 1, 0, 0, 0, 326, 1574, 1, 0, 0, 0, 328, 1585, 1, 0, 0, 0, 330, 1596,
		1, 0, 0, 0, 332, 1599, 1, 0, 0, 0, 334, 1620, 1, 0, 0, 0, 336, 1622, 1,
		0, 0, 0, 338, 1626, 1, 0, 0, 0, 340, 1628, 1, 0, 0, 0, 342, 1632, 1, 0,
		0, 0, 344, 1634, 1, 0, 0, 0, 346, 1636, 1, 0, 0, 0, 348, 1638, 1, 0, 0,
		0, 350, 1642, 1, 0, 0, 0, 352, 1644, 1, 0, 0, 0, 354, 1650, 1, 0, 0, 0,
		356, 1654, 1, 0, 0, 0, 358, 1656, 1, 0, 0, 0, 360, 1658, 1, 0, 0, 0, 362,
		1662, 1, 0, 0, 0, 364, 1676, 1, 0, 0, 0, 366, 1684, 1, 0, 0, 0, 368, 1696,
		1, 0, 0, 0, 370, 1698, 1, 0, 0, 0, 372, 1700, 1, 0, 0, 0, 374, 1719, 1,
		0, 0, 0, 376, 1721, 1, 0, 0, 0, 378, 1727, 1, 0, 0, 0, 380, 1729, 1, 0,
		0, 0, 382, 1735, 1, 0, 0, 0, 384, 1739, 1, 0, 0, 0, 386, 1744, 1, 0, 0,
		0, 388, 1746, 1, 0, 0, 0, 390, 1753, 1, 0, 0, 0, 392, 1759, 1, 0, 0, 0,
		394, 1763, 1, 0, 0, 0, 396, 1767, 1, 0, 0, 0, 398, 1771, 1, 0, 0, 0, 400,
		1773, 1, 0, 0, 0, 402, 1777, 1, 0, 0, 0, 404, 1784, 1, 0, 0, 0, 406, 1795,
		1, 0, 0, 0, 408, 1799, 1, 0, 0, 0, 410, 1801, 1, 0, 0, 0, 412, 1806, 1,
		0, 0, 0, 414, 1816, 1, 0, 0, 0, 416, 1824, 1, 0, 0, 0, 418, 1831, 1, 0,
		0, 0, 420, 1833, 1, 0, 0, 0, 422, 1837, 1, 0, 0, 0, 424, 1845, 1, 0, 0,
		0, 426, 1847, 1, 0, 0, 0, 428, 1858, 1, 0, 0, 0, 430, 1864, 1, 0, 0, 0,
		432, 1866, 1, 0, 0, 0, 434, 1872, 1, 0, 0, 0, 436, 1890, 1, 0, 0, 0, 438,
		1892, 1, 0, 0, 0, 440, 1895, 1, 0, 0, 0, 442, 1902, 1, 0, 0, 0, 444, 1904,
		1, 0, 0, 0, 446, 1908, 1, 0, 0, 0, 448, 1912, 1, 0, 0, 0, 450, 1916, 1,
		0, 0, 0, 452, 1920, 1, 0, 0, 0, 454, 1927, 1, 0, 0, 0, 456, 1933, 1, 0,
		0, 0, 458, 1939, 1, 0, 0, 0, 460, 1945, 1, 0, 0, 0, 462, 1951, 1, 0, 0,
		0, 464, 1953, 1, 0, 0, 0, 466, 1957, 1, 0, 0, 0, 468, 1964, 1, 0, 0, 0,
		470, 1975, 1, 0, 0, 0, 472, 1979, 1, 0, 0, 0, 474, 1981, 1, 0, 0, 0, 476,
		1985, 1, 0, 0, 0, 478, 1988, 1, 0, 0, 0, 480, 2007, 1, 0, 0, 0, 482, 2009,
		1, 0, 0, 0, 484, 2011, 1, 0, 0, 0, 486, 2024, 1, 0, 0, 0, 488, 2029, 1,
		0, 0, 0, 490, 2031, 1, 0, 0, 0, 492, 2043, 1, 0, 0, 0, 494, 2046, 1, 0,
		0, 0, 496, 2058, 1, 0, 0, 0, 498, 2060, 1, 0, 0, 0, 500, 2064, 1, 0, 0,
		0, 502, 2068, 1, 0, 0, 0, 504, 2072, 1, 0, 0, 0, 506, 2078, 1, 0, 0, 0,
		508, 2083, 1, 0, 0, 0, 510, 2088, 1, 0, 0, 0, 512, 2090, 1, 0, 0, 0, 514,
		2108, 1, 0, 0, 0, 516, 2110, 1, 0, 0, 0, 518, 2132, 1, 0, 0, 0, 520, 2137,
		1, 0, 0, 0, 522, 2147, 1, 0, 0, 0, 524, 2153, 1, 0, 0, 0, 526, 2155, 1,
		0, 0, 0, 528, 2164, 1, 0, 0, 0, 530, 2177, 1, 0, 0, 0, 532, 2179, 1, 0,
		0, 0, 534, 2184, 1, 0, 0, 0, 536, 2188, 1, 0, 0, 0, 538, 2193, 1, 0, 0,
		0, 540, 2201, 1, 0, 0, 0, 542, 2206, 1, 0, 0, 0, 544, 2208, 1, 0, 0, 0,
		546, 2213, 1, 0, 0, 0, 548, 2217, 1, 0, 0, 0, 550, 2223, 1, 0, 0, 0, 552,
		2225, 1, 0, 0, 0, 554, 2228, 1, 0, 0, 0, 556, 2231, 1, 0, 0, 0, 558, 2242,
		1, 0, 0, 0, 560, 2246, 1, 0, 0, 0, 562, 2254, 1, 0, 0, 0, 564, 2256, 1,
		0, 0, 0, 566, 2258, 1, 0, 0, 0, 568, 2260, 1, 0, 0, 0, 570, 2263, 1, 0,
		0, 0, 572, 2267, 1, 0, 0, 0, 574, 2270, 1, 0, 0, 0, 576, 2279, 1, 0, 0,
		0, 578, 2281, 1, 0, 0, 0, 580, 2284, 1, 0, 0, 0, 582, 2287, 1, 0, 0, 0,
		584, 2289, 1, 0, 0, 0, 586, 2291, 1, 0, 0, 0, 588, 2301, 1, 0, 0, 0, 590,
		2307, 1, 0, 0, 0, 592, 2315, 1, 0, 0, 0, 594, 2317, 1, 0, 0, 0, 596, 2323,
		1, 0, 0, 0, 598, 2325, 1, 0, 0, 0, 600, 2327, 1, 0, 0, 0, 602, 2331, 1,
		0, 0, 0, 604, 2333, 1, 0, 0, 0, 606, 2337, 1, 0, 0, 0, 608, 2354, 1, 0,
		0, 0, 610, 2356, 1, 0, 0, 0, 612, 2359, 1, 0, 0, 0, 614, 2362, 1, 0, 0,
		0, 616, 2367, 1, 0, 0, 0, 618, 2373, 1, 0, 0, 0, 620, 2379, 1, 0, 0, 0,
		622, 2384, 1, 0, 0, 0, 624, 2390, 1, 0, 0, 0, 626, 2396, 1, 0, 0, 0, 628,
		2400, 1, 0, 0, 0, 630, 2416, 1, 0, 0, 0, 632, 2420, 1, 0, 0, 0, 634, 2422,
		1, 0, 0, 0, 636, 2426, 1, 0, 0, 0, 638, 2428, 1, 0, 0, 0, 640, 2430, 1,
		0, 0, 0, 642, 643, 3, 2, 1, 0, 643, 644, 5, 0, 0, 1, 644, 1, 1, 0, 0, 0,
		645, 646, 6, 1, -1, 0, 646, 647, 3, 4, 2, 0, 647, 652, 1, 0, 0, 0, 648,
		649, 10, 2, 0, 0, 649, 651, 3, 4, 2, 0, 650, 648, 1, 0, 0, 0, 651, 654,
		1, 0, 0, 0, 652, 650, 1, 0, 0, 0, 652, 653, 1, 0, 0, 0, 653, 3, 1, 0, 0,
		0, 654, 652, 1, 0, 0, 0, 655, 656, 3, 8, 4, 0, 656, 657, 5, 21, 0, 0, 657,
		658, 3, 32, 16, 0, 658, 659, 3, 34, 17, 0, 659, 660, 3, 36, 18, 0, 660,
		661, 5, 95, 0, 0, 661, 662, 5, 6, 0, 0, 662, 663, 3, 38, 19, 0, 663, 664,
		3, 640, 320, 0, 664, 665, 5, 26, 0, 0, 665, 5, 1, 0, 0, 0, 666, 667, 7,
		0, 0, 0, 667, 7, 1, 0, 0, 0, 668, 669, 3, 6, 3, 0, 669, 670, 3, 10, 5,
		0, 670, 9, 1, 0, 0, 0, 671, 675, 3, 12, 6, 0, 672, 675, 3, 24, 12, 0, 673,
		675, 1, 0, 0, 0, 674, 671, 1, 0, 0, 0, 674, 672, 1, 0, 0, 0, 674, 673,
		1, 0, 0, 0, 675, 11, 1, 0, 0, 0, 676, 677, 5, 104, 0, 0, 677, 678, 3, 14,
		7, 0, 678, 679, 5, 105, 0, 0, 679, 13, 1, 0, 0, 0, 680, 681, 6, 7, -1,
		0, 681, 682, 3, 16, 8, 0, 682, 687, 1, 0, 0, 0, 683, 684, 10, 2, 0, 0,
		684, 686, 3, 16, 8, 0, 685, 683, 1, 0, 0, 0, 686, 689, 1, 0, 0, 0, 687,
		685, 1, 0, 0, 0, 687, 688, 1, 0, 0, 0, 688, 15, 1, 0, 0, 0, 689, 687, 1,
		0, 0, 0, 690, 694, 3, 18, 9, 0, 691, 694, 3, 20, 10, 0, 692, 694, 3, 22,
		11, 0, 693, 690, 1, 0, 0, 0, 693, 691, 1, 0, 0, 0, 693, 692, 1, 0, 0, 0,
		694, 17, 1, 0, 0, 0, 695, 696, 5, 132, 0, 0, 696, 19, 1, 0, 0, 0, 697,
		698, 5, 126, 0, 0, 698, 21, 1, 0, 0, 0, 699, 700, 5, 132, 0, 0, 700, 701,
		5, 108, 0, 0, 701, 702, 3, 20, 10, 0, 702, 703, 5, 109, 0, 0, 703, 23,
		1, 0, 0, 0, 704, 705, 3, 12, 6, 0, 705, 706, 3, 30, 15, 0, 706, 25, 1,
		0, 0, 0, 707, 708, 1, 0, 0, 0, 708, 27, 1, 0, 0, 0, 709, 710, 1, 0, 0,
		0, 710, 29, 1, 0, 0, 0, 711, 712, 5, 129, 0, 0, 712, 31, 1, 0, 0, 0, 713,
		714, 5, 131, 0, 0, 714, 717, 5, 45, 0, 0, 715, 717, 1, 0, 0, 0, 716, 713,
		1, 0, 0, 0, 716, 715, 1, 0, 0, 0, 717, 33, 1, 0, 0, 0, 718, 719, 5, 29,
		0, 0, 719, 726, 5, 77, 0, 0, 720, 721, 5, 40, 0, 0, 721, 726, 5, 77, 0,
		0, 722, 723, 5, 5, 0, 0, 723, 726, 5, 77, 0, 0, 724, 726, 1, 0, 0, 0, 725,
		718, 1, 0, 0, 0, 725, 720, 1, 0, 0, 0, 725, 722, 1, 0, 0, 0, 725, 724,
		1, 0, 0, 0, 726, 35, 1, 0, 0, 0, 727, 728, 5, 31, 0, 0, 728, 731, 5, 41,
		0, 0, 729, 731, 1, 0, 0, 0, 730, 727, 1, 0, 0, 0, 730, 729, 1, 0, 0, 0,
		731, 37, 1, 0, 0, 0, 732, 733, 3, 40, 20, 0, 733, 734, 3, 86, 43, 0, 734,
		735, 3, 98, 49, 0, 735, 738, 1, 0, 0, 0, 736, 738, 1, 0, 0, 0, 737, 732,
		1, 0, 0, 0, 737, 736, 1, 0, 0, 0, 738, 39, 1, 0, 0, 0, 739, 740, 5, 30,
		0, 0, 740, 741, 3, 42, 21, 0, 741, 742, 5, 119, 0, 0, 742, 748, 1, 0, 0,
		0, 743, 744, 5, 30, 0, 0, 744, 745, 5, 3, 0, 0, 745, 748, 5, 119, 0, 0,
		746, 748, 1, 0, 0, 0, 747, 739, 1, 0, 0, 0, 747, 743, 1, 0, 0, 0, 747,
		746, 1, 0, 0, 0, 748, 41, 1, 0, 0, 0, 749, 752, 3, 44, 22, 0, 750, 752,
		1, 0, 0, 0, 751, 749, 1, 0, 0, 0, 751, 750, 1, 0, 0, 0, 752, 43, 1, 0,
		0, 0, 753, 754, 6, 22, -1, 0, 754, 755, 3, 46, 23, 0, 755, 761, 1, 0, 0,
		0, 756, 757, 10, 2, 0, 0, 757, 758, 5, 113, 0, 0, 758, 760, 3, 46, 23,
		0, 759, 756, 1, 0, 0, 0, 760, 763, 1, 0, 0, 0, 761, 759, 1, 0, 0, 0, 761,
		762, 1, 0, 0, 0, 762, 45, 1, 0, 0, 0, 763, 761, 1, 0, 0, 0, 764, 767, 3,
		48, 24, 0, 765, 767, 3, 62, 31, 0, 766, 764, 1, 0, 0, 0, 766, 765, 1, 0,
		0, 0, 767, 47, 1, 0, 0, 0, 768, 774, 3, 52, 26, 0, 769, 774, 3, 54, 27,
		0, 770, 774, 3, 58, 29, 0, 771, 774, 3, 56, 28, 0, 772, 774, 3, 60, 30,
		0, 773, 768, 1, 0, 0, 0, 773, 769, 1, 0, 0, 0, 773, 770, 1, 0, 0, 0, 773,
		771, 1, 0, 0, 0, 773, 772, 1, 0, 0, 0, 774, 49, 1, 0, 0, 0, 775, 776, 5,
		132, 0, 0, 776, 51, 1, 0, 0, 0, 777, 778, 5, 131, 0, 0, 778, 53, 1, 0,
		0, 0, 779, 780, 5, 132, 0, 0, 780, 55, 1, 0, 0, 0, 781, 782, 5, 132, 0,
		0, 782, 57, 1, 0, 0, 0, 783, 784, 5, 131, 0, 0, 784, 59, 1, 0, 0, 0, 785,
		786, 5, 131, 0, 0, 786, 61, 1, 0, 0, 0, 787, 793, 3, 48, 24, 0, 788, 789,
		3, 48, 24, 0, 789, 790, 5, 104, 0, 0, 790, 791, 5, 105, 0, 0, 791, 793,
		1, 0, 0, 0, 792, 787, 1, 0, 0, 0, 792, 788, 1, 0, 0, 0, 793, 63, 1, 0,
		0, 0, 794, 795, 3, 6, 3, 0, 795, 796, 5, 120, 0, 0, 796, 797, 3, 52, 26,
		0, 797, 65, 1, 0, 0, 0, 798, 799, 3, 6, 3, 0, 799, 800, 5, 120, 0, 0, 800,
		801, 3, 54, 27, 0, 801, 67, 1, 0, 0, 0, 802, 803, 3, 6, 3, 0, 803, 804,
		5, 120, 0, 0, 804, 805, 3, 58, 29, 0, 805, 69, 1, 0, 0, 0, 806, 807, 3,
		6, 3, 0, 807, 808, 5, 120, 0, 0, 808, 809, 3, 56, 28, 0, 809, 71, 1, 0,
		0, 0, 810, 811, 3, 6, 3, 0, 811, 812, 5, 120, 0, 0, 812, 813, 3, 60, 30,
		0, 813, 73, 1, 0, 0, 0, 814, 815, 5, 103, 0, 0, 815, 816, 5, 131, 0, 0,
		816, 75, 1, 0, 0, 0, 817, 818, 5, 103, 0, 0, 818, 819, 5, 132, 0, 0, 819,
		77, 1, 0, 0, 0, 820, 821, 5, 103, 0, 0, 821, 822, 5, 131, 0, 0, 822, 79,
		1, 0, 0, 0, 823, 824, 5, 103, 0, 0, 824, 825, 5, 132, 0, 0, 825, 81, 1,
		0, 0, 0, 826, 827, 5, 103, 0, 0, 827, 828, 5, 131, 0, 0, 828, 83, 1, 0,
		0, 0, 829, 830, 7, 1, 0, 0, 830, 85, 1, 0, 0, 0, 831, 832, 5, 42, 0, 0,
		832, 833, 3, 88, 44, 0, 833, 834, 5, 119, 0, 0, 834, 837, 1, 0, 0, 0, 835,
		837, 1, 0, 0, 0, 836, 831, 1, 0, 0, 0, 836, 835, 1, 0, 0, 0, 837, 87, 1,
		0, 0, 0, 838, 841, 3, 90, 45, 0, 839, 841, 1, 0, 0, 0, 840, 838, 1, 0,
		0, 0, 840, 839, 1, 0, 0, 0, 841, 89, 1, 0, 0, 0, 842, 843, 6, 45, -1, 0,
		843, 844, 3, 92, 46, 0, 844, 849, 1, 0, 0, 0, 845, 846, 10, 2, 0, 0, 846,
		848, 3, 92, 46, 0, 847, 845, 1, 0, 0, 0, 848, 851, 1, 0, 0, 0, 849, 847,
		1, 0, 0, 0, 849, 850, 1, 0, 0, 0, 850, 91, 1, 0, 0, 0, 851, 849, 1, 0,
		0, 0, 852, 853, 3, 44, 22, 0, 853, 854, 5, 34, 0, 0, 854, 855, 3, 94, 47,
		0, 855, 93, 1, 0, 0, 0, 856, 857, 3, 6, 3, 0, 857, 858, 3, 96, 48, 0, 858,
		95, 1, 0, 0, 0, 859, 863, 3, 118, 59, 0, 860, 863, 3, 128, 64, 0, 861,
		863, 1, 0, 0, 0, 862, 859, 1, 0, 0, 0, 862, 860, 1, 0, 0, 0, 862, 861,
		1, 0, 0, 0, 863, 97, 1, 0, 0, 0, 864, 865, 6, 49, -1, 0, 865, 868, 3, 100,
		50, 0, 866, 868, 1, 0, 0, 0, 867, 864, 1, 0, 0, 0, 867, 866, 1, 0, 0, 0,
		868, 873, 1, 0, 0, 0, 869, 870, 10, 3, 0, 0, 870, 872, 3, 100, 50, 0, 871,
		869, 1, 0, 0, 0, 872, 875, 1, 0, 0, 0, 873, 871, 1, 0, 0, 0, 873, 874,
		1, 0, 0, 0, 874, 99, 1, 0, 0, 0, 875, 873, 1, 0, 0, 0, 876, 884, 3, 102,
		51, 0, 877, 884, 3, 104, 52, 0, 878, 884, 3, 108, 54, 0, 879, 884, 3, 112,
		56, 0, 880, 884, 3, 110, 55, 0, 881, 884, 3, 114, 57, 0, 882, 884, 3, 116,
		58, 0, 883, 876, 1, 0, 0, 0, 883, 877, 1, 0, 0, 0, 883, 878, 1, 0, 0, 0,
		883, 879, 1, 0, 0, 0, 883, 880, 1, 0, 0, 0, 883, 881, 1, 0, 0, 0, 883,
		882, 1, 0, 0, 0, 884, 101, 1, 0, 0, 0, 885, 886, 3, 52, 26, 0, 886, 887,
		5, 95, 0, 0, 887, 888, 3, 288, 144, 0, 888, 103, 1, 0, 0, 0, 889, 890,
		3, 54, 27, 0, 890, 891, 3, 288, 144, 0, 891, 892, 5, 95, 0, 0, 892, 893,
		3, 386, 193, 0, 893, 105, 1, 0, 0, 0, 894, 895, 1, 0, 0, 0, 895, 107, 1,
		0, 0, 0, 896, 897, 3, 52, 26, 0, 897, 898, 3, 288, 144, 0, 898, 899, 5,
		95, 0, 0, 899, 900, 3, 388, 194, 0, 900, 109, 1, 0, 0, 0, 901, 902, 3,
		56, 28, 0, 902, 903, 3, 390, 195, 0, 903, 904, 5, 95, 0, 0, 904, 905, 3,
		392, 196, 0, 905, 111, 1, 0, 0, 0, 906, 907, 3, 58, 29, 0, 907, 908, 5,
		95, 0, 0, 908, 909, 3, 430, 215, 0, 909, 113, 1, 0, 0, 0, 910, 911, 3,
		60, 30, 0, 911, 912, 3, 390, 195, 0, 912, 913, 5, 95, 0, 0, 913, 914, 3,
		478, 239, 0, 914, 115, 1, 0, 0, 0, 915, 922, 3, 614, 307, 0, 916, 922,
		3, 616, 308, 0, 917, 922, 3, 618, 309, 0, 918, 922, 3, 620, 310, 0, 919,
		922, 3, 622, 311, 0, 920, 922, 3, 624, 312, 0, 921, 915, 1, 0, 0, 0, 921,
		916, 1, 0, 0, 0, 921, 917, 1, 0, 0, 0, 921, 918, 1, 0, 0, 0, 921, 919,
		1, 0, 0, 0, 921, 920, 1, 0, 0, 0, 922, 117, 1, 0, 0, 0, 923, 924, 5, 104,
		0, 0, 924, 925, 3, 120, 60, 0, 925, 926, 5, 105, 0, 0, 926, 933, 1, 0,
		0, 0, 927, 928, 5, 104, 0, 0, 928, 929, 3, 128, 64, 0, 929, 930, 3, 120,
		60, 0, 930, 931, 5, 105, 0, 0, 931, 933, 1, 0, 0, 0, 932, 923, 1, 0, 0,
		0, 932, 927, 1, 0, 0, 0, 933, 119, 1, 0, 0, 0, 934, 935, 6, 60, -1, 0,
		935, 936, 3, 122, 61, 0, 936, 941, 1, 0, 0, 0, 937, 938, 10, 2, 0, 0, 938,
		940, 3, 122, 61, 0, 939, 937, 1, 0, 0, 0, 940, 943, 1, 0, 0, 0, 941, 939,
		1, 0, 0, 0, 941, 942, 1, 0, 0, 0, 942, 121, 1, 0, 0, 0, 943, 941, 1, 0,
		0, 0, 944, 949, 3, 18, 9, 0, 945, 949, 3, 124, 62, 0, 946, 949, 3, 126,
		63, 0, 947, 949, 3, 128, 64, 0, 948, 944, 1, 0, 0, 0, 948, 945, 1, 0, 0,
		0, 948, 946, 1, 0, 0, 0, 948, 947, 1, 0, 0, 0, 949, 123, 1, 0, 0, 0, 950,
		953, 5, 126, 0, 0, 951, 953, 3, 128, 64, 0, 952, 950, 1, 0, 0, 0, 952,
		951, 1, 0, 0, 0, 953, 125, 1, 0, 0, 0, 954, 955, 3, 50, 25, 0, 955, 956,
		5, 104, 0, 0, 956, 957, 3, 124, 62, 0, 957, 958, 5, 105, 0, 0, 958, 127,
		1, 0, 0, 0, 959, 963, 3, 66, 33, 0, 960, 963, 3, 54, 27, 0, 961, 963, 3,
		612, 306, 0, 962, 959, 1, 0, 0, 0, 962, 960, 1, 0, 0, 0, 962, 961, 1, 0,
		0, 0, 963, 129, 1, 0, 0, 0, 964, 965, 3, 50, 25, 0, 965, 966, 5, 108, 0,
		0, 966, 967, 5, 126, 0, 0, 967, 968, 5, 109, 0, 0, 968, 975, 1, 0, 0, 0,
		969, 970, 3, 50, 25, 0, 970, 971, 5, 108, 0, 0, 971, 972, 3, 128, 64, 0,
		972, 973, 5, 109, 0, 0, 973, 975, 1, 0, 0, 0, 974, 964, 1, 0, 0, 0, 974,
		969, 1, 0, 0, 0, 975, 131, 1, 0, 0, 0, 976, 977, 6, 66, -1, 0, 977, 978,
		3, 130, 65, 0, 978, 984, 1, 0, 0, 0, 979, 980, 10, 2, 0, 0, 980, 981, 5,
		113, 0, 0, 981, 983, 3, 130, 65, 0, 982, 979, 1, 0, 0, 0, 983, 986, 1,
		0, 0, 0, 984, 982, 1, 0, 0, 0, 984, 985, 1, 0, 0, 0, 985, 133, 1, 0, 0,
		0, 986, 984, 1, 0, 0, 0, 987, 988, 7, 2, 0, 0, 988, 135, 1, 0, 0, 0, 989,
		990, 5, 11, 0, 0, 990, 991, 5, 74, 0, 0, 991, 137, 1, 0, 0, 0, 992, 993,
		6, 69, -1, 0, 993, 994, 3, 282, 141, 0, 994, 1000, 1, 0, 0, 0, 995, 996,
		10, 2, 0, 0, 996, 997, 5, 113, 0, 0, 997, 999, 3, 282, 141, 0, 998, 995,
		1, 0, 0, 0, 999, 1002, 1, 0, 0, 0, 1000, 998, 1, 0, 0, 0, 1000, 1001, 1,
		0, 0, 0, 1001, 139, 1, 0, 0, 0, 1002, 1000, 1, 0, 0, 0, 1003, 1004, 3,
		138, 69, 0, 1004, 141, 1, 0, 0, 0, 1005, 1006, 5, 126, 0, 0, 1006, 1009,
		5, 110, 0, 0, 1007, 1009, 1, 0, 0, 0, 1008, 1005, 1, 0, 0, 0, 1008, 1007,
		1, 0, 0, 0, 1009, 143, 1, 0, 0, 0, 1010, 1011, 5, 98, 0, 0, 1011, 1012,
		3, 142, 71, 0, 1012, 1013, 3, 138, 69, 0, 1013, 1014, 5, 99, 0, 0, 1014,
		145, 1, 0, 0, 0, 1015, 1018, 3, 144, 72, 0, 1016, 1018, 3, 282, 141, 0,
		1017, 1015, 1, 0, 0, 0, 1017, 1016, 1, 0, 0, 0, 1018, 147, 1, 0, 0, 0,
		1019, 1020, 6, 74, -1, 0, 1020, 1021, 3, 146, 73, 0, 1021, 1027, 1, 0,
		0, 0, 1022, 1023, 10, 2, 0, 0, 1023, 1024, 5, 113, 0, 0, 1024, 1026, 3,
		146, 73, 0, 1025, 1022, 1, 0, 0, 0, 1026, 1029, 1, 0, 0, 0, 1027, 1025,
		1, 0, 0, 0, 1027, 1028, 1, 0, 0, 0, 1028, 149, 1, 0, 0, 0, 1029, 1027,
		1, 0, 0, 0, 1030, 1031, 5, 113, 0, 0, 1031, 1034, 3, 148, 74, 0, 1032,
		1034, 1, 0, 0, 0, 1033, 1030, 1, 0, 0, 0, 1033, 1032, 1, 0, 0, 0, 1034,
		151, 1, 0, 0, 0, 1035, 1038, 3, 164, 82, 0, 1036, 1038, 3, 50, 25, 0, 1037,
		1035, 1, 0, 0, 0, 1037, 1036, 1, 0, 0, 0, 1038, 153, 1, 0, 0, 0, 1039,
		1040, 6, 77, -1, 0, 1040, 1041, 3, 152, 76, 0, 1041, 1047, 1, 0, 0, 0,
		1042, 1043, 10, 2, 0, 0, 1043, 1044, 5, 113, 0, 0, 1044, 1046, 3, 152,
		76, 0, 1045, 1042, 1, 0, 0, 0, 1046, 1049, 1, 0, 0, 0, 1047, 1045, 1, 0,
		0, 0, 1047, 1048, 1, 0, 0, 0, 1048, 155, 1, 0, 0, 0, 1049, 1047, 1, 0,
		0, 0, 1050, 1051, 3, 154, 77, 0, 1051, 157, 1, 0, 0, 0, 1052, 1053, 3,
		154, 77, 0, 1053, 159, 1, 0, 0, 0, 1054, 1055, 3, 140, 70, 0, 1055, 1056,
		5, 113, 0, 0, 1056, 1057, 3, 186, 93, 0, 1057, 1058, 3, 150, 75, 0, 1058,
		1059, 3, 188, 94, 0, 1059, 1062, 1, 0, 0, 0, 1060, 1062, 3, 140, 70, 0,
		1061, 1054, 1, 0, 0, 0, 1061, 1060, 1, 0, 0, 0, 1062, 161, 1, 0, 0, 0,
		1063, 1064, 3, 156, 78, 0, 1064, 1065, 5, 113, 0, 0, 1065, 1066, 5, 96,
		0, 0, 1066, 1067, 3, 542, 271, 0, 1067, 1068, 5, 113, 0, 0, 1068, 1069,
		3, 158, 79, 0, 1069, 1077, 1, 0, 0, 0, 1070, 1071, 3, 156, 78, 0, 1071,
		1072, 5, 113, 0, 0, 1072, 1073, 5, 96, 0, 0, 1073, 1074, 3, 542, 271, 0,
		1074, 1077, 1, 0, 0, 0, 1075, 1077, 3, 156, 78, 0, 1076, 1063, 1, 0, 0,
		0, 1076, 1070, 1, 0, 0, 0, 1076, 1075, 1, 0, 0, 0, 1077, 163, 1, 0, 0,
		0, 1078, 1079, 3, 50, 25, 0, 1079, 1080, 5, 108, 0, 0, 1080, 1081, 3, 538,
		269, 0, 1081, 1082, 5, 109, 0, 0, 1082, 1089, 1, 0, 0, 0, 1083, 1084, 3,
		50, 25, 0, 1084, 1085, 5, 108, 0, 0, 1085, 1086, 3, 128, 64, 0, 1086, 1087,
		5, 109, 0, 0, 1087, 1089, 1, 0, 0, 0, 1088, 1078, 1, 0, 0, 0, 1088, 1083,
		1, 0, 0, 0, 1089, 165, 1, 0, 0, 0, 1090, 1091, 6, 83, -1, 0, 1091, 1092,
		3, 164, 82, 0, 1092, 1098, 1, 0, 0, 0, 1093, 1094, 10, 2, 0, 0, 1094, 1095,
		5, 113, 0, 0, 1095, 1097, 3, 164, 82, 0, 1096, 1093, 1, 0, 0, 0, 1097,
		1100, 1, 0, 0, 0, 1098, 1096, 1, 0, 0, 0, 1098, 1099, 1, 0, 0, 0, 1099,
		167, 1, 0, 0, 0, 1100, 1098, 1, 0, 0, 0, 1101, 1102, 5, 15, 0, 0, 1102,
		1103, 5, 58, 0, 0, 1103, 1113, 3, 288, 144, 0, 1104, 1105, 3, 282, 141,
		0, 1105, 1106, 5, 20, 0, 0, 1106, 1107, 3, 386, 193, 0, 1107, 1113, 1,
		0, 0, 0, 1108, 1109, 3, 282, 141, 0, 1109, 1110, 5, 60, 0, 0, 1110, 1113,
		1, 0, 0, 0, 1111, 1113, 3, 282, 141, 0, 1112, 1101, 1, 0, 0, 0, 1112, 1104,
		1, 0, 0, 0, 1112, 1108, 1, 0, 0, 0, 1112, 1111, 1, 0, 0, 0, 1113, 169,
		1, 0, 0, 0, 1114, 1115, 5, 98, 0, 0, 1115, 1116, 3, 142, 71, 0, 1116, 1117,
		3, 174, 87, 0, 1117, 1118, 5, 99, 0, 0, 1118, 171, 1, 0, 0, 0, 1119, 1122,
		3, 168, 84, 0, 1120, 1122, 3, 170, 85, 0, 1121, 1119, 1, 0, 0, 0, 1121,
		1120, 1, 0, 0, 0, 1122, 173, 1, 0, 0, 0, 1123, 1124, 6, 87, -1, 0, 1124,
		1125, 3, 168, 84, 0, 1125, 1131, 1, 0, 0, 0, 1126, 1127, 10, 2, 0, 0, 1127,
		1128, 5, 113, 0, 0, 1128, 1130, 3, 168, 84, 0, 1129, 1126, 1, 0, 0, 0,
		1130, 1133, 1, 0, 0, 0, 1131, 1129, 1, 0, 0, 0, 1131, 1132, 1, 0, 0, 0,
		1132, 175, 1, 0, 0, 0, 1133, 1131, 1, 0, 0, 0, 1134, 1135, 6, 88, -1, 0,
		1135, 1136, 3, 172, 86, 0, 1136, 1142, 1, 0, 0, 0, 1137, 1138, 10, 2, 0,
		0, 1138, 1139, 5, 113, 0, 0, 1139, 1141, 3, 172, 86, 0, 1140, 1137, 1,
		0, 0, 0, 1141, 1144, 1, 0, 0, 0, 1142, 1140, 1, 0, 0, 0, 1142, 1143, 1,
		0, 0, 0, 1143, 177, 1, 0, 0, 0, 1144, 1142, 1, 0, 0, 0, 1145, 1146, 3,
		174, 87, 0, 1146, 179, 1, 0, 0, 0, 1147, 1148, 5, 113, 0, 0, 1148, 1151,
		3, 176, 88, 0, 1149, 1151, 1, 0, 0, 0, 1150, 1147, 1, 0, 0, 0, 1150, 1149,
		1, 0, 0, 0, 1151, 181, 1, 0, 0, 0, 1152, 1153, 5, 113, 0, 0, 1153, 1154,
		5, 96, 0, 0, 1154, 183, 1, 0, 0, 0, 1155, 1156, 3, 178, 89, 0, 1156, 1157,
		3, 180, 90, 0, 1157, 1158, 3, 182, 91, 0, 1158, 1159, 5, 113, 0, 0, 1159,
		1160, 3, 178, 89, 0, 1160, 1181, 1, 0, 0, 0, 1161, 1162, 3, 178, 89, 0,
		1162, 1163, 3, 180, 90, 0, 1163, 1164, 3, 188, 94, 0, 1164, 1181, 1, 0,
		0, 0, 1165, 1166, 3, 178, 89, 0, 1166, 1167, 5, 113, 0, 0, 1167, 1168,
		3, 186, 93, 0, 1168, 1169, 3, 180, 90, 0, 1169, 1170, 3, 182, 91, 0, 1170,
		1171, 5, 113, 0, 0, 1171, 1172, 3, 178, 89, 0, 1172, 1181, 1, 0, 0, 0,
		1173, 1174, 3, 178, 89, 0, 1174, 1175, 5, 113, 0, 0, 1175, 1176, 3, 186,
		93, 0, 1176, 1177, 3, 180, 90, 0, 1177, 1178, 3, 188, 94, 0, 1178, 1181,
		1, 0, 0, 0, 1179, 1181, 3, 178, 89, 0, 1180, 1155, 1, 0, 0, 0, 1180, 1161,
		1, 0, 0, 0, 1180, 1165, 1, 0, 0, 0, 1180, 1173, 1, 0, 0, 0, 1180, 1179,
		1, 0, 0, 0, 1181, 185, 1, 0, 0, 0, 1182, 1183, 5, 96, 0, 0, 1183, 1186,
		3, 542, 271, 0, 1184, 1186, 5, 96, 0, 0, 1185, 1182, 1, 0, 0, 0, 1185,
		1184, 1, 0, 0, 0, 1186, 187, 1, 0, 0, 0, 1187, 1188, 5, 113, 0, 0, 1188,
		1191, 5, 96, 0, 0, 1189, 1191, 1, 0, 0, 0, 1190, 1187, 1, 0, 0, 0, 1190,
		1189, 1, 0, 0, 0, 1191, 189, 1, 0, 0, 0, 1192, 1193, 5, 131, 0, 0, 1193,
		1196, 5, 110, 0, 0, 1194, 1196, 1, 0, 0, 0, 1195, 1192, 1, 0, 0, 0, 1195,
		1194, 1, 0, 0, 0, 1196, 191, 1, 0, 0, 0, 1197, 1202, 5, 85, 0, 0, 1198,
		1202, 5, 4, 0, 0, 1199, 1202, 5, 66, 0, 0, 1200, 1202, 1, 0, 0, 0, 1201,
		1197, 1, 0, 0, 0, 1201, 1198, 1, 0, 0, 0, 1201, 1199, 1, 0, 0, 0, 1201,
		1200, 1, 0, 0, 0, 1202, 193, 1, 0, 0, 0, 1203, 1206, 5, 126, 0, 0, 1204,
		1206, 3, 128, 64, 0, 1205, 1203, 1, 0, 0, 0, 1205, 1204, 1, 0, 0, 0, 1206,
		195, 1, 0, 0, 0, 1207, 1208, 7, 0, 0, 0, 1208, 197, 1, 0, 0, 0, 1209, 1210,
		5, 106, 0, 0, 1210, 1211, 3, 190, 95, 0, 1211, 1212, 3, 192, 96, 0, 1212,
		1213, 3, 194, 97, 0, 1213, 1214, 5, 107, 0, 0, 1214, 199, 1, 0, 0, 0, 1215,
		1216, 5, 106, 0, 0, 1216, 1217, 3, 190, 95, 0, 1217, 1218, 3, 196, 98,
		0, 1218, 1219, 5, 107, 0, 0, 1219, 201, 1, 0, 0, 0, 1220, 1221, 3, 198,
		99, 0, 1221, 1222, 5, 40, 0, 0, 1222, 1223, 3, 288, 144, 0, 1223, 1229,
		1, 0, 0, 0, 1224, 1225, 3, 198, 99, 0, 1225, 1226, 5, 29, 0, 0, 1226, 1227,
		3, 288, 144, 0, 1227, 1229, 1, 0, 0, 0, 1228, 1220, 1, 0, 0, 0, 1228, 1224,
		1, 0, 0, 0, 1229, 203, 1, 0, 0, 0, 1230, 1231, 3, 200, 100, 0, 1231, 1232,
		3, 288, 144, 0, 1232, 205, 1, 0, 0, 0, 1233, 1234, 5, 7, 0, 0, 1234, 1235,
		5, 74, 0, 0, 1235, 1236, 5, 104, 0, 0, 1236, 1237, 3, 132, 66, 0, 1237,
		1238, 5, 105, 0, 0, 1238, 1242, 1, 0, 0, 0, 1239, 1240, 5, 7, 0, 0, 1240,
		1242, 5, 74, 0, 0, 1241, 1233, 1, 0, 0, 0, 1241, 1239, 1, 0, 0, 0, 1242,
		207, 1, 0, 0, 0, 1243, 1244, 5, 9, 0, 0, 1244, 209, 1, 0, 0, 0, 1245, 1248,
		3, 134, 67, 0, 1246, 1248, 3, 136, 68, 0, 1247, 1245, 1, 0, 0, 0, 1247,
		1246, 1, 0, 0, 0, 1248, 211, 1, 0, 0, 0, 1249, 1250, 5, 12, 0, 0, 1250,
		1251, 5, 104, 0, 0, 1251, 1252, 3, 160, 80, 0, 1252, 1253, 5, 105, 0, 0,
		1253, 213, 1, 0, 0, 0, 1254, 1255, 5, 18, 0, 0, 1255, 215, 1, 0, 0, 0,
		1256, 1257, 5, 19, 0, 0, 1257, 217, 1, 0, 0, 0, 1258, 1259, 5, 22, 0, 0,
		1259, 219, 1, 0, 0, 0, 1260, 1261, 5, 23, 0, 0, 1261, 1262, 5, 62, 0, 0,
		1262, 221, 1, 0, 0, 0, 1263, 1264, 5, 27, 0, 0, 1264, 1265, 5, 104, 0,
		0, 1265, 1266, 3, 162, 81, 0, 1266, 1267, 5, 105, 0, 0, 1267, 223, 1, 0,
		0, 0, 1268, 1269, 5, 32, 0, 0, 1269, 225, 1, 0, 0, 0, 1270, 1271, 5, 44,
		0, 0, 1271, 1272, 5, 58, 0, 0, 1272, 1273, 3, 390, 195, 0, 1273, 227, 1,
		0, 0, 0, 1274, 1275, 5, 46, 0, 0, 1275, 1276, 5, 104, 0, 0, 1276, 1277,
		3, 166, 83, 0, 1277, 1278, 5, 105, 0, 0, 1278, 1281, 1, 0, 0, 0, 1279,
		1281, 5, 46, 0, 0, 1280, 1274, 1, 0, 0, 0, 1280, 1279, 1, 0, 0, 0, 1281,
		229, 1, 0, 0, 0, 1282, 1283, 5, 59, 0, 0, 1283, 231, 1, 0, 0, 0, 1284,
		1285, 5, 53, 0, 0, 1285, 233, 1, 0, 0, 0, 1286, 1287, 3, 390, 195, 0, 1287,
		1288, 5, 120, 0, 0, 1288, 1289, 3, 426, 213, 0, 1289, 235, 1, 0, 0, 0,
		1290, 1291, 5, 55, 0, 0, 1291, 1292, 5, 39, 0, 0, 1292, 237, 1, 0, 0, 0,
		1293, 1294, 5, 57, 0, 0, 1294, 1295, 5, 74, 0, 0, 1295, 239, 1, 0, 0, 0,
		1296, 1297, 5, 67, 0, 0, 1297, 241, 1, 0, 0, 0, 1298, 1299, 5, 69, 0, 0,
		1299, 243, 1, 0, 0, 0, 1300, 1301, 5, 68, 0, 0, 1301, 245, 1, 0, 0, 0,
		1302, 1303, 5, 70, 0, 0, 1303, 1304, 5, 104, 0, 0, 1304, 1317, 5, 105,
		0, 0, 1305, 1306, 5, 70, 0, 0, 1306, 1307, 5, 104, 0, 0, 1307, 1308, 3,
		186, 93, 0, 1308, 1309, 3, 188, 94, 0, 1309, 1310, 5, 105, 0, 0, 1310,
		1317, 1, 0, 0, 0, 1311, 1312, 5, 70, 0, 0, 1312, 1313, 5, 104, 0, 0, 1313,
		1314, 3, 184, 92, 0, 1314, 1315, 5, 105, 0, 0, 1315, 1317, 1, 0, 0, 0,
		1316, 1302, 1, 0, 0, 0, 1316, 1305, 1, 0, 0, 0, 1316, 1311, 1, 0, 0, 0,
		1317, 247, 1, 0, 0, 0, 1318, 1319, 5, 70, 0, 0, 1319, 1320, 5, 58, 0, 0,
		1320, 1325, 3, 282, 141, 0, 1321, 1322, 5, 70, 0, 0, 1322, 1323, 5, 58,
		0, 0, 1323, 1325, 3, 288, 144, 0, 1324, 1318, 1, 0, 0, 0, 1324, 1321, 1,
		0, 0, 0, 1325, 249, 1, 0, 0, 0, 1326, 1327, 5, 71, 0, 0, 1327, 1328, 5,
		104, 0, 0, 1328, 1329, 3, 184, 92, 0, 1329, 1330, 5, 105, 0, 0, 1330, 1341,
		1, 0, 0, 0, 1331, 1332, 5, 71, 0, 0, 1332, 1333, 5, 104, 0, 0, 1333, 1334,
		3, 186, 93, 0, 1334, 1335, 3, 188, 94, 0, 1335, 1336, 5, 105, 0, 0, 1336,
		1341, 1, 0, 0, 0, 1337, 1338, 5, 71, 0, 0, 1338, 1339, 5, 104, 0, 0, 1339,
		1341, 5, 105, 0, 0, 1340, 1326, 1, 0, 0, 0, 1340, 1331, 1, 0, 0, 0, 1340,
		1337, 1, 0, 0, 0, 1341, 251, 1, 0, 0, 0, 1342, 1343, 5, 71, 0, 0, 1343,
		1344, 5, 58, 0, 0, 1344, 1349, 3, 282, 141, 0, 1345, 1346, 5, 71, 0, 0,
		1346, 1347, 5, 58, 0, 0, 1347, 1349, 3, 288, 144, 0, 1348, 1342, 1, 0,
		0, 0, 1348, 1345, 1, 0, 0, 0, 1349, 253, 1, 0, 0, 0, 1350, 1353, 3, 202,
		101, 0, 1351, 1353, 3, 204, 102, 0, 1352, 1350, 1, 0, 0, 0, 1352, 1351,
		1, 0, 0, 0, 1353, 255, 1, 0, 0, 0, 1354, 1355, 5, 79, 0, 0, 1355, 257,
		1, 0, 0, 0, 1356, 1357, 5, 80, 0, 0, 1357, 259, 1, 0, 0, 0, 1358, 1385,
		3, 206, 103, 0, 1359, 1385, 3, 208, 104, 0, 1360, 1385, 3, 210, 105, 0,
		1361, 1385, 3, 212, 106, 0, 1362, 1385, 3, 214, 107, 0, 1363, 1385, 3,
		216, 108, 0, 1364, 1385, 3, 218, 109, 0, 1365, 1385, 3, 220, 110, 0, 1366,
		1385, 3, 222, 111, 0, 1367, 1385, 3, 224, 112, 0, 1368, 1385, 3, 226, 113,
		0, 1369, 1385, 3, 228, 114, 0, 1370, 1385, 3, 230, 115, 0, 1371, 1385,
		3, 232, 116, 0, 1372, 1385, 3, 234, 117, 0, 1373, 1385, 3, 236, 118, 0,
		1374, 1385, 3, 238, 119, 0, 1375, 1385, 3, 240, 120, 0, 1376, 1385, 3,
		242, 121, 0, 1377, 1385, 3, 244, 122, 0, 1378, 1385, 3, 246, 123, 0, 1379,
		1385, 3, 248, 124, 0, 1380, 1385, 3, 250, 125, 0, 1381, 1385, 3, 252, 126,
		0, 1382, 1385, 3, 256, 128, 0, 1383, 1385, 3, 258, 129, 0, 1384, 1358,
		1, 0, 0, 0, 1384, 1359, 1, 0, 0, 0, 1384, 1360, 1, 0, 0, 0, 1384, 1361,
		1, 0, 0, 0, 1384, 1362, 1, 0, 0, 0, 1384, 1363, 1, 0, 0, 0, 1384, 1364,
		1, 0, 0, 0, 1384, 1365, 1, 0, 0, 0, 1384, 1366, 1, 0, 0, 0, 1384, 1367,
		1, 0, 0, 0, 1384, 1368, 1, 0, 0, 0, 1384, 1369, 1, 0, 0, 0, 1384, 1370,
		1, 0, 0, 0, 1384, 1371, 1, 0, 0, 0, 1384, 1372, 1, 0, 0, 0, 1384, 1373,
		1, 0, 0, 0, 1384, 1374, 1, 0, 0, 0, 1384, 1375, 1, 0, 0, 0, 1384, 1376,
		1, 0, 0, 0, 1384, 1377, 1, 0, 0, 0, 1384, 1378, 1, 0, 0, 0, 1384, 1379,
		1, 0, 0, 0, 1384, 1380, 1, 0, 0, 0, 1384, 1381, 1, 0, 0, 0, 1384, 1382,
		1, 0, 0, 0, 1384, 1383, 1, 0, 0, 0, 1385, 261, 1, 0, 0, 0, 1386, 1389,
		3, 64, 32, 0, 1387, 1389, 3, 52, 26, 0, 1388, 1386, 1, 0, 0, 0, 1388, 1387,
		1, 0, 0, 0, 1389, 263, 1, 0, 0, 0, 1390, 1391, 3, 262, 131, 0, 1391, 1392,
		3, 604, 302, 0, 1392, 265, 1, 0, 0, 0, 1393, 1394, 3, 262, 131, 0, 1394,
		1395, 3, 604, 302, 0, 1395, 267, 1, 0, 0, 0, 1396, 1401, 3, 64, 32, 0,
		1397, 1401, 3, 52, 26, 0, 1398, 1401, 3, 264, 132, 0, 1399, 1401, 3, 266,
		133, 0, 1400, 1396, 1, 0, 0, 0, 1400, 1397, 1, 0, 0, 0, 1400, 1398, 1,
		0, 0, 0, 1400, 1399, 1, 0, 0, 0, 1401, 269, 1, 0, 0, 0, 1402, 1403, 7,
		3, 0, 0, 1403, 271, 1, 0, 0, 0, 1404, 1405, 3, 50, 25, 0, 1405, 1406, 5,
		112, 0, 0, 1406, 1407, 3, 288, 144, 0, 1407, 273, 1, 0, 0, 0, 1408, 1409,
		3, 424, 212, 0, 1409, 1410, 5, 120, 0, 0, 1410, 1411, 3, 426, 213, 0, 1411,
		275, 1, 0, 0, 0, 1412, 1413, 3, 424, 212, 0, 1413, 1414, 5, 120, 0, 0,
		1414, 1415, 3, 426, 213, 0, 1415, 277, 1, 0, 0, 0, 1416, 1422, 3, 268,
		134, 0, 1417, 1422, 3, 270, 135, 0, 1418, 1422, 3, 272, 136, 0, 1419, 1422,
		3, 274, 137, 0, 1420, 1422, 3, 276, 138, 0, 1421, 1416, 1, 0, 0, 0, 1421,
		1417, 1, 0, 0, 0, 1421, 1418, 1, 0, 0, 0, 1421, 1419, 1, 0, 0, 0, 1421,
		1420, 1, 0, 0, 0, 1422, 279, 1, 0, 0, 0, 1423, 1426, 3, 260, 130, 0, 1424,
		1426, 3, 278, 139, 0, 1425, 1423, 1, 0, 0, 0, 1425, 1424, 1, 0, 0, 0, 1426,
		281, 1, 0, 0, 0, 1427, 1428, 3, 50, 25, 0, 1428, 1429, 3, 288, 144, 0,
		1429, 283, 1, 0, 0, 0, 1430, 1431, 5, 71, 0, 0, 1431, 1432, 3, 544, 272,
		0, 1432, 1433, 5, 58, 0, 0, 1433, 1434, 3, 288, 144, 0, 1434, 1471, 1,
		0, 0, 0, 1435, 1436, 5, 71, 0, 0, 1436, 1437, 3, 574, 287, 0, 1437, 1438,
		5, 58, 0, 0, 1438, 1439, 3, 288, 144, 0, 1439, 1471, 1, 0, 0, 0, 1440,
		1441, 5, 70, 0, 0, 1441, 1442, 3, 544, 272, 0, 1442, 1443, 5, 58, 0, 0,
		1443, 1444, 3, 288, 144, 0, 1444, 1471, 1, 0, 0, 0, 1445, 1446, 5, 70,
		0, 0, 1446, 1447, 3, 574, 287, 0, 1447, 1448, 5, 58, 0, 0, 1448, 1449,
		3, 288, 144, 0, 1449, 1471, 1, 0, 0, 0, 1450, 1451, 5, 71, 0, 0, 1451,
		1452, 3, 544, 272, 0, 1452, 1453, 5, 58, 0, 0, 1453, 1454, 3, 282, 141,
		0, 1454, 1471, 1, 0, 0, 0, 1455, 1456, 5, 71, 0, 0, 1456, 1457, 3, 574,
		287, 0, 1457, 1458, 5, 58, 0, 0, 1458, 1459, 3, 282, 141, 0, 1459, 1471,
		1, 0, 0, 0, 1460, 1461, 5, 70, 0, 0, 1461, 1462, 3, 544, 272, 0, 1462,
		1463, 5, 58, 0, 0, 1463, 1464, 3, 282, 141, 0, 1464, 1471, 1, 0, 0, 0,
		1465, 1466, 5, 70, 0, 0, 1466, 1467, 3, 574, 287, 0, 1467, 1468, 5, 58,
		0, 0, 1468, 1469, 3, 282, 141, 0, 1469, 1471, 1, 0, 0, 0, 1470, 1430, 1,
		0, 0, 0, 1470, 1435, 1, 0, 0, 0, 1470, 1440, 1, 0, 0, 0, 1470, 1445, 1,
		0, 0, 0, 1470, 1450, 1, 0, 0, 0, 1470, 1455, 1, 0, 0, 0, 1470, 1460, 1,
		0, 0, 0, 1470, 1465, 1, 0, 0, 0, 1471, 285, 1, 0, 0, 0, 1472, 1473, 3,
		280, 140, 0, 1473, 1474, 3, 544, 272, 0, 1474, 1477, 1, 0, 0, 0, 1475,
		1477, 3, 284, 142, 0, 1476, 1472, 1, 0, 0, 0, 1476, 1475, 1, 0, 0, 0, 1477,
		287, 1, 0, 0, 0, 1478, 1482, 3, 260, 130, 0, 1479, 1482, 3, 278, 139, 0,
		1480, 1482, 3, 286, 143, 0, 1481, 1478, 1, 0, 0, 0, 1481, 1479, 1, 0, 0,
		0, 1481, 1480, 1, 0, 0, 0, 1482, 289, 1, 0, 0, 0, 1483, 1484, 6, 145, -1,
		0, 1484, 1485, 3, 50, 25, 0, 1485, 1491, 1, 0, 0, 0, 1486, 1487, 10, 2,
		0, 0, 1487, 1488, 5, 113, 0, 0, 1488, 1490, 3, 50, 25, 0, 1489, 1486, 1,
		0, 0, 0, 1490, 1493, 1, 0, 0, 0, 1491, 1489, 1, 0, 0, 0, 1491, 1492, 1,
		0, 0, 0, 1492, 291, 1, 0, 0, 0, 1493, 1491, 1, 0, 0, 0, 1494, 1499, 5,
		129, 0, 0, 1495, 1499, 3, 310, 155, 0, 1496, 1499, 3, 312, 156, 0, 1497,
		1499, 3, 128, 64, 0, 1498, 1494, 1, 0, 0, 0, 1498, 1495, 1, 0, 0, 0, 1498,
		1496, 1, 0, 0, 0, 1498, 1497, 1, 0, 0, 0, 1499, 293, 1, 0, 0, 0, 1500,
		1501, 6, 147, -1, 0, 1501, 1502, 3, 292, 146, 0, 1502, 1508, 1, 0, 0, 0,
		1503, 1504, 10, 2, 0, 0, 1504, 1505, 5, 113, 0, 0, 1505, 1507, 3, 292,
		146, 0, 1506, 1503, 1, 0, 0, 0, 1507, 1510, 1, 0, 0, 0, 1508, 1506, 1,
		0, 0, 0, 1508, 1509, 1, 0, 0, 0, 1509, 295, 1, 0, 0, 0, 1510, 1508, 1,
		0, 0, 0, 1511, 1512, 5, 126, 0, 0, 1512, 297, 1, 0, 0, 0, 1513, 1514, 5,
		126, 0, 0, 1514, 299, 1, 0, 0, 0, 1515, 1516, 5, 126, 0, 0, 1516, 301,
		1, 0, 0, 0, 1517, 1518, 5, 126, 0, 0, 1518, 303, 1, 0, 0, 0, 1519, 1520,
		5, 126, 0, 0, 1520, 305, 1, 0, 0, 0, 1521, 1522, 5, 126, 0, 0, 1522, 307,
		1, 0, 0, 0, 1523, 1524, 5, 104, 0, 0, 1524, 1525, 3, 294, 147, 0, 1525,
		1526, 5, 105, 0, 0, 1526, 309, 1, 0, 0, 0, 1527, 1528, 5, 104, 0, 0, 1528,
		1529, 3, 296, 148, 0, 1529, 1530, 5, 113, 0, 0, 1530, 1531, 3, 298, 149,
		0, 1531, 1532, 5, 113, 0, 0, 1532, 1533, 3, 300, 150, 0, 1533, 1534, 5,
		113, 0, 0, 1534, 1535, 3, 302, 151, 0, 1535, 1536, 5, 105, 0, 0, 1536,
		311, 1, 0, 0, 0, 1537, 1538, 5, 104, 0, 0, 1538, 1539, 3, 304, 152, 0,
		1539, 1540, 5, 113, 0, 0, 1540, 1541, 3, 306, 153, 0, 1541, 1542, 5, 105,
		0, 0, 1542, 313, 1, 0, 0, 0, 1543, 1548, 5, 129, 0, 0, 1544, 1548, 3, 308,
		154, 0, 1545, 1548, 3, 310, 155, 0, 1546, 1548, 3, 312, 156, 0, 1547, 1543,
		1, 0, 0, 0, 1547, 1544, 1, 0, 0, 0, 1547, 1545, 1, 0, 0, 0, 1547, 1546,
		1, 0, 0, 0, 1548, 315, 1, 0, 0, 0, 1549, 1550, 3, 362, 181, 0, 1550, 317,
		1, 0, 0, 0, 1551, 1556, 5, 125, 0, 0, 1552, 1553, 5, 122, 0, 0, 1553, 1556,
		5, 125, 0, 0, 1554, 1556, 3, 362, 181, 0, 1555, 1551, 1, 0, 0, 0, 1555,
		1552, 1, 0, 0, 0, 1555, 1554, 1, 0, 0, 0, 1556, 319, 1, 0, 0, 0, 1557,
		1558, 7, 4, 0, 0, 1558, 321, 1, 0, 0, 0, 1559, 1563, 3, 124, 62, 0, 1560,
		1563, 3, 126, 63, 0, 1561, 1563, 3, 128, 64, 0, 1562, 1559, 1, 0, 0, 0,
		1562, 1560, 1, 0, 0, 0, 1562, 1561, 1, 0, 0, 0, 1563, 323, 1, 0, 0, 0,
		1564, 1565, 6, 162, -1, 0, 1565, 1566, 3, 322, 161, 0, 1566, 1571, 1, 0,
		0, 0, 1567, 1568, 10, 2, 0, 0, 1568, 1570, 3, 322, 161, 0, 1569, 1567,
		1, 0, 0, 0, 1570, 1573, 1, 0, 0, 0, 1571, 1569, 1, 0, 0, 0, 1571, 1572,
		1, 0, 0, 0, 1572, 325, 1, 0, 0, 0, 1573, 1571, 1, 0, 0, 0, 1574, 1575,
		6, 163, -1, 0, 1575, 1576, 3, 330, 165, 0, 1576, 1582, 1, 0, 0, 0, 1577,
		1578, 10, 2, 0, 0, 1578, 1579, 5, 113, 0, 0, 1579, 1581, 3, 330, 165, 0,
		1580, 1577, 1, 0, 0, 0, 1581, 1584, 1, 0, 0, 0, 1582, 1580, 1, 0, 0, 0,
		1582, 1583, 1, 0, 0, 0, 1583, 327, 1, 0, 0, 0, 1584, 1582, 1, 0, 0, 0,
		1585, 1586, 6, 164, -1, 0, 1586, 1587, 3, 386, 193, 0, 1587, 1593, 1, 0,
		0, 0, 1588, 1589, 10, 2, 0, 0, 1589, 1590, 5, 113, 0, 0, 1590, 1592, 3,
		386, 193, 0, 1591, 1588, 1, 0, 0, 0, 1592, 1595, 1, 0, 0, 0, 1593, 1591,
		1, 0, 0, 0, 1593, 1594, 1, 0, 0, 0, 1594, 329, 1, 0, 0, 0, 1595, 1593,
		1, 0, 0, 0, 1596, 1597, 3, 50, 25, 0, 1597, 1598, 3, 386, 193, 0, 1598,
		331, 1, 0, 0, 0, 1599, 1600, 6, 166, -1, 0, 1600, 1601, 3, 330, 165, 0,
		1601, 1607, 1, 0, 0, 0, 1602, 1603, 10, 2, 0, 0, 1603, 1604, 5, 113, 0,
		0, 1604, 1606, 3, 330, 165, 0, 1605, 1602, 1, 0, 0, 0, 1606, 1609, 1, 0,
		0, 0, 1607, 1605, 1, 0, 0, 0, 1607, 1608, 1, 0, 0, 0, 1608, 333, 1, 0,
		0, 0, 1609, 1607, 1, 0, 0, 0, 1610, 1621, 5, 128, 0, 0, 1611, 1621, 5,
		127, 0, 0, 1612, 1613, 5, 104, 0, 0, 1613, 1614, 3, 290, 145, 0, 1614,
		1615, 5, 105, 0, 0, 1615, 1621, 1, 0, 0, 0, 1616, 1617, 5, 104, 0, 0, 1617,
		1621, 5, 105, 0, 0, 1618, 1619, 5, 17, 0, 0, 1619, 1621, 3, 386, 193, 0,
		1620, 1610, 1, 0, 0, 0, 1620, 1611, 1, 0, 0, 0, 1620, 1612, 1, 0, 0, 0,
		1620, 1616, 1, 0, 0, 0, 1620, 1618, 1, 0, 0, 0, 1621, 335, 1, 0, 0, 0,
		1622, 1623, 7, 5, 0, 0, 1623, 337, 1, 0, 0, 0, 1624, 1627, 3, 314, 157,
		0, 1625, 1627, 3, 316, 158, 0, 1626, 1624, 1, 0, 0, 0, 1626, 1625, 1, 0,
		0, 0, 1627, 339, 1, 0, 0, 0, 1628, 1629, 3, 50, 25, 0, 1629, 1630, 5, 110,
		0, 0, 1630, 1631, 3, 386, 193, 0, 1631, 341, 1, 0, 0, 0, 1632, 1633, 3,
		362, 181, 0, 1633, 343, 1, 0, 0, 0, 1634, 1635, 3, 50, 25, 0, 1635, 345,
		1, 0, 0, 0, 1636, 1637, 3, 362, 181, 0, 1637, 347, 1, 0, 0, 0, 1638, 1639,
		3, 386, 193, 0, 1639, 349, 1, 0, 0, 0, 1640, 1643, 3, 538, 269, 0, 1641,
		1643, 3, 50, 25, 0, 1642, 1640, 1, 0, 0, 0, 1642, 1641, 1, 0, 0, 0, 1643,
		351, 1, 0, 0, 0, 1644, 1645, 5, 53, 0, 0, 1645, 353, 1, 0, 0, 0, 1646,
		1651, 5, 128, 0, 0, 1647, 1651, 5, 127, 0, 0, 1648, 1649, 5, 17, 0, 0,
		1649, 1651, 3, 386, 193, 0, 1650, 1646, 1, 0, 0, 0, 1650, 1647, 1, 0, 0,
		0, 1650, 1648, 1, 0, 0, 0, 1651, 355, 1, 0, 0, 0, 1652, 1655, 3, 318, 159,
		0, 1653, 1655, 3, 320, 160, 0, 1654, 1652, 1, 0, 0, 0, 1654, 1653, 1, 0,
		0, 0, 1655, 357, 1, 0, 0, 0, 1656, 1657, 1, 0, 0, 0, 1657, 359, 1, 0, 0,
		0, 1658, 1659, 5, 104, 0, 0, 1659, 1660, 3, 324, 162, 0, 1660, 1661, 5,
		105, 0, 0, 1661, 361, 1, 0, 0, 0, 1662, 1663, 5, 104, 0, 0, 1663, 1664,
		3, 326, 163, 0, 1664, 1665, 5, 105, 0, 0, 1665, 363, 1, 0, 0, 0, 1666,
		1667, 5, 104, 0, 0, 1667, 1668, 3, 328, 164, 0, 1668, 1669, 5, 105, 0,
		0, 1669, 1677, 1, 0, 0, 0, 1670, 1671, 5, 104, 0, 0, 1671, 1672, 3, 332,
		166, 0, 1672, 1673, 5, 105, 0, 0, 1673, 1677, 1, 0, 0, 0, 1674, 1675, 5,
		104, 0, 0, 1675, 1677, 5, 105, 0, 0, 1676, 1666, 1, 0, 0, 0, 1676, 1670,
		1, 0, 0, 0, 1676, 1674, 1, 0, 0, 0, 1677, 365, 1, 0, 0, 0, 1678, 1679,
		5, 104, 0, 0, 1679, 1680, 3, 326, 163, 0, 1680, 1681, 5, 105, 0, 0, 1681,
		1685, 1, 0, 0, 0, 1682, 1683, 5, 104, 0, 0, 1683, 1685, 5, 105, 0, 0, 1684,
		1678, 1, 0, 0, 0, 1684, 1682, 1, 0, 0, 0, 1685, 367, 1, 0, 0, 0, 1686,
		1687, 5, 104, 0, 0, 1687, 1688, 3, 328, 164, 0, 1688, 1689, 5, 105, 0,
		0, 1689, 1697, 1, 0, 0, 0, 1690, 1691, 5, 104, 0, 0, 1691, 1692, 3, 332,
		166, 0, 1692, 1693, 5, 105, 0, 0, 1693, 1697, 1, 0, 0, 0, 1694, 1695, 5,
		104, 0, 0, 1695, 1697, 5, 105, 0, 0, 1696, 1686, 1, 0, 0, 0, 1696, 1690,
		1, 0, 0, 0, 1696, 1694, 1, 0, 0, 0, 1697, 369, 1, 0, 0, 0, 1698, 1699,
		3, 386, 193, 0, 1699, 371, 1, 0, 0, 0, 1700, 1701, 5, 129, 0, 0, 1701,
		373, 1, 0, 0, 0, 1702, 1720, 3, 334, 167, 0, 1703, 1720, 3, 336, 168, 0,
		1704, 1720, 3, 338, 169, 0, 1705, 1720, 3, 340, 170, 0, 1706, 1720, 3,
		344, 172, 0, 1707, 1720, 3, 350, 175, 0, 1708, 1720, 3, 30, 15, 0, 1709,
		1720, 3, 352, 176, 0, 1710, 1720, 3, 118, 59, 0, 1711, 1720, 3, 354, 177,
		0, 1712, 1720, 3, 356, 178, 0, 1713, 1720, 3, 360, 180, 0, 1714, 1720,
		3, 362, 181, 0, 1715, 1720, 3, 364, 182, 0, 1716, 1720, 3, 366, 183, 0,
		1717, 1720, 3, 368, 184, 0, 1718, 1720, 3, 372, 186, 0, 1719, 1702, 1,
		0, 0, 0, 1719, 1703, 1, 0, 0, 0, 1719, 1704, 1, 0, 0, 0, 1719, 1705, 1,
		0, 0, 0, 1719, 1706, 1, 0, 0, 0, 1719, 1707, 1, 0, 0, 0, 1719, 1708, 1,
		0, 0, 0, 1719, 1709, 1, 0, 0, 0, 1719, 1710, 1, 0, 0, 0, 1719, 1711, 1,
		0, 0, 0, 1719, 1712, 1, 0, 0, 0, 1719, 1713, 1, 0, 0, 0, 1719, 1714, 1,
		0, 0, 0, 1719, 1715, 1, 0, 0, 0, 1719, 1716, 1, 0, 0, 0, 1719, 1717, 1,
		0, 0, 0, 1719, 1718, 1, 0, 0, 0, 1720, 375, 1, 0, 0, 0, 1721, 1722, 3,
		424, 212, 0, 1722, 1723, 5, 120, 0, 0, 1723, 1724, 3, 426, 213, 0, 1724,
		377, 1, 0, 0, 0, 1725, 1728, 3, 128, 64, 0, 1726, 1728, 3, 376, 188, 0,
		1727, 1725, 1, 0, 0, 0, 1727, 1726, 1, 0, 0, 0, 1728, 379, 1, 0, 0, 0,
		1729, 1730, 3, 288, 144, 0, 1730, 1731, 5, 110, 0, 0, 1731, 1732, 3, 386,
		193, 0, 1732, 381, 1, 0, 0, 0, 1733, 1736, 3, 374, 187, 0, 1734, 1736,
		3, 378, 189, 0, 1735, 1733, 1, 0, 0, 0, 1735, 1734, 1, 0, 0, 0, 1736, 383,
		1, 0, 0, 0, 1737, 1740, 3, 380, 190, 0, 1738, 1740, 3, 382, 191, 0, 1739,
		1737, 1, 0, 0, 0, 1739, 1738, 1, 0, 0, 0, 1740, 385, 1, 0, 0, 0, 1741,
		1745, 3, 374, 187, 0, 1742, 1745, 3, 378, 189, 0, 1743, 1745, 3, 384, 192,
		0, 1744, 1741, 1, 0, 0, 0, 1744, 1742, 1, 0, 0, 0, 1744, 1743, 1, 0, 0,
		0, 1745, 387, 1, 0, 0, 0, 1746, 1747, 5, 104, 0, 0, 1747, 1748, 3, 486,
		243, 0, 1748, 1749, 5, 105, 0, 0, 1749, 389, 1, 0, 0, 0, 1750, 1754, 3,
		68, 34, 0, 1751, 1754, 3, 58, 29, 0, 1752, 1754, 3, 84, 42, 0, 1753, 1750,
		1, 0, 0, 0, 1753, 1751, 1, 0, 0, 0, 1753, 1752, 1, 0, 0, 0, 1754, 391,
		1, 0, 0, 0, 1755, 1760, 3, 394, 197, 0, 1756, 1760, 3, 398, 199, 0, 1757,
		1760, 3, 420, 210, 0, 1758, 1760, 3, 428, 214, 0, 1759, 1755, 1, 0, 0,
		0, 1759, 1756, 1, 0, 0, 0, 1759, 1757, 1, 0, 0, 0, 1759, 1758, 1, 0, 0,
		0, 1760, 393, 1, 0, 0, 0, 1761, 1764, 3, 70, 35, 0, 1762, 1764, 3, 56,
		28, 0, 1763, 1761, 1, 0, 0, 0, 1763, 1762, 1, 0, 0, 0, 1764, 395, 1, 0,
		0, 0, 1765, 1768, 3, 72, 36, 0, 1766, 1768, 3, 60, 30, 0, 1767, 1765, 1,
		0, 0, 0, 1767, 1766, 1, 0, 0, 0, 1768, 397, 1, 0, 0, 0, 1769, 1772, 3,
		400, 200, 0, 1770, 1772, 3, 402, 201, 0, 1771, 1769, 1, 0, 0, 0, 1771,
		1770, 1, 0, 0, 0, 1772, 399, 1, 0, 0, 0, 1773, 1774, 5, 104, 0, 0, 1774,
		1775, 3, 412, 206, 0, 1775, 1776, 5, 105, 0, 0, 1776, 401, 1, 0, 0, 0,
		1777, 1778, 5, 104, 0, 0, 1778, 1779, 3, 404, 202, 0, 1779, 1780, 5, 105,
		0, 0, 1780, 403, 1, 0, 0, 0, 1781, 1782, 6, 202, -1, 0, 1782, 1785, 3,
		406, 203, 0, 1783, 1785, 1, 0, 0, 0, 1784, 1781, 1, 0, 0, 0, 1784, 1783,
		1, 0, 0, 0, 1785, 1790, 1, 0, 0, 0, 1786, 1787, 10, 3, 0, 0, 1787, 1789,
		3, 406, 203, 0, 1788, 1786, 1, 0, 0, 0, 1789, 1792, 1, 0, 0, 0, 1790, 1788,
		1, 0, 0, 0, 1790, 1791, 1, 0, 0, 0, 1791, 405, 1, 0, 0, 0, 1792, 1790,
		1, 0, 0, 0, 1793, 1796, 3, 408, 204, 0, 1794, 1796, 3, 418, 209, 0, 1795,
		1793, 1, 0, 0, 0, 1795, 1794, 1, 0, 0, 0, 1796, 407, 1, 0, 0, 0, 1797,
		1800, 3, 410, 205, 0, 1798, 1800, 5, 113, 0, 0, 1799, 1797, 1, 0, 0, 0,
		1799, 1798, 1, 0, 0, 0, 1800, 409, 1, 0, 0, 0, 1801, 1802, 7, 0, 0, 0,
		1802, 411, 1, 0, 0, 0, 1803, 1804, 6, 206, -1, 0, 1804, 1807, 3, 414, 207,
		0, 1805, 1807, 1, 0, 0, 0, 1806, 1803, 1, 0, 0, 0, 1806, 1805, 1, 0, 0,
		0, 1807, 1813, 1, 0, 0, 0, 1808, 1809, 10, 3, 0, 0, 1809, 1810, 5, 113,
		0, 0, 1810, 1812, 3, 414, 207, 0, 1811, 1808, 1, 0, 0, 0, 1812, 1815, 1,
		0, 0, 0, 1813, 1811, 1, 0, 0, 0, 1813, 1814, 1, 0, 0, 0, 1814, 413, 1,
		0, 0, 0, 1815, 1813, 1, 0, 0, 0, 1816, 1817, 3, 416, 208, 0, 1817, 1818,
		3, 418, 209, 0, 1818, 415, 1, 0, 0, 0, 1819, 1825, 3, 74, 37, 0, 1820,
		1825, 3, 76, 38, 0, 1821, 1825, 3, 78, 39, 0, 1822, 1825, 3, 80, 40, 0,
		1823, 1825, 3, 82, 41, 0, 1824, 1819, 1, 0, 0, 0, 1824, 1820, 1, 0, 0,
		0, 1824, 1821, 1, 0, 0, 0, 1824, 1822, 1, 0, 0, 0, 1824, 1823, 1, 0, 0,
		0, 1825, 417, 1, 0, 0, 0, 1826, 1832, 3, 288, 144, 0, 1827, 1832, 3, 386,
		193, 0, 1828, 1832, 3, 388, 194, 0, 1829, 1832, 3, 392, 196, 0, 1830, 1832,
		3, 478, 239, 0, 1831, 1826, 1, 0, 0, 0, 1831, 1827, 1, 0, 0, 0, 1831, 1828,
		1, 0, 0, 0, 1831, 1829, 1, 0, 0, 0, 1831, 1830, 1, 0, 0, 0, 1832, 419,
		1, 0, 0, 0, 1833, 1834, 3, 424, 212, 0, 1834, 1835, 5, 120, 0, 0, 1835,
		1836, 3, 426, 213, 0, 1836, 421, 1, 0, 0, 0, 1837, 1838, 3, 424, 212, 0,
		1838, 1839, 5, 120, 0, 0, 1839, 1840, 3, 426, 213, 0, 1840, 423, 1, 0,
		0, 0, 1841, 1846, 3, 394, 197, 0, 1842, 1846, 3, 428, 214, 0, 1843, 1846,
		3, 396, 198, 0, 1844, 1846, 3, 610, 305, 0, 1845, 1841, 1, 0, 0, 0, 1845,
		1842, 1, 0, 0, 0, 1845, 1843, 1, 0, 0, 0, 1845, 1844, 1, 0, 0, 0, 1846,
		425, 1, 0, 0, 0, 1847, 1848, 6, 213, -1, 0, 1848, 1849, 3, 416, 208, 0,
		1849, 1855, 1, 0, 0, 0, 1850, 1851, 10, 2, 0, 0, 1851, 1852, 5, 120, 0,
		0, 1852, 1854, 3, 416, 208, 0, 1853, 1850, 1, 0, 0, 0, 1854, 1857, 1, 0,
		0, 0, 1855, 1853, 1, 0, 0, 0, 1855, 1856, 1, 0, 0, 0, 1856, 427, 1, 0,
		0, 0, 1857, 1855, 1, 0, 0, 0, 1858, 1859, 3, 394, 197, 0, 1859, 1860, 3,
		604, 302, 0, 1860, 429, 1, 0, 0, 0, 1861, 1865, 3, 390, 195, 0, 1862, 1865,
		3, 432, 216, 0, 1863, 1865, 3, 476, 238, 0, 1864, 1861, 1, 0, 0, 0, 1864,
		1862, 1, 0, 0, 0, 1864, 1863, 1, 0, 0, 0, 1865, 431, 1, 0, 0, 0, 1866,
		1867, 5, 13, 0, 0, 1867, 1868, 5, 104, 0, 0, 1868, 1869, 3, 434, 217, 0,
		1869, 1870, 5, 105, 0, 0, 1870, 1871, 3, 464, 232, 0, 1871, 433, 1, 0,
		0, 0, 1872, 1873, 6, 217, -1, 0, 1873, 1874, 3, 436, 218, 0, 1874, 1880,
		1, 0, 0, 0, 1875, 1876, 10, 2, 0, 0, 1876, 1877, 5, 113, 0, 0, 1877, 1879,
		3, 436, 218, 0, 1878, 1875, 1, 0, 0, 0, 1879, 1882, 1, 0, 0, 0, 1880, 1878,
		1, 0, 0, 0, 1880, 1881, 1, 0, 0, 0, 1881, 435, 1, 0, 0, 0, 1882, 1880,
		1, 0, 0, 0, 1883, 1891, 3, 438, 219, 0, 1884, 1891, 3, 440, 220, 0, 1885,
		1891, 3, 444, 222, 0, 1886, 1891, 3, 446, 223, 0, 1887, 1891, 3, 448, 224,
		0, 1888, 1891, 3, 450, 225, 0, 1889, 1891, 3, 452, 226, 0, 1890, 1883,
		1, 0, 0, 0, 1890, 1884, 1, 0, 0, 0, 1890, 1885, 1, 0, 0, 0, 1890, 1886,
		1, 0, 0, 0, 1890, 1887, 1, 0, 0, 0, 1890, 1888, 1, 0, 0, 0, 1890, 1889,
		1, 0, 0, 0, 1891, 437, 1, 0, 0, 0, 1892, 1893, 3, 74, 37, 0, 1893, 1894,
		3, 454, 227, 0, 1894, 439, 1, 0, 0, 0, 1895, 1896, 3, 76, 38, 0, 1896,
		1897, 3, 288, 144, 0, 1897, 1898, 3, 442, 221, 0, 1898, 1899, 3, 456, 228,
		0, 1899, 441, 1, 0, 0, 0, 1900, 1903, 5, 84, 0, 0, 1901, 1903, 1, 0, 0,
		0, 1902, 1900, 1, 0, 0, 0, 1902, 1901, 1, 0, 0, 0, 1903, 443, 1, 0, 0,
		0, 1904, 1905, 3, 76, 38, 0, 1905, 1906, 3, 426, 213, 0, 1906, 1907, 3,
		456, 228, 0, 1907, 445, 1, 0, 0, 0, 1908, 1909, 3, 78, 39, 0, 1909, 1910,
		3, 288, 144, 0, 1910, 1911, 3, 458, 229, 0, 1911, 447, 1, 0, 0, 0, 1912,
		1913, 3, 78, 39, 0, 1913, 1914, 3, 426, 213, 0, 1914, 1915, 3, 458, 229,
		0, 1915, 449, 1, 0, 0, 0, 1916, 1917, 3, 80, 40, 0, 1917, 1918, 3, 390,
		195, 0, 1918, 1919, 3, 460, 230, 0, 1919, 451, 1, 0, 0, 0, 1920, 1921,
		3, 82, 41, 0, 1921, 1922, 3, 390, 195, 0, 1922, 1923, 3, 462, 231, 0, 1923,
		453, 1, 0, 0, 0, 1924, 1928, 5, 60, 0, 0, 1925, 1928, 5, 20, 0, 0, 1926,
		1928, 1, 0, 0, 0, 1927, 1924, 1, 0, 0, 0, 1927, 1925, 1, 0, 0, 0, 1927,
		1926, 1, 0, 0, 0, 1928, 455, 1, 0, 0, 0, 1929, 1934, 5, 60, 0, 0, 1930,
		1931, 5, 20, 0, 0, 1931, 1934, 3, 386, 193, 0, 1932, 1934, 1, 0, 0, 0,
		1933, 1929, 1, 0, 0, 0, 1933, 1930, 1, 0, 0, 0, 1933, 1932, 1, 0, 0, 0,
		1934, 457, 1, 0, 0, 0, 1935, 1940, 5, 60, 0, 0, 1936, 1937, 5, 20, 0, 0,
		1937, 1940, 3, 388, 194, 0, 1938, 1940, 1, 0, 0, 0, 1939, 1935, 1, 0, 0,
		0, 1939, 1936, 1, 0, 0, 0, 1939, 1938, 1, 0, 0, 0, 1940, 459, 1, 0, 0,
		0, 1941, 1946, 5, 60, 0, 0, 1942, 1943, 5, 20, 0, 0, 1943, 1946, 3, 392,
		196, 0, 1944, 1946, 1, 0, 0, 0, 1945, 1941, 1, 0, 0, 0, 1945, 1942, 1,
		0, 0, 0, 1945, 1944, 1, 0, 0, 0, 1946, 461, 1, 0, 0, 0, 1947, 1952, 5,
		60, 0, 0, 1948, 1949, 5, 20, 0, 0, 1949, 1952, 3, 478, 239, 0, 1950, 1952,
		1, 0, 0, 0, 1951, 1947, 1, 0, 0, 0, 1951, 1948, 1, 0, 0, 0, 1951, 1950,
		1, 0, 0, 0, 1952, 463, 1, 0, 0, 0, 1953, 1954, 5, 91, 0, 0, 1954, 1955,
		5, 75, 0, 0, 1955, 1956, 3, 466, 233, 0, 1956, 465, 1, 0, 0, 0, 1957, 1958,
		5, 104, 0, 0, 1958, 1959, 3, 468, 234, 0, 1959, 1960, 5, 105, 0, 0, 1960,
		467, 1, 0, 0, 0, 1961, 1962, 6, 234, -1, 0, 1962, 1965, 3, 470, 235, 0,
		1963, 1965, 1, 0, 0, 0, 1964, 1961, 1, 0, 0, 0, 1964, 1963, 1, 0, 0, 0,
		1965, 1970, 1, 0, 0, 0, 1966, 1967, 10, 3, 0, 0, 1967, 1969, 3, 470, 235,
		0, 1968, 1966, 1, 0, 0, 0, 1969, 1972, 1, 0, 0, 0, 1970, 1968, 1, 0, 0,
		0, 1970, 1971, 1, 0, 0, 0, 1971, 469, 1, 0, 0, 0, 1972, 1970, 1, 0, 0,
		0, 1973, 1976, 3, 472, 236, 0, 1974, 1976, 3, 474, 237, 0, 1975, 1973,
		1, 0, 0, 0, 1975, 1974, 1, 0, 0, 0, 1976, 471, 1, 0, 0, 0, 1977, 1980,
		3, 408, 204, 0, 1978, 1980, 3, 416, 208, 0, 1979, 1977, 1, 0, 0, 0, 1979,
		1978, 1, 0, 0, 0, 1980, 473, 1, 0, 0, 0, 1981, 1982, 5, 106, 0, 0, 1982,
		1983, 3, 468, 234, 0, 1983, 1984, 5, 107, 0, 0, 1984, 475, 1, 0, 0, 0,
		1985, 1986, 3, 390, 195, 0, 1986, 1987, 3, 604, 302, 0, 1987, 477, 1, 0,
		0, 0, 1988, 1989, 5, 104, 0, 0, 1989, 1990, 3, 480, 240, 0, 1990, 1991,
		5, 105, 0, 0, 1991, 479, 1, 0, 0, 0, 1992, 2008, 3, 482, 241, 0, 1993,
		1994, 3, 482, 241, 0, 1994, 1995, 5, 113, 0, 0, 1995, 1996, 5, 96, 0, 0,
		1996, 2008, 1, 0, 0, 0, 1997, 2008, 5, 96, 0, 0, 1998, 1999, 5, 96, 0,
		0, 1999, 2000, 5, 113, 0, 0, 2000, 2008, 3, 484, 242, 0, 2001, 2002, 3,
		482, 241, 0, 2002, 2003, 5, 113, 0, 0, 2003, 2004, 5, 96, 0, 0, 2004, 2005,
		5, 113, 0, 0, 2005, 2006, 3, 484, 242, 0, 2006, 2008, 1, 0, 0, 0, 2007,
		1992, 1, 0, 0, 0, 2007, 1993, 1, 0, 0, 0, 2007, 1997, 1, 0, 0, 0, 2007,
		1998, 1, 0, 0, 0, 2007, 2001, 1, 0, 0, 0, 2008, 481, 1, 0, 0, 0, 2009,
		2010, 3, 488, 244, 0, 2010, 483, 1, 0, 0, 0, 2011, 2012, 3, 488, 244, 0,
		2012, 485, 1, 0, 0, 0, 2013, 2025, 3, 482, 241, 0, 2014, 2015, 3, 482,
		241, 0, 2015, 2016, 5, 113, 0, 0, 2016, 2017, 5, 96, 0, 0, 2017, 2025,
		1, 0, 0, 0, 2018, 2019, 3, 482, 241, 0, 2019, 2020, 5, 113, 0, 0, 2020,
		2021, 5, 96, 0, 0, 2021, 2022, 5, 113, 0, 0, 2022, 2023, 3, 484, 242, 0,
		2023, 2025, 1, 0, 0, 0, 2024, 2013, 1, 0, 0, 0, 2024, 2014, 1, 0, 0, 0,
		2024, 2018, 1, 0, 0, 0, 2025, 487, 1, 0, 0, 0, 2026, 2030, 3, 490, 245,
		0, 2027, 2028, 5, 3, 0, 0, 2028, 2030, 3, 492, 246, 0, 2029, 2026, 1, 0,
		0, 0, 2029, 2027, 1, 0, 0, 0, 2030, 489, 1, 0, 0, 0, 2031, 2032, 6, 245,
		-1, 0, 2032, 2033, 3, 494, 247, 0, 2033, 2040, 1, 0, 0, 0, 2034, 2035,
		10, 1, 0, 0, 2035, 2036, 3, 498, 249, 0, 2036, 2037, 3, 494, 247, 0, 2037,
		2039, 1, 0, 0, 0, 2038, 2034, 1, 0, 0, 0, 2039, 2042, 1, 0, 0, 0, 2040,
		2038, 1, 0, 0, 0, 2040, 2041, 1, 0, 0, 0, 2041, 491, 1, 0, 0, 0, 2042,
		2040, 1, 0, 0, 0, 2043, 2044, 5, 28, 0, 0, 2044, 2045, 3, 592, 296, 0,
		2045, 493, 1, 0, 0, 0, 2046, 2047, 6, 247, -1, 0, 2047, 2048, 3, 596, 298,
		0, 2048, 2055, 1, 0, 0, 0, 2049, 2050, 10, 1, 0, 0, 2050, 2051, 3, 600,
		300, 0, 2051, 2052, 3, 596, 298, 0, 2052, 2054, 1, 0, 0, 0, 2053, 2049,
		1, 0, 0, 0, 2054, 2057, 1, 0, 0, 0, 2055, 2053, 1, 0, 0, 0, 2055, 2056,
		1, 0, 0, 0, 2056, 495, 1, 0, 0, 0, 2057, 2055, 1, 0, 0, 0, 2058, 2059,
		3, 490, 245, 0, 2059, 497, 1, 0, 0, 0, 2060, 2061, 7, 6, 0, 0, 2061, 499,
		1, 0, 0, 0, 2062, 2065, 3, 386, 193, 0, 2063, 2065, 5, 50, 0, 0, 2064,
		2062, 1, 0, 0, 0, 2064, 2063, 1, 0, 0, 0, 2065, 501, 1, 0, 0, 0, 2066,
		2069, 3, 386, 193, 0, 2067, 2069, 5, 49, 0, 0, 2068, 2066, 1, 0, 0, 0,
		2068, 2067, 1, 0, 0, 0, 2069, 503, 1, 0, 0, 0, 2070, 2073, 5, 43, 0, 0,
		2071, 2073, 1, 0, 0, 0, 2072, 2070, 1, 0, 0, 0, 2072, 2071, 1, 0, 0, 0,
		2073, 505, 1, 0, 0, 0, 2074, 2079, 3, 500, 250, 0, 2075, 2076, 3, 500,
		250, 0, 2076, 2077, 5, 112, 0, 0, 2077, 2079, 1, 0, 0, 0, 2078, 2074, 1,
		0, 0, 0, 2078, 2075, 1, 0, 0, 0, 2079, 507, 1, 0, 0, 0, 2080, 2084, 3,
		502, 251, 0, 2081, 2082, 5, 112, 0, 0, 2082, 2084, 3, 502, 251, 0, 2083,
		2080, 1, 0, 0, 0, 2083, 2081, 1, 0, 0, 0, 2084, 509, 1, 0, 0, 0, 2085,
		2086, 5, 120, 0, 0, 2086, 2089, 3, 510, 255, 0, 2087, 2089, 1, 0, 0, 0,
		2088, 2085, 1, 0, 0, 0, 2088, 2087, 1, 0, 0, 0, 2089, 511, 1, 0, 0, 0,
		2090, 2091, 6, 256, -1, 0, 2091, 2092, 3, 50, 25, 0, 2092, 2098, 1, 0,
		0, 0, 2093, 2094, 10, 2, 0, 0, 2094, 2095, 5, 120, 0, 0, 2095, 2097, 3,
		50, 25, 0, 2096, 2093, 1, 0, 0, 0, 2097, 2100, 1, 0, 0, 0, 2098, 2096,
		1, 0, 0, 0, 2098, 2099, 1, 0, 0, 0, 2099, 513, 1, 0, 0, 0, 2100, 2098,
		1, 0, 0, 0, 2101, 2102, 5, 117, 0, 0, 2102, 2109, 3, 512, 256, 0, 2103,
		2104, 5, 117, 0, 0, 2104, 2105, 5, 120, 0, 0, 2105, 2106, 3, 510, 255,
		0, 2106, 2107, 3, 512, 256, 0, 2107, 2109, 1, 0, 0, 0, 2108, 2101, 1, 0,
		0, 0, 2108, 2103, 1, 0, 0, 0, 2109, 515, 1, 0, 0, 0, 2110, 2111, 6, 258,
		-1, 0, 2111, 2112, 3, 514, 257, 0, 2112, 2118, 1, 0, 0, 0, 2113, 2114,
		10, 2, 0, 0, 2114, 2115, 5, 113, 0, 0, 2115, 2117, 3, 514, 257, 0, 2116,
		2113, 1, 0, 0, 0, 2117, 2120, 1, 0, 0, 0, 2118, 2116, 1, 0, 0, 0, 2118,
		2119, 1, 0, 0, 0, 2119, 517, 1, 0, 0, 0, 2120, 2118, 1, 0, 0, 0, 2121,
		2122, 3, 636, 318, 0, 2122, 2123, 5, 110, 0, 0, 2123, 2124, 3, 386, 193,
		0, 2124, 2133, 1, 0, 0, 0, 2125, 2126, 3, 636, 318, 0, 2126, 2127, 5, 110,
		0, 0, 2127, 2128, 3, 392, 196, 0, 2128, 2133, 1, 0, 0, 0, 2129, 2133, 3,
		396, 198, 0, 2130, 2133, 3, 288, 144, 0, 2131, 2133, 3, 390, 195, 0, 2132,
		2121, 1, 0, 0, 0, 2132, 2125, 1, 0, 0, 0, 2132, 2129, 1, 0, 0, 0, 2132,
		2130, 1, 0, 0, 0, 2132, 2131, 1, 0, 0, 0, 2133, 519, 1, 0, 0, 0, 2134,
		2135, 6, 260, -1, 0, 2135, 2138, 3, 518, 259, 0, 2136, 2138, 1, 0, 0, 0,
		2137, 2134, 1, 0, 0, 0, 2137, 2136, 1, 0, 0, 0, 2138, 2144, 1, 0, 0, 0,
		2139, 2140, 10, 3, 0, 0, 2140, 2141, 5, 113, 0, 0, 2141, 2143, 3, 518,
		259, 0, 2142, 2139, 1, 0, 0, 0, 2143, 2146, 1, 0, 0, 0, 2144, 2142, 1,
		0, 0, 0, 2144, 2145, 1, 0, 0, 0, 2145, 521, 1, 0, 0, 0, 2146, 2144, 1,
		0, 0, 0, 2147, 2148, 5, 16, 0, 0, 2148, 2149, 5, 10, 0, 0, 2149, 2150,
		5, 104, 0, 0, 2150, 2151, 3, 520, 260, 0, 2151, 2152, 5, 105, 0, 0, 2152,
		523, 1, 0, 0, 0, 2153, 2154, 3, 478, 239, 0, 2154, 525, 1, 0, 0, 0, 2155,
		2156, 5, 104, 0, 0, 2156, 2157, 3, 396, 198, 0, 2157, 2158, 5, 105, 0,
		0, 2158, 2159, 5, 104, 0, 0, 2159, 2160, 3, 516, 258, 0, 2160, 2161, 5,
		105, 0, 0, 2161, 527, 1, 0, 0, 0, 2162, 2165, 3, 524, 262, 0, 2163, 2165,
		3, 526, 263, 0, 2164, 2162, 1, 0, 0, 0, 2164, 2163, 1, 0, 0, 0, 2165, 529,
		1, 0, 0, 0, 2166, 2167, 5, 17, 0, 0, 2167, 2168, 3, 288, 144, 0, 2168,
		2169, 5, 24, 0, 0, 2169, 2170, 5, 10, 0, 0, 2170, 2171, 3, 386, 193, 0,
		2171, 2178, 1, 0, 0, 0, 2172, 2173, 5, 17, 0, 0, 2173, 2178, 3, 288, 144,
		0, 2174, 2175, 5, 24, 0, 0, 2175, 2176, 5, 10, 0, 0, 2176, 2178, 3, 386,
		193, 0, 2177, 2166, 1, 0, 0, 0, 2177, 2172, 1, 0, 0, 0, 2177, 2174, 1,
		0, 0, 0, 2178, 531, 1, 0, 0, 0, 2179, 2180, 3, 486, 243, 0, 2180, 533,
		1, 0, 0, 0, 2181, 2185, 3, 522, 261, 0, 2182, 2185, 3, 528, 264, 0, 2183,
		2185, 3, 530, 265, 0, 2184, 2181, 1, 0, 0, 0, 2184, 2182, 1, 0, 0, 0, 2184,
		2183, 1, 0, 0, 0, 2185, 535, 1, 0, 0, 0, 2186, 2189, 3, 532, 266, 0, 2187,
		2189, 3, 534, 267, 0, 2188, 2186, 1, 0, 0, 0, 2188, 2187, 1, 0, 0, 0, 2189,
		537, 1, 0, 0, 0, 2190, 2194, 5, 126, 0, 0, 2191, 2192, 5, 122, 0, 0, 2192,
		2194, 5, 126, 0, 0, 2193, 2190, 1, 0, 0, 0, 2193, 2191, 1, 0, 0, 0, 2194,
		539, 1, 0, 0, 0, 2195, 2202, 3, 538, 269, 0, 2196, 2202, 3, 128, 64, 0,
		2197, 2198, 3, 288, 144, 0, 2198, 2199, 5, 110, 0, 0, 2199, 2200, 3, 386,
		193, 0, 2200, 2202, 1, 0, 0, 0, 2201, 2195, 1, 0, 0, 0, 2201, 2196, 1,
		0, 0, 0, 2201, 2197, 1, 0, 0, 0, 2202, 541, 1, 0, 0, 0, 2203, 2204, 5,
		116, 0, 0, 2204, 2207, 3, 540, 270, 0, 2205, 2207, 1, 0, 0, 0, 2206, 2203,
		1, 0, 0, 0, 2206, 2205, 1, 0, 0, 0, 2207, 543, 1, 0, 0, 0, 2208, 2209,
		5, 108, 0, 0, 2209, 2210, 3, 536, 268, 0, 2210, 2211, 3, 542, 271, 0, 2211,
		2212, 5, 109, 0, 0, 2212, 545, 1, 0, 0, 0, 2213, 2214, 3, 544, 272, 0,
		2214, 547, 1, 0, 0, 0, 2215, 2218, 3, 544, 272, 0, 2216, 2218, 1, 0, 0,
		0, 2217, 2215, 1, 0, 0, 0, 2217, 2216, 1, 0, 0, 0, 2218, 549, 1, 0, 0,
		0, 2219, 2224, 5, 64, 0, 0, 2220, 2224, 5, 1, 0, 0, 2221, 2224, 5, 60,
		0, 0, 2222, 2224, 1, 0, 0, 0, 2223, 2219, 1, 0, 0, 0, 2223, 2220, 1, 0,
		0, 0, 2223, 2221, 1, 0, 0, 0, 2223, 2222, 1, 0, 0, 0, 2224, 551, 1, 0,
		0, 0, 2225, 2226, 3, 548, 274, 0, 2226, 2227, 3, 550, 275, 0, 2227, 553,
		1, 0, 0, 0, 2228, 2229, 3, 50, 25, 0, 2229, 2230, 3, 552, 276, 0, 2230,
		555, 1, 0, 0, 0, 2231, 2232, 6, 278, -1, 0, 2232, 2233, 3, 554, 277, 0,
		2233, 2239, 1, 0, 0, 0, 2234, 2235, 10, 2, 0, 0, 2235, 2236, 5, 113, 0,
		0, 2236, 2238, 3, 554, 277, 0, 2237, 2234, 1, 0, 0, 0, 2238, 2241, 1, 0,
		0, 0, 2239, 2237, 1, 0, 0, 0, 2239, 2240, 1, 0, 0, 0, 2240, 557, 1, 0,
		0, 0, 2241, 2239, 1, 0, 0, 0, 2242, 2243, 5, 104, 0, 0, 2243, 2244, 3,
		556, 278, 0, 2244, 2245, 5, 105, 0, 0, 2245, 559, 1, 0, 0, 0, 2246, 2247,
		5, 104, 0, 0, 2247, 2248, 5, 96, 0, 0, 2248, 2249, 5, 113, 0, 0, 2249,
		2250, 3, 556, 278, 0, 2250, 2251, 5, 105, 0, 0, 2251, 561, 1, 0, 0, 0,
		2252, 2255, 3, 558, 279, 0, 2253, 2255, 3, 560, 280, 0, 2254, 2252, 1,
		0, 0, 0, 2254, 2253, 1, 0, 0, 0, 2255, 563, 1, 0, 0, 0, 2256, 2257, 5,
		129, 0, 0, 2257, 565, 1, 0, 0, 0, 2258, 2259, 3, 386, 193, 0, 2259, 567,
		1, 0, 0, 0, 2260, 2261, 3, 504, 252, 0, 2261, 2262, 3, 288, 144, 0, 2262,
		569, 1, 0, 0, 0, 2263, 2264, 3, 506, 253, 0, 2264, 2265, 5, 97, 0, 0, 2265,
		2266, 3, 508, 254, 0, 2266, 571, 1, 0, 0, 0, 2267, 2268, 5, 34, 0, 0, 2268,
		2269, 3, 544, 272, 0, 2269, 573, 1, 0, 0, 0, 2270, 2271, 5, 73, 0, 0, 2271,
		2272, 3, 544, 272, 0, 2272, 575, 1, 0, 0, 0, 2273, 2274, 5, 91, 0, 0, 2274,
		2275, 5, 14, 0, 0, 2275, 2280, 3, 546, 273, 0, 2276, 2277, 5, 91, 0, 0,
		2277, 2278, 5, 15, 0, 0, 2278, 2280, 3, 562, 281, 0, 2279, 2273, 1, 0,
		0, 0, 2279, 2276, 1, 0, 0, 0, 2280, 577, 1, 0, 0, 0, 2281, 2282, 5, 61,
		0, 0, 2282, 2283, 3, 386, 193, 0, 2283, 579, 1, 0, 0, 0, 2284, 2285, 5,
		72, 0, 0, 2285, 2286, 3, 564, 282, 0, 2286, 581, 1, 0, 0, 0, 2287, 2288,
		3, 570, 285, 0, 2288, 583, 1, 0, 0, 0, 2289, 2290, 3, 570, 285, 0, 2290,
		585, 1, 0, 0, 0, 2291, 2292, 3, 570, 285, 0, 2292, 587, 1, 0, 0, 0, 2293,
		2302, 3, 566, 283, 0, 2294, 2302, 3, 568, 284, 0, 2295, 2302, 3, 570, 285,
		0, 2296, 2302, 3, 572, 286, 0, 2297, 2302, 3, 574, 287, 0, 2298, 2302,
		3, 576, 288, 0, 2299, 2302, 3, 578, 289, 0, 2300, 2302, 3, 580, 290, 0,
		2301, 2293, 1, 0, 0, 0, 2301, 2294, 1, 0, 0, 0, 2301, 2295, 1, 0, 0, 0,
		2301, 2296, 1, 0, 0, 0, 2301, 2297, 1, 0, 0, 0, 2301, 2298, 1, 0, 0, 0,
		2301, 2299, 1, 0, 0, 0, 2301, 2300, 1, 0, 0, 0, 2302, 589, 1, 0, 0, 0,
		2303, 2308, 3, 392, 196, 0, 2304, 2308, 3, 396, 198, 0, 2305, 2308, 3,
		422, 211, 0, 2306, 2308, 3, 610, 305, 0, 2307, 2303, 1, 0, 0, 0, 2307,
		2304, 1, 0, 0, 0, 2307, 2305, 1, 0, 0, 0, 2307, 2306, 1, 0, 0, 0, 2308,
		591, 1, 0, 0, 0, 2309, 2316, 3, 588, 294, 0, 2310, 2316, 3, 590, 295, 0,
		2311, 2312, 5, 108, 0, 0, 2312, 2313, 3, 488, 244, 0, 2313, 2314, 5, 109,
		0, 0, 2314, 2316, 1, 0, 0, 0, 2315, 2309, 1, 0, 0, 0, 2315, 2310, 1, 0,
		0, 0, 2315, 2311, 1, 0, 0, 0, 2316, 593, 1, 0, 0, 0, 2317, 2318, 3, 592,
		296, 0, 2318, 595, 1, 0, 0, 0, 2319, 2324, 3, 592, 296, 0, 2320, 2321,
		3, 594, 297, 0, 2321, 2322, 3, 492, 246, 0, 2322, 2324, 1, 0, 0, 0, 2323,
		2319, 1, 0, 0, 0, 2323, 2320, 1, 0, 0, 0, 2324, 597, 1, 0, 0, 0, 2325,
		2326, 3, 494, 247, 0, 2326, 599, 1, 0, 0, 0, 2327, 2328, 7, 7, 0, 0, 2328,
		601, 1, 0, 0, 0, 2329, 2332, 3, 66, 33, 0, 2330, 2332, 3, 54, 27, 0, 2331,
		2329, 1, 0, 0, 0, 2331, 2330, 1, 0, 0, 0, 2332, 603, 1, 0, 0, 0, 2333,
		2334, 5, 104, 0, 0, 2334, 2335, 3, 606, 303, 0, 2335, 2336, 5, 105, 0,
		0, 2336, 605, 1, 0, 0, 0, 2337, 2338, 6, 303, -1, 0, 2338, 2339, 3, 608,
		304, 0, 2339, 2345, 1, 0, 0, 0, 2340, 2341, 10, 2, 0, 0, 2341, 2342, 5,
		113, 0, 0, 2342, 2344, 3, 608, 304, 0, 2343, 2340, 1, 0, 0, 0, 2344, 2347,
		1, 0, 0, 0, 2345, 2343, 1, 0, 0, 0, 2345, 2346, 1, 0, 0, 0, 2346, 607,
		1, 0, 0, 0, 2347, 2345, 1, 0, 0, 0, 2348, 2355, 3, 288, 144, 0, 2349, 2355,
		3, 386, 193, 0, 2350, 2355, 3, 388, 194, 0, 2351, 2355, 3, 390, 195, 0,
		2352, 2355, 3, 392, 196, 0, 2353, 2355, 3, 478, 239, 0, 2354, 2348, 1,
		0, 0, 0, 2354, 2349, 1, 0, 0, 0, 2354, 2350, 1, 0, 0, 0, 2354, 2351, 1,
		0, 0, 0, 2354, 2352, 1, 0, 0, 0, 2354, 2353, 1, 0, 0, 0, 2355, 609, 1,
		0, 0, 0, 2356, 2357, 3, 396, 198, 0, 2357, 2358, 3, 604, 302, 0, 2358,
		611, 1, 0, 0, 0, 2359, 2360, 3, 602, 301, 0, 2360, 2361, 3, 604, 302, 0,
		2361, 613, 1, 0, 0, 0, 2362, 2363, 3, 52, 26, 0, 2363, 2364, 3, 626, 313,
		0, 2364, 2365, 5, 95, 0, 0, 2365, 2366, 3, 288, 144, 0, 2366, 615, 1, 0,
		0, 0, 2367, 2368, 3, 54, 27, 0, 2368, 2369, 3, 626, 313, 0, 2369, 2370,
		3, 288, 144, 0, 2370, 2371, 5, 95, 0, 0, 2371, 2372, 3, 386, 193, 0, 2372,
		617, 1, 0, 0, 0, 2373, 2374, 3, 52, 26, 0, 2374, 2375, 3, 626, 313, 0,
		2375, 2376, 3, 288, 144, 0, 2376, 2377, 5, 95, 0, 0, 2377, 2378, 3, 388,
		194, 0, 2378, 619, 1, 0, 0, 0, 2379, 2380, 3, 58, 29, 0, 2380, 2381, 3,
		626, 313, 0, 2381, 2382, 5, 95, 0, 0, 2382, 2383, 3, 430, 215, 0, 2383,
		621, 1, 0, 0, 0, 2384, 2385, 3, 56, 28, 0, 2385, 2386, 3, 626, 313, 0,
		2386, 2387, 3, 390, 195, 0, 2387, 2388, 5, 95, 0, 0, 2388, 2389, 3, 392,
		196, 0, 2389, 623, 1, 0, 0, 0, 2390, 2391, 3, 60, 30, 0, 2391, 2392, 3,
		626, 313, 0, 2392, 2393, 3, 390, 195, 0, 2393, 2394, 5, 95, 0, 0, 2394,
		2395, 3, 478, 239, 0, 2395, 625, 1, 0, 0, 0, 2396, 2397, 5, 104, 0, 0,
		2397, 2398, 3, 628, 314, 0, 2398, 2399, 5, 105, 0, 0, 2399, 627, 1, 0,
		0, 0, 2400, 2401, 6, 314, -1, 0, 2401, 2402, 3, 630, 315, 0, 2402, 2408,
		1, 0, 0, 0, 2403, 2404, 10, 2, 0, 0, 2404, 2405, 5, 113, 0, 0, 2405, 2407,
		3, 630, 315, 0, 2406, 2403, 1, 0, 0, 0, 2407, 2410, 1, 0, 0, 0, 2408, 2406,
		1, 0, 0, 0, 2408, 2409, 1, 0, 0, 0, 2409, 629, 1, 0, 0, 0, 2410, 2408,
		1, 0, 0, 0, 2411, 2412, 3, 632, 316, 0, 2412, 2413, 5, 110, 0, 0, 2413,
		2414, 3, 634, 317, 0, 2414, 2417, 1, 0, 0, 0, 2415, 2417, 3, 634, 317,
		0, 2416, 2411, 1, 0, 0, 0, 2416, 2415, 1, 0, 0, 0, 2417, 631, 1, 0, 0,
		0, 2418, 2421, 3, 636, 318, 0, 2419, 2421, 3, 638, 319, 0, 2420, 2418,
		1, 0, 0, 0, 2420, 2419, 1, 0, 0, 0, 2421, 633, 1, 0, 0, 0, 2422, 2423,
		3, 48, 24, 0, 2423, 635, 1, 0, 0, 0, 2424, 2427, 3, 288, 144, 0, 2425,
		2427, 3, 390, 195, 0, 2426, 2424, 1, 0, 0, 0, 2426, 2425, 1, 0, 0, 0, 2427,
		637, 1, 0, 0, 0, 2428, 2429, 3, 634, 317, 0, 2429, 639, 1, 0, 0, 0, 2430,
		2431, 1, 0, 0, 0, 2431, 641, 1, 0, 0, 0, 159, 652, 674, 687, 693, 716,
		725, 730, 737, 747, 751, 761, 766, 773, 792, 836, 840, 849, 862, 867, 873,
		883, 921, 932, 941, 948, 952, 962, 974, 984, 1000, 1008, 1017, 1027, 1033,
		1037, 1047, 1061, 1076, 1088, 1098, 1112, 1121, 1131, 1142, 1150, 1180,
		1185, 1190, 1195, 1201, 1205, 1228, 1241, 1247, 1280, 1316, 1324, 1340,
		1348, 1352, 1384, 1388, 1400, 1421, 1425, 1470, 1476, 1481, 1491, 1498,
		1508, 1547, 1555, 1562, 1571, 1582, 1593, 1607, 1620, 1626, 1642, 1650,
		1654, 1676, 1684, 1696, 1719, 1727, 1735, 1739, 1744, 1753, 1759, 1763,
		1767, 1771, 1784, 1790, 1795, 1799, 1806, 1813, 1824, 1831, 1845, 1855,
		1864, 1880, 1890, 1902, 1927, 1933, 1939, 1945, 1951, 1964, 1970, 1975,
		1979, 2007, 2024, 2029, 2040, 2055, 2064, 2068, 2072, 2078, 2083, 2088,
		2098, 2108, 2118, 2132, 2137, 2144, 2164, 2177, 2184, 2188, 2193, 2201,
		2206, 2217, 2223, 2239, 2254, 2279, 2301, 2307, 2315, 2323, 2331, 2345,
		2354, 2408, 2416, 2420, 2426,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// asn1ParserInit initializes any static state used to implement asn1Parser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// Newasn1Parser(). You can call this function if you wish to initialize the static state ahead
// of time.
func Asn1ParserInit() {
	staticData := &asn1ParserStaticData
	staticData.once.Do(asn1ParserInit)
}

// Newasn1Parser produces a new parser instance for the optional input antlr.TokenStream.
func Newasn1Parser(input antlr.TokenStream) *asn1Parser {
	Asn1ParserInit()
	this := new(asn1Parser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &asn1ParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.predictionContextCache)
	this.RuleNames = staticData.ruleNames
	this.LiteralNames = staticData.literalNames
	this.SymbolicNames = staticData.symbolicNames
	this.GrammarFileName = "asn1.g4"

	return this
}

// asn1Parser tokens.
const (
	asn1ParserEOF                   = antlr.TokenEOF
	asn1ParserABSENT_SYM            = 1
	asn1ParserABSTRACT_SYNTAX_SYM   = 2
	asn1ParserALL_SYM               = 3
	asn1ParserAPPLICATION_SYM       = 4
	asn1ParserAUTOMATIC_SYM         = 5
	asn1ParserBEGIN_SYM             = 6
	asn1ParserBIT_SYM               = 7
	asn1ParserBMP_STRING_SYM        = 8
	asn1ParserBOOLEAN_SYM           = 9
	asn1ParserBY_SYM                = 10
	asn1ParserCHARACTER_SYM         = 11
	asn1ParserCHOICE_SYM            = 12
	asn1ParserCLASS_SYM             = 13
	asn1ParserCOMPONENT_SYM         = 14
	asn1ParserCOMPONENTS_SYM        = 15
	asn1ParserCONSTRAINED_SYM       = 16
	asn1ParserCONTAINING_SYM        = 17
	asn1ParserDATE_SYM              = 18
	asn1ParserDATE_TIME_SYM         = 19
	asn1ParserDEFAULT_SYM           = 20
	asn1ParserDEFINITIONS_SYM       = 21
	asn1ParserDURATION_SYM          = 22
	asn1ParserEMBEDDED_SYM          = 23
	asn1ParserENCODED_SYM           = 24
	asn1ParserENCODING_CONTROL_SYM  = 25
	asn1ParserEND_SYM               = 26
	asn1ParserENUMERATED_SYM        = 27
	asn1ParserEXCEPT_SYM            = 28
	asn1ParserEXPLICIT_SYM          = 29
	asn1ParserEXPORTS_SYM           = 30
	asn1ParserEXTENSIBILITY_SYM     = 31
	asn1ParserEXTERNAL_SYM          = 32
	asn1ParserFALSE_SYM             = 33
	asn1ParserFROM_SYM              = 34
	asn1ParserGENERALIZED_TIME_SYM  = 35
	asn1ParserGENERAL_STRING_SYM    = 36
	asn1ParserGRAPHIC_STRING_SYM    = 37
	asn1ParserIA5_STRING_SYM        = 38
	asn1ParserIDENTIFIER_SYM        = 39
	asn1ParserIMPLICIT_SYM          = 40
	asn1ParserIMPLIED_SYM           = 41
	asn1ParserIMPORTS_SYM           = 42
	asn1ParserINCLUDES_SYM          = 43
	asn1ParserINSTANCE_SYM          = 44
	asn1ParserINSTRUCTIONS_SYM      = 45
	asn1ParserINTEGER_SYM           = 46
	asn1ParserINTERSECTION_SYM      = 47
	asn1ParserISO646_STRING_SYM     = 48
	asn1ParserMAX_SYM               = 49
	asn1ParserMIN_SYM               = 50
	asn1ParserMINUS_INFINITY_SYM    = 51
	asn1ParserNOT_A_NUMBER_SYM      = 52
	asn1ParserNULL_SYM              = 53
	asn1ParserNUMERIC_STRING_SYM    = 54
	asn1ParserOBJECT_SYM            = 55
	asn1ParserOBJECT_DESCRIPTOR_SYM = 56
	asn1ParserOCTET_SYM             = 57
	asn1ParserOF_SYM                = 58
	asn1ParserOID_IRI_SYM           = 59
	asn1ParserOPTIONAL_SYM          = 60
	asn1ParserPATTERN_SYM           = 61
	asn1ParserPDV_SYM               = 62
	asn1ParserPLUS_INFINITY_SYM     = 63
	asn1ParserPRESENT_SYM           = 64
	asn1ParserPRINTABLE_STRING_SYM  = 65
	asn1ParserPRIVATE_SYM           = 66
	asn1ParserREAL_SYM              = 67
	asn1ParserRELATIVE_OID_SYM      = 68
	asn1ParserRELATIVE_OID_IRI_SYM  = 69
	asn1ParserSEQUENCE_SYM          = 70
	asn1ParserSET_SYM               = 71
	asn1ParserSETTINGS_SYM          = 72
	asn1ParserSIZE_SYM              = 73
	asn1ParserSTRING_SYM            = 74
	asn1ParserSYNTAX_SYM            = 75
	asn1ParserT61_STRING_SYM        = 76
	asn1ParserTAGS_SYM              = 77
	asn1ParserTELETEX_STRING_SYM    = 78
	asn1ParserTIME_SYM              = 79
	asn1ParserTIME_OF_DAY_SYM       = 80
	asn1ParserTRUE_SYM              = 81
	asn1ParserTYPE_IDENTIFIER_SYM   = 82
	asn1ParserUNION_SYM             = 83
	asn1ParserUNIQUE_SYM            = 84
	asn1ParserUNIVERSAL_SYM         = 85
	asn1ParserUNIVERSAL_STRING_SYM  = 86
	asn1ParserUTC_TIME_SYM          = 87
	asn1ParserUTF8_STRING_SYM       = 88
	asn1ParserVIDEOTEX_STRING_SYM   = 89
	asn1ParserVISIBLE_STRING_SYM    = 90
	asn1ParserWITH_SYM              = 91
	asn1ParserTAG_SYM               = 92
	asn1ParserXER_SYM               = 93
	asn1ParserPER_SYM               = 94
	asn1ParserASSIGNMENT            = 95
	asn1ParserELLIPSIS              = 96
	asn1ParserRANGE                 = 97
	asn1ParserVERSION_START         = 98
	asn1ParserVERSION_END           = 99
	asn1ParserDASH_COMMENT          = 100
	asn1ParserBLOCK_START           = 101
	asn1ParserBLOCK_END             = 102
	asn1ParserAND                   = 103
	asn1ParserCURLY_START           = 104
	asn1ParserCURLY_END             = 105
	asn1ParserSQUARE_START          = 106
	asn1ParserSQUARE_END            = 107
	asn1ParserROUND_START           = 108
	asn1ParserROUND_END             = 109
	asn1ParserCOLON                 = 110
	asn1ParserGREATER               = 111
	asn1ParserLESS                  = 112
	asn1ParserCOMMA                 = 113
	asn1ParserSLASH                 = 114
	asn1ParserPIPE                  = 115
	asn1ParserEXCLAMATION           = 116
	asn1ParserAT                    = 117
	asn1ParserCARAT                 = 118
	asn1ParserSEMI_COMMA            = 119
	asn1ParserDOT                   = 120
	asn1ParserEQUALS                = 121
	asn1ParserMINUS                 = 122
	asn1ParserSINGLE_QUOTE          = 123
	asn1ParserDOUBLE_QUOTE          = 124
	asn1ParserFLOAT                 = 125
	asn1ParserNUMBER                = 126
	asn1ParserHEX_STRING            = 127
	asn1ParserBIN_STRING            = 128
	asn1ParserCHAR_STRING           = 129
	asn1ParserWHITESPACE            = 130
	asn1ParserUCASE_ID              = 131
	asn1ParserLCASE_ID              = 132
	asn1ParserLINE_COMMENT          = 133
	asn1ParserBLOCK_COMMENT         = 134
)

// asn1Parser rules.
const (
	asn1ParserRULE_start                                   = 0
	asn1ParserRULE_ruleModules                             = 1
	asn1ParserRULE_ruleModuleDefinition                    = 2
	asn1ParserRULE_ruleModuleReference                     = 3
	asn1ParserRULE_ruleModuleIdentifier                    = 4
	asn1ParserRULE_ruleDefinitiveIdentification            = 5
	asn1ParserRULE_ruleDefinitiveOID                       = 6
	asn1ParserRULE_ruleDefinitiveObjIdComponentList        = 7
	asn1ParserRULE_ruleDefinitiveObjIdComponent            = 8
	asn1ParserRULE_ruleNameForm                            = 9
	asn1ParserRULE_ruleDefinitiveNumberForm                = 10
	asn1ParserRULE_ruleDefinitiveNameAndNumberForm         = 11
	asn1ParserRULE_ruleDefinitiveOIDAndIRI                 = 12
	asn1ParserRULE_ruleFirstArcIdentifier                  = 13
	asn1ParserRULE_ruleSubsequentArcIdentifier             = 14
	asn1ParserRULE_ruleIRIValue                            = 15
	asn1ParserRULE_ruleEncodingReferenceDefault            = 16
	asn1ParserRULE_ruleTagDefault                          = 17
	asn1ParserRULE_ruleExtensionDefault                    = 18
	asn1ParserRULE_ruleModuleBody                          = 19
	asn1ParserRULE_ruleExports                             = 20
	asn1ParserRULE_ruleSymbolsExported                     = 21
	asn1ParserRULE_ruleSymbolList                          = 22
	asn1ParserRULE_ruleSymbol                              = 23
	asn1ParserRULE_ruleReference                           = 24
	asn1ParserRULE_ruleIdentifier                          = 25
	asn1ParserRULE_ruleTypeReference                       = 26
	asn1ParserRULE_ruleValueReference                      = 27
	asn1ParserRULE_ruleObjectReference                     = 28
	asn1ParserRULE_ruleObjectClassReference                = 29
	asn1ParserRULE_ruleObjectSetReference                  = 30
	asn1ParserRULE_ruleParameterizedReference              = 31
	asn1ParserRULE_ruleExternalTypeReference               = 32
	asn1ParserRULE_ruleExternalValueReference              = 33
	asn1ParserRULE_ruleExternalObjectClassReference        = 34
	asn1ParserRULE_ruleExternalObjectReference             = 35
	asn1ParserRULE_ruleExternalObjectSetReference          = 36
	asn1ParserRULE_ruleTypeFieldReference                  = 37
	asn1ParserRULE_ruleValueFieldReference                 = 38
	asn1ParserRULE_ruleValueSetFieldReference              = 39
	asn1ParserRULE_ruleObjectFieldReference                = 40
	asn1ParserRULE_ruleObjectSetFieldReference             = 41
	asn1ParserRULE_ruleUsefulObjectClassReference          = 42
	asn1ParserRULE_ruleImports                             = 43
	asn1ParserRULE_ruleSymbolsImported                     = 44
	asn1ParserRULE_ruleSymbolsFromModuleList               = 45
	asn1ParserRULE_ruleSymbolsFromModule                   = 46
	asn1ParserRULE_ruleGlobalModuleReference               = 47
	asn1ParserRULE_ruleAssignedIdentifier                  = 48
	asn1ParserRULE_ruleAssignmentList                      = 49
	asn1ParserRULE_ruleAssignment                          = 50
	asn1ParserRULE_ruleTypeAssignment                      = 51
	asn1ParserRULE_ruleValueAssignment                     = 52
	asn1ParserRULE_ruleXMLValueAssignment                  = 53
	asn1ParserRULE_ruleValueSetTypeAssignment              = 54
	asn1ParserRULE_ruleObjectAssignment                    = 55
	asn1ParserRULE_ruleObjectClassAssignment               = 56
	asn1ParserRULE_ruleObjectSetAssignment                 = 57
	asn1ParserRULE_ruleParameterizedAssignment             = 58
	asn1ParserRULE_ruleObjectIdentifierValue               = 59
	asn1ParserRULE_ruleObjIdComponentsList                 = 60
	asn1ParserRULE_ruleObjIdComponents                     = 61
	asn1ParserRULE_ruleNumberForm                          = 62
	asn1ParserRULE_ruleNameAndNumberForm                   = 63
	asn1ParserRULE_ruleDefinedValue                        = 64
	asn1ParserRULE_ruleNamedBit                            = 65
	asn1ParserRULE_ruleNamedBitList                        = 66
	asn1ParserRULE_ruleRestrictedCharacterStringType       = 67
	asn1ParserRULE_ruleUnrestrictedCharacterStringType     = 68
	asn1ParserRULE_ruleAlternativeTypeList                 = 69
	asn1ParserRULE_ruleRootAlternativeTypeList             = 70
	asn1ParserRULE_ruleVersionNumber                       = 71
	asn1ParserRULE_ruleExtensionAdditionAlternativesGroup  = 72
	asn1ParserRULE_ruleExtensionAdditionAlternative        = 73
	asn1ParserRULE_ruleExtensionAdditionAlternativesList   = 74
	asn1ParserRULE_ruleExtensionAdditionAlternatives       = 75
	asn1ParserRULE_ruleEnumerationItem                     = 76
	asn1ParserRULE_ruleEnumeration                         = 77
	asn1ParserRULE_ruleRootEnumeration                     = 78
	asn1ParserRULE_ruleAdditionalEnumeration               = 79
	asn1ParserRULE_ruleAlternativeTypeLists                = 80
	asn1ParserRULE_ruleEnumerations                        = 81
	asn1ParserRULE_ruleNamedNumber                         = 82
	asn1ParserRULE_ruleNamedNumberList                     = 83
	asn1ParserRULE_ruleComponentType                       = 84
	asn1ParserRULE_ruleExtensionAdditionGroup              = 85
	asn1ParserRULE_ruleExtensionAddition                   = 86
	asn1ParserRULE_ruleComponentTypeList                   = 87
	asn1ParserRULE_ruleExtensionAdditionList               = 88
	asn1ParserRULE_ruleRootComponentTypeList               = 89
	asn1ParserRULE_ruleExtensionAdditions                  = 90
	asn1ParserRULE_ruleExtensionEndMarker                  = 91
	asn1ParserRULE_ruleComponentTypeLists                  = 92
	asn1ParserRULE_ruleExtensionAndException               = 93
	asn1ParserRULE_ruleOptionalExtensionMarker             = 94
	asn1ParserRULE_ruleEncodingReference                   = 95
	asn1ParserRULE_ruleClass                               = 96
	asn1ParserRULE_ruleClassNumber                         = 97
	asn1ParserRULE_ruleEncodingInstruction                 = 98
	asn1ParserRULE_ruleTag                                 = 99
	asn1ParserRULE_ruleEncodingPrefix                      = 100
	asn1ParserRULE_ruleTaggedType                          = 101
	asn1ParserRULE_ruleEncodingPrefixedType                = 102
	asn1ParserRULE_ruleBitStringType                       = 103
	asn1ParserRULE_ruleBooleanType                         = 104
	asn1ParserRULE_ruleCharacterStringType                 = 105
	asn1ParserRULE_ruleChoiceType                          = 106
	asn1ParserRULE_ruleDateType                            = 107
	asn1ParserRULE_ruleDateTimeType                        = 108
	asn1ParserRULE_ruleDurationType                        = 109
	asn1ParserRULE_ruleEmbeddedPDVType                     = 110
	asn1ParserRULE_ruleEnumeratedType                      = 111
	asn1ParserRULE_ruleExternalType                        = 112
	asn1ParserRULE_ruleInstanceOfType                      = 113
	asn1ParserRULE_ruleIntegerType                         = 114
	asn1ParserRULE_ruleIRIType                             = 115
	asn1ParserRULE_ruleNullType                            = 116
	asn1ParserRULE_ruleObjectClassFieldType                = 117
	asn1ParserRULE_ruleObjectIdentifierType                = 118
	asn1ParserRULE_ruleOctetStringType                     = 119
	asn1ParserRULE_ruleRealType                            = 120
	asn1ParserRULE_ruleRelativeIRIType                     = 121
	asn1ParserRULE_ruleRelativeOIDType                     = 122
	asn1ParserRULE_ruleSequenceType                        = 123
	asn1ParserRULE_ruleSequenceOfType                      = 124
	asn1ParserRULE_ruleSetType                             = 125
	asn1ParserRULE_ruleSetOfType                           = 126
	asn1ParserRULE_rulePrefixedType                        = 127
	asn1ParserRULE_ruleTimeType                            = 128
	asn1ParserRULE_ruleTimeOfDayType                       = 129
	asn1ParserRULE_ruleBuiltinType                         = 130
	asn1ParserRULE_ruleSimpleDefinedType                   = 131
	asn1ParserRULE_ruleParameterizedType                   = 132
	asn1ParserRULE_ruleParameterizedValueSetType           = 133
	asn1ParserRULE_ruleDefinedType                         = 134
	asn1ParserRULE_ruleUsefulType                          = 135
	asn1ParserRULE_ruleSelectionType                       = 136
	asn1ParserRULE_ruleTypeFromObject                      = 137
	asn1ParserRULE_ruleValueSetFromObjects                 = 138
	asn1ParserRULE_ruleReferencedType                      = 139
	asn1ParserRULE_ruleTypeForConstraint                   = 140
	asn1ParserRULE_ruleNamedType                           = 141
	asn1ParserRULE_ruleTypeWithConstraint                  = 142
	asn1ParserRULE_ruleConstrainedType                     = 143
	asn1ParserRULE_ruleType                                = 144
	asn1ParserRULE_ruleIdentifierList                      = 145
	asn1ParserRULE_ruleCharsDefn                           = 146
	asn1ParserRULE_ruleCharSyms                            = 147
	asn1ParserRULE_ruleGroup                               = 148
	asn1ParserRULE_rulePlane                               = 149
	asn1ParserRULE_ruleRow                                 = 150
	asn1ParserRULE_ruleCell                                = 151
	asn1ParserRULE_ruleTableColumn                         = 152
	asn1ParserRULE_ruleTableRow                            = 153
	asn1ParserRULE_ruleCharacterStringList                 = 154
	asn1ParserRULE_ruleQuadruple                           = 155
	asn1ParserRULE_ruleTuple                               = 156
	asn1ParserRULE_ruleRestrictedCharacterStringValue      = 157
	asn1ParserRULE_ruleUnrestrictedCharacterStringValue    = 158
	asn1ParserRULE_ruleNumericRealValue                    = 159
	asn1ParserRULE_ruleSpecialRealValue                    = 160
	asn1ParserRULE_ruleRelativeOIDComponents               = 161
	asn1ParserRULE_ruleRelativeOIDComponentsList           = 162
	asn1ParserRULE_ruleComponentValueList                  = 163
	asn1ParserRULE_ruleValueList                           = 164
	asn1ParserRULE_ruleNamedValue                          = 165
	asn1ParserRULE_ruleNamedValueList                      = 166
	asn1ParserRULE_ruleBitStringValue                      = 167
	asn1ParserRULE_ruleBooleanValue                        = 168
	asn1ParserRULE_ruleCharacterStringValue                = 169
	asn1ParserRULE_ruleChoiceValue                         = 170
	asn1ParserRULE_ruleEmbeddedPDVValue                    = 171
	asn1ParserRULE_ruleEnumeratedValue                     = 172
	asn1ParserRULE_ruleExternalValue                       = 173
	asn1ParserRULE_ruleInstanceOfValue                     = 174
	asn1ParserRULE_ruleIntegerValue                        = 175
	asn1ParserRULE_ruleNullValue                           = 176
	asn1ParserRULE_ruleOctetStringValue                    = 177
	asn1ParserRULE_ruleRealValue                           = 178
	asn1ParserRULE_ruleRelativeIRIValue                    = 179
	asn1ParserRULE_ruleRelativeOIDValue                    = 180
	asn1ParserRULE_ruleSequenceValue                       = 181
	asn1ParserRULE_ruleSequenceOfValue                     = 182
	asn1ParserRULE_ruleSetValue                            = 183
	asn1ParserRULE_ruleSetOfValue                          = 184
	asn1ParserRULE_rulePrefixedValue                       = 185
	asn1ParserRULE_ruleTimeValue                           = 186
	asn1ParserRULE_ruleBuiltinValue                        = 187
	asn1ParserRULE_ruleValueFromObject                     = 188
	asn1ParserRULE_ruleReferencedValue                     = 189
	asn1ParserRULE_ruleOpenTypeFieldVal                    = 190
	asn1ParserRULE_ruleFixedTypeFieldVal                   = 191
	asn1ParserRULE_ruleObjectClassFieldValue               = 192
	asn1ParserRULE_ruleValue                               = 193
	asn1ParserRULE_ruleValueSet                            = 194
	asn1ParserRULE_ruleDefinedObjectClass                  = 195
	asn1ParserRULE_ruleObject                              = 196
	asn1ParserRULE_ruleDefinedObject                       = 197
	asn1ParserRULE_ruleDefinedObjectSet                    = 198
	asn1ParserRULE_ruleObjectDefn                          = 199
	asn1ParserRULE_ruleDefaultSyntax                       = 200
	asn1ParserRULE_ruleDefinedSyntax                       = 201
	asn1ParserRULE_ruleDefinedSyntaxTokenList              = 202
	asn1ParserRULE_ruleDefinedSyntaxToken                  = 203
	asn1ParserRULE_ruleLiteral                             = 204
	asn1ParserRULE_ruleWord                                = 205
	asn1ParserRULE_ruleFieldSettingList                    = 206
	asn1ParserRULE_ruleFieldSetting                        = 207
	asn1ParserRULE_rulePrimitiveFieldName                  = 208
	asn1ParserRULE_ruleSetting                             = 209
	asn1ParserRULE_ruleObjectFromObject                    = 210
	asn1ParserRULE_ruleObjectSetFromObjects                = 211
	asn1ParserRULE_ruleReferencedObjects                   = 212
	asn1ParserRULE_ruleFieldName                           = 213
	asn1ParserRULE_ruleParameterizedObject                 = 214
	asn1ParserRULE_ruleObjectClass                         = 215
	asn1ParserRULE_ruleObjectClassDefn                     = 216
	asn1ParserRULE_ruleFieldSpecList                       = 217
	asn1ParserRULE_ruleFieldSpec                           = 218
	asn1ParserRULE_ruleTypeFieldSpec                       = 219
	asn1ParserRULE_ruleFixedTypeValueFieldSpec             = 220
	asn1ParserRULE_ruleUnique                              = 221
	asn1ParserRULE_ruleVariableTypeValueFieldSpec          = 222
	asn1ParserRULE_ruleFixedTypeValueSetFieldSpec          = 223
	asn1ParserRULE_ruleVariableTypeValueSetFieldSpec       = 224
	asn1ParserRULE_ruleObjectFieldSpec                     = 225
	asn1ParserRULE_ruleObjectSetFieldSpec                  = 226
	asn1ParserRULE_ruleTypeOptionalitySpec                 = 227
	asn1ParserRULE_ruleValueOptionalitySpec                = 228
	asn1ParserRULE_ruleValueSetOptionalitySpec             = 229
	asn1ParserRULE_ruleObjectOptionalitySpec               = 230
	asn1ParserRULE_ruleObjectSetOptionalitySpec            = 231
	asn1ParserRULE_ruleWithSyntaxSpec                      = 232
	asn1ParserRULE_ruleSyntaxList                          = 233
	asn1ParserRULE_ruleTokenOrGroupSpecList                = 234
	asn1ParserRULE_ruleTokenOrGroupSpec                    = 235
	asn1ParserRULE_ruleRequiredToken                       = 236
	asn1ParserRULE_ruleOptionalGroup                       = 237
	asn1ParserRULE_ruleParameterizedObjectClass            = 238
	asn1ParserRULE_ruleObjectSet                           = 239
	asn1ParserRULE_ruleObjectSetSpec                       = 240
	asn1ParserRULE_ruleRootElementSetSpec                  = 241
	asn1ParserRULE_ruleAdditionalElementSetSpec            = 242
	asn1ParserRULE_ruleElementSetSpecs                     = 243
	asn1ParserRULE_ruleElementSetSpec                      = 244
	asn1ParserRULE_ruleUnions                              = 245
	asn1ParserRULE_ruleExclusions                          = 246
	asn1ParserRULE_ruleIntersections                       = 247
	asn1ParserRULE_ruleUElems                              = 248
	asn1ParserRULE_ruleUnionMark                           = 249
	asn1ParserRULE_ruleLowerEndValue                       = 250
	asn1ParserRULE_ruleUpperEndValue                       = 251
	asn1ParserRULE_ruleIncludes                            = 252
	asn1ParserRULE_ruleLowerEndpoint                       = 253
	asn1ParserRULE_ruleUpperEndpoint                       = 254
	asn1ParserRULE_ruleLevel                               = 255
	asn1ParserRULE_ruleComponentIdList                     = 256
	asn1ParserRULE_ruleAtNotation                          = 257
	asn1ParserRULE_ruleAtNotationList                      = 258
	asn1ParserRULE_ruleUserDefinedConstraintParameter      = 259
	asn1ParserRULE_ruleUserDefinedConstraintParameterList  = 260
	asn1ParserRULE_ruleUserDefinedConstraint               = 261
	asn1ParserRULE_ruleSimpleTableConstraint               = 262
	asn1ParserRULE_ruleComponentRelationConstraint         = 263
	asn1ParserRULE_ruleTableConstraint                     = 264
	asn1ParserRULE_ruleContentsConstraint                  = 265
	asn1ParserRULE_ruleSubtypeConstraint                   = 266
	asn1ParserRULE_ruleGeneralConstraint                   = 267
	asn1ParserRULE_ruleConstraintSpec                      = 268
	asn1ParserRULE_ruleSignedNumber                        = 269
	asn1ParserRULE_ruleExceptionIdentification             = 270
	asn1ParserRULE_ruleExceptionSpec                       = 271
	asn1ParserRULE_ruleConstraint                          = 272
	asn1ParserRULE_ruleSingleTypeConstraint                = 273
	asn1ParserRULE_ruleValueConstraint                     = 274
	asn1ParserRULE_rulePresenceConstraint                  = 275
	asn1ParserRULE_ruleComponentConstraint                 = 276
	asn1ParserRULE_ruleNamedConstraint                     = 277
	asn1ParserRULE_ruleTypeConstraints                     = 278
	asn1ParserRULE_ruleFullSpecification                   = 279
	asn1ParserRULE_rulePartialSpecification                = 280
	asn1ParserRULE_ruleMultipleTypeConstraints             = 281
	asn1ParserRULE_ruleSimpleString                        = 282
	asn1ParserRULE_ruleSingleValue                         = 283
	asn1ParserRULE_ruleContainedSubtype                    = 284
	asn1ParserRULE_ruleValueRange                          = 285
	asn1ParserRULE_rulePermittedAlphabet                   = 286
	asn1ParserRULE_ruleSizeConstraint                      = 287
	asn1ParserRULE_ruleInnerTypeConstraints                = 288
	asn1ParserRULE_rulePatternConstraint                   = 289
	asn1ParserRULE_rulePropertySettings                    = 290
	asn1ParserRULE_ruleDurationRange                       = 291
	asn1ParserRULE_ruleTimePointRange                      = 292
	asn1ParserRULE_ruleRecurrenceRange                     = 293
	asn1ParserRULE_ruleSubtypeElements                     = 294
	asn1ParserRULE_ruleObjectSetElements                   = 295
	asn1ParserRULE_ruleElements                            = 296
	asn1ParserRULE_ruleElems                               = 297
	asn1ParserRULE_ruleIntersectionElements                = 298
	asn1ParserRULE_ruleIElems                              = 299
	asn1ParserRULE_ruleIntersectionMark                    = 300
	asn1ParserRULE_ruleSimpleDefinedValue                  = 301
	asn1ParserRULE_ruleActualParameterList                 = 302
	asn1ParserRULE_ruleActualParameters                    = 303
	asn1ParserRULE_ruleActualParameter                     = 304
	asn1ParserRULE_ruleParameterizedObjectSet              = 305
	asn1ParserRULE_ruleParameterizedValue                  = 306
	asn1ParserRULE_ruleParameterizedTypeAssignment         = 307
	asn1ParserRULE_ruleParameterizedValueAssignment        = 308
	asn1ParserRULE_ruleParameterizedValueSetTypeAssignment = 309
	asn1ParserRULE_ruleParameterizedObjectClassAssignment  = 310
	asn1ParserRULE_ruleParameterizedObjectAssignment       = 311
	asn1ParserRULE_ruleParameterizedObjectSetAssignment    = 312
	asn1ParserRULE_ruleParameterList                       = 313
	asn1ParserRULE_ruleParameters                          = 314
	asn1ParserRULE_ruleParameter                           = 315
	asn1ParserRULE_ruleParamGovernor                       = 316
	asn1ParserRULE_ruleDummyReference                      = 317
	asn1ParserRULE_ruleGovernor                            = 318
	asn1ParserRULE_ruleDummyGovernor                       = 319
	asn1ParserRULE_ruleEncodingControlSections             = 320
)

// IStartContext is an interface to support dynamic dispatch.
type IStartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStartContext differentiates from other interfaces.
	IsStartContext()
}

type StartContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartContext() *StartContext {
	var p = new(StartContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_start
	return p
}

func (*StartContext) IsStartContext() {}

func NewStartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartContext {
	var p = new(StartContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_start

	return p
}

func (s *StartContext) GetParser() antlr.Parser { return s.parser }

func (s *StartContext) RuleModules() IRuleModulesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleModulesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleModulesContext)
}

func (s *StartContext) EOF() antlr.TerminalNode {
	return s.GetToken(asn1ParserEOF, 0)
}

func (s *StartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterStart(s)
	}
}

func (s *StartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitStart(s)
	}
}

func (s *StartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitStart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) Start() (localctx IStartContext) {
	this := p
	_ = this

	localctx = NewStartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, asn1ParserRULE_start)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(642)
		p.ruleModules(0)
	}
	{
		p.SetState(643)
		p.Match(asn1ParserEOF)
	}

	return localctx
}

// IRuleModulesContext is an interface to support dynamic dispatch.
type IRuleModulesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleModulesContext differentiates from other interfaces.
	IsRuleModulesContext()
}

type RuleModulesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleModulesContext() *RuleModulesContext {
	var p = new(RuleModulesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleModules
	return p
}

func (*RuleModulesContext) IsRuleModulesContext() {}

func NewRuleModulesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleModulesContext {
	var p = new(RuleModulesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleModules

	return p
}

func (s *RuleModulesContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleModulesContext) RuleModuleDefinition() IRuleModuleDefinitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleModuleDefinitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleModuleDefinitionContext)
}

func (s *RuleModulesContext) RuleModules() IRuleModulesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleModulesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleModulesContext)
}

func (s *RuleModulesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleModulesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleModulesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleModules(s)
	}
}

func (s *RuleModulesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleModules(s)
	}
}

func (s *RuleModulesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleModules(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleModules() (localctx IRuleModulesContext) {
	return p.ruleModules(0)
}

func (p *asn1Parser) ruleModules(_p int) (localctx IRuleModulesContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRuleModulesContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRuleModulesContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 2
	p.EnterRecursionRule(localctx, 2, asn1ParserRULE_ruleModules, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(646)
		p.RuleModuleDefinition()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(652)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewRuleModulesContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, asn1ParserRULE_ruleModules)
			p.SetState(648)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(649)
				p.RuleModuleDefinition()
			}

		}
		p.SetState(654)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext())
	}

	return localctx
}

// IRuleModuleDefinitionContext is an interface to support dynamic dispatch.
type IRuleModuleDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleModuleDefinitionContext differentiates from other interfaces.
	IsRuleModuleDefinitionContext()
}

type RuleModuleDefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleModuleDefinitionContext() *RuleModuleDefinitionContext {
	var p = new(RuleModuleDefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleModuleDefinition
	return p
}

func (*RuleModuleDefinitionContext) IsRuleModuleDefinitionContext() {}

func NewRuleModuleDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleModuleDefinitionContext {
	var p = new(RuleModuleDefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleModuleDefinition

	return p
}

func (s *RuleModuleDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleModuleDefinitionContext) RuleModuleIdentifier() IRuleModuleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleModuleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleModuleIdentifierContext)
}

func (s *RuleModuleDefinitionContext) DEFINITIONS_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserDEFINITIONS_SYM, 0)
}

func (s *RuleModuleDefinitionContext) RuleEncodingReferenceDefault() IRuleEncodingReferenceDefaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleEncodingReferenceDefaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleEncodingReferenceDefaultContext)
}

func (s *RuleModuleDefinitionContext) RuleTagDefault() IRuleTagDefaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTagDefaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTagDefaultContext)
}

func (s *RuleModuleDefinitionContext) RuleExtensionDefault() IRuleExtensionDefaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleExtensionDefaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleExtensionDefaultContext)
}

func (s *RuleModuleDefinitionContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(asn1ParserASSIGNMENT, 0)
}

func (s *RuleModuleDefinitionContext) BEGIN_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserBEGIN_SYM, 0)
}

func (s *RuleModuleDefinitionContext) RuleModuleBody() IRuleModuleBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleModuleBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleModuleBodyContext)
}

func (s *RuleModuleDefinitionContext) RuleEncodingControlSections() IRuleEncodingControlSectionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleEncodingControlSectionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleEncodingControlSectionsContext)
}

func (s *RuleModuleDefinitionContext) END_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserEND_SYM, 0)
}

func (s *RuleModuleDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleModuleDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleModuleDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleModuleDefinition(s)
	}
}

func (s *RuleModuleDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleModuleDefinition(s)
	}
}

func (s *RuleModuleDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleModuleDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleModuleDefinition() (localctx IRuleModuleDefinitionContext) {
	this := p
	_ = this

	localctx = NewRuleModuleDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, asn1ParserRULE_ruleModuleDefinition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(655)
		p.RuleModuleIdentifier()
	}
	{
		p.SetState(656)
		p.Match(asn1ParserDEFINITIONS_SYM)
	}
	{
		p.SetState(657)
		p.RuleEncodingReferenceDefault()
	}
	{
		p.SetState(658)
		p.RuleTagDefault()
	}
	{
		p.SetState(659)
		p.RuleExtensionDefault()
	}
	{
		p.SetState(660)
		p.Match(asn1ParserASSIGNMENT)
	}
	{
		p.SetState(661)
		p.Match(asn1ParserBEGIN_SYM)
	}
	{
		p.SetState(662)
		p.RuleModuleBody()
	}
	{
		p.SetState(663)
		p.RuleEncodingControlSections()
	}
	{
		p.SetState(664)
		p.Match(asn1ParserEND_SYM)
	}

	return localctx
}

// IRuleModuleReferenceContext is an interface to support dynamic dispatch.
type IRuleModuleReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleModuleReferenceContext differentiates from other interfaces.
	IsRuleModuleReferenceContext()
}

type RuleModuleReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleModuleReferenceContext() *RuleModuleReferenceContext {
	var p = new(RuleModuleReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleModuleReference
	return p
}

func (*RuleModuleReferenceContext) IsRuleModuleReferenceContext() {}

func NewRuleModuleReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleModuleReferenceContext {
	var p = new(RuleModuleReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleModuleReference

	return p
}

func (s *RuleModuleReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleModuleReferenceContext) UCASE_ID() antlr.TerminalNode {
	return s.GetToken(asn1ParserUCASE_ID, 0)
}

func (s *RuleModuleReferenceContext) LCASE_ID() antlr.TerminalNode {
	return s.GetToken(asn1ParserLCASE_ID, 0)
}

func (s *RuleModuleReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleModuleReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleModuleReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleModuleReference(s)
	}
}

func (s *RuleModuleReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleModuleReference(s)
	}
}

func (s *RuleModuleReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleModuleReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleModuleReference() (localctx IRuleModuleReferenceContext) {
	this := p
	_ = this

	localctx = NewRuleModuleReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, asn1ParserRULE_ruleModuleReference)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(666)
		_la = p.GetTokenStream().LA(1)

		if !(_la == asn1ParserUCASE_ID || _la == asn1ParserLCASE_ID) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IRuleModuleIdentifierContext is an interface to support dynamic dispatch.
type IRuleModuleIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleModuleIdentifierContext differentiates from other interfaces.
	IsRuleModuleIdentifierContext()
}

type RuleModuleIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleModuleIdentifierContext() *RuleModuleIdentifierContext {
	var p = new(RuleModuleIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleModuleIdentifier
	return p
}

func (*RuleModuleIdentifierContext) IsRuleModuleIdentifierContext() {}

func NewRuleModuleIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleModuleIdentifierContext {
	var p = new(RuleModuleIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleModuleIdentifier

	return p
}

func (s *RuleModuleIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleModuleIdentifierContext) RuleModuleReference() IRuleModuleReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleModuleReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleModuleReferenceContext)
}

func (s *RuleModuleIdentifierContext) RuleDefinitiveIdentification() IRuleDefinitiveIdentificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinitiveIdentificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinitiveIdentificationContext)
}

func (s *RuleModuleIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleModuleIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleModuleIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleModuleIdentifier(s)
	}
}

func (s *RuleModuleIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleModuleIdentifier(s)
	}
}

func (s *RuleModuleIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleModuleIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleModuleIdentifier() (localctx IRuleModuleIdentifierContext) {
	this := p
	_ = this

	localctx = NewRuleModuleIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, asn1ParserRULE_ruleModuleIdentifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(668)
		p.RuleModuleReference()
	}
	{
		p.SetState(669)
		p.RuleDefinitiveIdentification()
	}

	return localctx
}

// IRuleDefinitiveIdentificationContext is an interface to support dynamic dispatch.
type IRuleDefinitiveIdentificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleDefinitiveIdentificationContext differentiates from other interfaces.
	IsRuleDefinitiveIdentificationContext()
}

type RuleDefinitiveIdentificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleDefinitiveIdentificationContext() *RuleDefinitiveIdentificationContext {
	var p = new(RuleDefinitiveIdentificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleDefinitiveIdentification
	return p
}

func (*RuleDefinitiveIdentificationContext) IsRuleDefinitiveIdentificationContext() {}

func NewRuleDefinitiveIdentificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleDefinitiveIdentificationContext {
	var p = new(RuleDefinitiveIdentificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleDefinitiveIdentification

	return p
}

func (s *RuleDefinitiveIdentificationContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleDefinitiveIdentificationContext) RuleDefinitiveOID() IRuleDefinitiveOIDContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinitiveOIDContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinitiveOIDContext)
}

func (s *RuleDefinitiveIdentificationContext) RuleDefinitiveOIDAndIRI() IRuleDefinitiveOIDAndIRIContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinitiveOIDAndIRIContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinitiveOIDAndIRIContext)
}

func (s *RuleDefinitiveIdentificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleDefinitiveIdentificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleDefinitiveIdentificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleDefinitiveIdentification(s)
	}
}

func (s *RuleDefinitiveIdentificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleDefinitiveIdentification(s)
	}
}

func (s *RuleDefinitiveIdentificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleDefinitiveIdentification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleDefinitiveIdentification() (localctx IRuleDefinitiveIdentificationContext) {
	this := p
	_ = this

	localctx = NewRuleDefinitiveIdentificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, asn1ParserRULE_ruleDefinitiveIdentification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(674)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(671)
			p.RuleDefinitiveOID()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(672)
			p.RuleDefinitiveOIDAndIRI()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)

	}

	return localctx
}

// IRuleDefinitiveOIDContext is an interface to support dynamic dispatch.
type IRuleDefinitiveOIDContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleDefinitiveOIDContext differentiates from other interfaces.
	IsRuleDefinitiveOIDContext()
}

type RuleDefinitiveOIDContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleDefinitiveOIDContext() *RuleDefinitiveOIDContext {
	var p = new(RuleDefinitiveOIDContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleDefinitiveOID
	return p
}

func (*RuleDefinitiveOIDContext) IsRuleDefinitiveOIDContext() {}

func NewRuleDefinitiveOIDContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleDefinitiveOIDContext {
	var p = new(RuleDefinitiveOIDContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleDefinitiveOID

	return p
}

func (s *RuleDefinitiveOIDContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleDefinitiveOIDContext) CURLY_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_START, 0)
}

func (s *RuleDefinitiveOIDContext) RuleDefinitiveObjIdComponentList() IRuleDefinitiveObjIdComponentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinitiveObjIdComponentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinitiveObjIdComponentListContext)
}

func (s *RuleDefinitiveOIDContext) CURLY_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_END, 0)
}

func (s *RuleDefinitiveOIDContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleDefinitiveOIDContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleDefinitiveOIDContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleDefinitiveOID(s)
	}
}

func (s *RuleDefinitiveOIDContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleDefinitiveOID(s)
	}
}

func (s *RuleDefinitiveOIDContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleDefinitiveOID(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleDefinitiveOID() (localctx IRuleDefinitiveOIDContext) {
	this := p
	_ = this

	localctx = NewRuleDefinitiveOIDContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, asn1ParserRULE_ruleDefinitiveOID)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(676)
		p.Match(asn1ParserCURLY_START)
	}
	{
		p.SetState(677)
		p.ruleDefinitiveObjIdComponentList(0)
	}
	{
		p.SetState(678)
		p.Match(asn1ParserCURLY_END)
	}

	return localctx
}

// IRuleDefinitiveObjIdComponentListContext is an interface to support dynamic dispatch.
type IRuleDefinitiveObjIdComponentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleDefinitiveObjIdComponentListContext differentiates from other interfaces.
	IsRuleDefinitiveObjIdComponentListContext()
}

type RuleDefinitiveObjIdComponentListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleDefinitiveObjIdComponentListContext() *RuleDefinitiveObjIdComponentListContext {
	var p = new(RuleDefinitiveObjIdComponentListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleDefinitiveObjIdComponentList
	return p
}

func (*RuleDefinitiveObjIdComponentListContext) IsRuleDefinitiveObjIdComponentListContext() {}

func NewRuleDefinitiveObjIdComponentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleDefinitiveObjIdComponentListContext {
	var p = new(RuleDefinitiveObjIdComponentListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleDefinitiveObjIdComponentList

	return p
}

func (s *RuleDefinitiveObjIdComponentListContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleDefinitiveObjIdComponentListContext) RuleDefinitiveObjIdComponent() IRuleDefinitiveObjIdComponentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinitiveObjIdComponentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinitiveObjIdComponentContext)
}

func (s *RuleDefinitiveObjIdComponentListContext) RuleDefinitiveObjIdComponentList() IRuleDefinitiveObjIdComponentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinitiveObjIdComponentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinitiveObjIdComponentListContext)
}

func (s *RuleDefinitiveObjIdComponentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleDefinitiveObjIdComponentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleDefinitiveObjIdComponentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleDefinitiveObjIdComponentList(s)
	}
}

func (s *RuleDefinitiveObjIdComponentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleDefinitiveObjIdComponentList(s)
	}
}

func (s *RuleDefinitiveObjIdComponentListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleDefinitiveObjIdComponentList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleDefinitiveObjIdComponentList() (localctx IRuleDefinitiveObjIdComponentListContext) {
	return p.ruleDefinitiveObjIdComponentList(0)
}

func (p *asn1Parser) ruleDefinitiveObjIdComponentList(_p int) (localctx IRuleDefinitiveObjIdComponentListContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRuleDefinitiveObjIdComponentListContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRuleDefinitiveObjIdComponentListContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 14
	p.EnterRecursionRule(localctx, 14, asn1ParserRULE_ruleDefinitiveObjIdComponentList, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(681)
		p.RuleDefinitiveObjIdComponent()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(687)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewRuleDefinitiveObjIdComponentListContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, asn1ParserRULE_ruleDefinitiveObjIdComponentList)
			p.SetState(683)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(684)
				p.RuleDefinitiveObjIdComponent()
			}

		}
		p.SetState(689)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext())
	}

	return localctx
}

// IRuleDefinitiveObjIdComponentContext is an interface to support dynamic dispatch.
type IRuleDefinitiveObjIdComponentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleDefinitiveObjIdComponentContext differentiates from other interfaces.
	IsRuleDefinitiveObjIdComponentContext()
}

type RuleDefinitiveObjIdComponentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleDefinitiveObjIdComponentContext() *RuleDefinitiveObjIdComponentContext {
	var p = new(RuleDefinitiveObjIdComponentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleDefinitiveObjIdComponent
	return p
}

func (*RuleDefinitiveObjIdComponentContext) IsRuleDefinitiveObjIdComponentContext() {}

func NewRuleDefinitiveObjIdComponentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleDefinitiveObjIdComponentContext {
	var p = new(RuleDefinitiveObjIdComponentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleDefinitiveObjIdComponent

	return p
}

func (s *RuleDefinitiveObjIdComponentContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleDefinitiveObjIdComponentContext) RuleNameForm() IRuleNameFormContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleNameFormContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleNameFormContext)
}

func (s *RuleDefinitiveObjIdComponentContext) RuleDefinitiveNumberForm() IRuleDefinitiveNumberFormContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinitiveNumberFormContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinitiveNumberFormContext)
}

func (s *RuleDefinitiveObjIdComponentContext) RuleDefinitiveNameAndNumberForm() IRuleDefinitiveNameAndNumberFormContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinitiveNameAndNumberFormContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinitiveNameAndNumberFormContext)
}

func (s *RuleDefinitiveObjIdComponentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleDefinitiveObjIdComponentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleDefinitiveObjIdComponentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleDefinitiveObjIdComponent(s)
	}
}

func (s *RuleDefinitiveObjIdComponentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleDefinitiveObjIdComponent(s)
	}
}

func (s *RuleDefinitiveObjIdComponentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleDefinitiveObjIdComponent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleDefinitiveObjIdComponent() (localctx IRuleDefinitiveObjIdComponentContext) {
	this := p
	_ = this

	localctx = NewRuleDefinitiveObjIdComponentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, asn1ParserRULE_ruleDefinitiveObjIdComponent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(693)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(690)
			p.RuleNameForm()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(691)
			p.RuleDefinitiveNumberForm()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(692)
			p.RuleDefinitiveNameAndNumberForm()
		}

	}

	return localctx
}

// IRuleNameFormContext is an interface to support dynamic dispatch.
type IRuleNameFormContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleNameFormContext differentiates from other interfaces.
	IsRuleNameFormContext()
}

type RuleNameFormContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleNameFormContext() *RuleNameFormContext {
	var p = new(RuleNameFormContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleNameForm
	return p
}

func (*RuleNameFormContext) IsRuleNameFormContext() {}

func NewRuleNameFormContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleNameFormContext {
	var p = new(RuleNameFormContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleNameForm

	return p
}

func (s *RuleNameFormContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleNameFormContext) LCASE_ID() antlr.TerminalNode {
	return s.GetToken(asn1ParserLCASE_ID, 0)
}

func (s *RuleNameFormContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleNameFormContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleNameFormContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleNameForm(s)
	}
}

func (s *RuleNameFormContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleNameForm(s)
	}
}

func (s *RuleNameFormContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleNameForm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleNameForm() (localctx IRuleNameFormContext) {
	this := p
	_ = this

	localctx = NewRuleNameFormContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, asn1ParserRULE_ruleNameForm)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(695)
		p.Match(asn1ParserLCASE_ID)
	}

	return localctx
}

// IRuleDefinitiveNumberFormContext is an interface to support dynamic dispatch.
type IRuleDefinitiveNumberFormContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleDefinitiveNumberFormContext differentiates from other interfaces.
	IsRuleDefinitiveNumberFormContext()
}

type RuleDefinitiveNumberFormContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleDefinitiveNumberFormContext() *RuleDefinitiveNumberFormContext {
	var p = new(RuleDefinitiveNumberFormContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleDefinitiveNumberForm
	return p
}

func (*RuleDefinitiveNumberFormContext) IsRuleDefinitiveNumberFormContext() {}

func NewRuleDefinitiveNumberFormContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleDefinitiveNumberFormContext {
	var p = new(RuleDefinitiveNumberFormContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleDefinitiveNumberForm

	return p
}

func (s *RuleDefinitiveNumberFormContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleDefinitiveNumberFormContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(asn1ParserNUMBER, 0)
}

func (s *RuleDefinitiveNumberFormContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleDefinitiveNumberFormContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleDefinitiveNumberFormContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleDefinitiveNumberForm(s)
	}
}

func (s *RuleDefinitiveNumberFormContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleDefinitiveNumberForm(s)
	}
}

func (s *RuleDefinitiveNumberFormContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleDefinitiveNumberForm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleDefinitiveNumberForm() (localctx IRuleDefinitiveNumberFormContext) {
	this := p
	_ = this

	localctx = NewRuleDefinitiveNumberFormContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, asn1ParserRULE_ruleDefinitiveNumberForm)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(697)
		p.Match(asn1ParserNUMBER)
	}

	return localctx
}

// IRuleDefinitiveNameAndNumberFormContext is an interface to support dynamic dispatch.
type IRuleDefinitiveNameAndNumberFormContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleDefinitiveNameAndNumberFormContext differentiates from other interfaces.
	IsRuleDefinitiveNameAndNumberFormContext()
}

type RuleDefinitiveNameAndNumberFormContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleDefinitiveNameAndNumberFormContext() *RuleDefinitiveNameAndNumberFormContext {
	var p = new(RuleDefinitiveNameAndNumberFormContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleDefinitiveNameAndNumberForm
	return p
}

func (*RuleDefinitiveNameAndNumberFormContext) IsRuleDefinitiveNameAndNumberFormContext() {}

func NewRuleDefinitiveNameAndNumberFormContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleDefinitiveNameAndNumberFormContext {
	var p = new(RuleDefinitiveNameAndNumberFormContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleDefinitiveNameAndNumberForm

	return p
}

func (s *RuleDefinitiveNameAndNumberFormContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleDefinitiveNameAndNumberFormContext) LCASE_ID() antlr.TerminalNode {
	return s.GetToken(asn1ParserLCASE_ID, 0)
}

func (s *RuleDefinitiveNameAndNumberFormContext) ROUND_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserROUND_START, 0)
}

func (s *RuleDefinitiveNameAndNumberFormContext) RuleDefinitiveNumberForm() IRuleDefinitiveNumberFormContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinitiveNumberFormContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinitiveNumberFormContext)
}

func (s *RuleDefinitiveNameAndNumberFormContext) ROUND_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserROUND_END, 0)
}

func (s *RuleDefinitiveNameAndNumberFormContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleDefinitiveNameAndNumberFormContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleDefinitiveNameAndNumberFormContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleDefinitiveNameAndNumberForm(s)
	}
}

func (s *RuleDefinitiveNameAndNumberFormContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleDefinitiveNameAndNumberForm(s)
	}
}

func (s *RuleDefinitiveNameAndNumberFormContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleDefinitiveNameAndNumberForm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleDefinitiveNameAndNumberForm() (localctx IRuleDefinitiveNameAndNumberFormContext) {
	this := p
	_ = this

	localctx = NewRuleDefinitiveNameAndNumberFormContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, asn1ParserRULE_ruleDefinitiveNameAndNumberForm)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(699)
		p.Match(asn1ParserLCASE_ID)
	}
	{
		p.SetState(700)
		p.Match(asn1ParserROUND_START)
	}
	{
		p.SetState(701)
		p.RuleDefinitiveNumberForm()
	}
	{
		p.SetState(702)
		p.Match(asn1ParserROUND_END)
	}

	return localctx
}

// IRuleDefinitiveOIDAndIRIContext is an interface to support dynamic dispatch.
type IRuleDefinitiveOIDAndIRIContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleDefinitiveOIDAndIRIContext differentiates from other interfaces.
	IsRuleDefinitiveOIDAndIRIContext()
}

type RuleDefinitiveOIDAndIRIContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleDefinitiveOIDAndIRIContext() *RuleDefinitiveOIDAndIRIContext {
	var p = new(RuleDefinitiveOIDAndIRIContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleDefinitiveOIDAndIRI
	return p
}

func (*RuleDefinitiveOIDAndIRIContext) IsRuleDefinitiveOIDAndIRIContext() {}

func NewRuleDefinitiveOIDAndIRIContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleDefinitiveOIDAndIRIContext {
	var p = new(RuleDefinitiveOIDAndIRIContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleDefinitiveOIDAndIRI

	return p
}

func (s *RuleDefinitiveOIDAndIRIContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleDefinitiveOIDAndIRIContext) RuleDefinitiveOID() IRuleDefinitiveOIDContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinitiveOIDContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinitiveOIDContext)
}

func (s *RuleDefinitiveOIDAndIRIContext) RuleIRIValue() IRuleIRIValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleIRIValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleIRIValueContext)
}

func (s *RuleDefinitiveOIDAndIRIContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleDefinitiveOIDAndIRIContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleDefinitiveOIDAndIRIContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleDefinitiveOIDAndIRI(s)
	}
}

func (s *RuleDefinitiveOIDAndIRIContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleDefinitiveOIDAndIRI(s)
	}
}

func (s *RuleDefinitiveOIDAndIRIContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleDefinitiveOIDAndIRI(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleDefinitiveOIDAndIRI() (localctx IRuleDefinitiveOIDAndIRIContext) {
	this := p
	_ = this

	localctx = NewRuleDefinitiveOIDAndIRIContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, asn1ParserRULE_ruleDefinitiveOIDAndIRI)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(704)
		p.RuleDefinitiveOID()
	}
	{
		p.SetState(705)
		p.RuleIRIValue()
	}

	return localctx
}

// IRuleFirstArcIdentifierContext is an interface to support dynamic dispatch.
type IRuleFirstArcIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleFirstArcIdentifierContext differentiates from other interfaces.
	IsRuleFirstArcIdentifierContext()
}

type RuleFirstArcIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleFirstArcIdentifierContext() *RuleFirstArcIdentifierContext {
	var p = new(RuleFirstArcIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleFirstArcIdentifier
	return p
}

func (*RuleFirstArcIdentifierContext) IsRuleFirstArcIdentifierContext() {}

func NewRuleFirstArcIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleFirstArcIdentifierContext {
	var p = new(RuleFirstArcIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleFirstArcIdentifier

	return p
}

func (s *RuleFirstArcIdentifierContext) GetParser() antlr.Parser { return s.parser }
func (s *RuleFirstArcIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleFirstArcIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleFirstArcIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleFirstArcIdentifier(s)
	}
}

func (s *RuleFirstArcIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleFirstArcIdentifier(s)
	}
}

func (s *RuleFirstArcIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleFirstArcIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleFirstArcIdentifier() (localctx IRuleFirstArcIdentifierContext) {
	this := p
	_ = this

	localctx = NewRuleFirstArcIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, asn1ParserRULE_ruleFirstArcIdentifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)

	return localctx
}

// IRuleSubsequentArcIdentifierContext is an interface to support dynamic dispatch.
type IRuleSubsequentArcIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleSubsequentArcIdentifierContext differentiates from other interfaces.
	IsRuleSubsequentArcIdentifierContext()
}

type RuleSubsequentArcIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleSubsequentArcIdentifierContext() *RuleSubsequentArcIdentifierContext {
	var p = new(RuleSubsequentArcIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleSubsequentArcIdentifier
	return p
}

func (*RuleSubsequentArcIdentifierContext) IsRuleSubsequentArcIdentifierContext() {}

func NewRuleSubsequentArcIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleSubsequentArcIdentifierContext {
	var p = new(RuleSubsequentArcIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleSubsequentArcIdentifier

	return p
}

func (s *RuleSubsequentArcIdentifierContext) GetParser() antlr.Parser { return s.parser }
func (s *RuleSubsequentArcIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleSubsequentArcIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleSubsequentArcIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleSubsequentArcIdentifier(s)
	}
}

func (s *RuleSubsequentArcIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleSubsequentArcIdentifier(s)
	}
}

func (s *RuleSubsequentArcIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleSubsequentArcIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleSubsequentArcIdentifier() (localctx IRuleSubsequentArcIdentifierContext) {
	this := p
	_ = this

	localctx = NewRuleSubsequentArcIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, asn1ParserRULE_ruleSubsequentArcIdentifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)

	return localctx
}

// IRuleIRIValueContext is an interface to support dynamic dispatch.
type IRuleIRIValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleIRIValueContext differentiates from other interfaces.
	IsRuleIRIValueContext()
}

type RuleIRIValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleIRIValueContext() *RuleIRIValueContext {
	var p = new(RuleIRIValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleIRIValue
	return p
}

func (*RuleIRIValueContext) IsRuleIRIValueContext() {}

func NewRuleIRIValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleIRIValueContext {
	var p = new(RuleIRIValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleIRIValue

	return p
}

func (s *RuleIRIValueContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleIRIValueContext) CHAR_STRING() antlr.TerminalNode {
	return s.GetToken(asn1ParserCHAR_STRING, 0)
}

func (s *RuleIRIValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleIRIValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleIRIValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleIRIValue(s)
	}
}

func (s *RuleIRIValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleIRIValue(s)
	}
}

func (s *RuleIRIValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleIRIValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleIRIValue() (localctx IRuleIRIValueContext) {
	this := p
	_ = this

	localctx = NewRuleIRIValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, asn1ParserRULE_ruleIRIValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(711)
		p.Match(asn1ParserCHAR_STRING)
	}

	return localctx
}

// IRuleEncodingReferenceDefaultContext is an interface to support dynamic dispatch.
type IRuleEncodingReferenceDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleEncodingReferenceDefaultContext differentiates from other interfaces.
	IsRuleEncodingReferenceDefaultContext()
}

type RuleEncodingReferenceDefaultContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleEncodingReferenceDefaultContext() *RuleEncodingReferenceDefaultContext {
	var p = new(RuleEncodingReferenceDefaultContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleEncodingReferenceDefault
	return p
}

func (*RuleEncodingReferenceDefaultContext) IsRuleEncodingReferenceDefaultContext() {}

func NewRuleEncodingReferenceDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleEncodingReferenceDefaultContext {
	var p = new(RuleEncodingReferenceDefaultContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleEncodingReferenceDefault

	return p
}

func (s *RuleEncodingReferenceDefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleEncodingReferenceDefaultContext) UCASE_ID() antlr.TerminalNode {
	return s.GetToken(asn1ParserUCASE_ID, 0)
}

func (s *RuleEncodingReferenceDefaultContext) INSTRUCTIONS_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserINSTRUCTIONS_SYM, 0)
}

func (s *RuleEncodingReferenceDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleEncodingReferenceDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleEncodingReferenceDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleEncodingReferenceDefault(s)
	}
}

func (s *RuleEncodingReferenceDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleEncodingReferenceDefault(s)
	}
}

func (s *RuleEncodingReferenceDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleEncodingReferenceDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleEncodingReferenceDefault() (localctx IRuleEncodingReferenceDefaultContext) {
	this := p
	_ = this

	localctx = NewRuleEncodingReferenceDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, asn1ParserRULE_ruleEncodingReferenceDefault)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(716)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case asn1ParserUCASE_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(713)
			p.Match(asn1ParserUCASE_ID)
		}
		{
			p.SetState(714)
			p.Match(asn1ParserINSTRUCTIONS_SYM)
		}

	case asn1ParserAUTOMATIC_SYM, asn1ParserEXPLICIT_SYM, asn1ParserEXTENSIBILITY_SYM, asn1ParserIMPLICIT_SYM, asn1ParserASSIGNMENT:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRuleTagDefaultContext is an interface to support dynamic dispatch.
type IRuleTagDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleTagDefaultContext differentiates from other interfaces.
	IsRuleTagDefaultContext()
}

type RuleTagDefaultContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleTagDefaultContext() *RuleTagDefaultContext {
	var p = new(RuleTagDefaultContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleTagDefault
	return p
}

func (*RuleTagDefaultContext) IsRuleTagDefaultContext() {}

func NewRuleTagDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleTagDefaultContext {
	var p = new(RuleTagDefaultContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleTagDefault

	return p
}

func (s *RuleTagDefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleTagDefaultContext) EXPLICIT_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserEXPLICIT_SYM, 0)
}

func (s *RuleTagDefaultContext) TAGS_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserTAGS_SYM, 0)
}

func (s *RuleTagDefaultContext) IMPLICIT_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserIMPLICIT_SYM, 0)
}

func (s *RuleTagDefaultContext) AUTOMATIC_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserAUTOMATIC_SYM, 0)
}

func (s *RuleTagDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleTagDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleTagDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleTagDefault(s)
	}
}

func (s *RuleTagDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleTagDefault(s)
	}
}

func (s *RuleTagDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleTagDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleTagDefault() (localctx IRuleTagDefaultContext) {
	this := p
	_ = this

	localctx = NewRuleTagDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, asn1ParserRULE_ruleTagDefault)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(725)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case asn1ParserEXPLICIT_SYM:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(718)
			p.Match(asn1ParserEXPLICIT_SYM)
		}
		{
			p.SetState(719)
			p.Match(asn1ParserTAGS_SYM)
		}

	case asn1ParserIMPLICIT_SYM:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(720)
			p.Match(asn1ParserIMPLICIT_SYM)
		}
		{
			p.SetState(721)
			p.Match(asn1ParserTAGS_SYM)
		}

	case asn1ParserAUTOMATIC_SYM:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(722)
			p.Match(asn1ParserAUTOMATIC_SYM)
		}
		{
			p.SetState(723)
			p.Match(asn1ParserTAGS_SYM)
		}

	case asn1ParserEXTENSIBILITY_SYM, asn1ParserASSIGNMENT:
		p.EnterOuterAlt(localctx, 4)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRuleExtensionDefaultContext is an interface to support dynamic dispatch.
type IRuleExtensionDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleExtensionDefaultContext differentiates from other interfaces.
	IsRuleExtensionDefaultContext()
}

type RuleExtensionDefaultContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleExtensionDefaultContext() *RuleExtensionDefaultContext {
	var p = new(RuleExtensionDefaultContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleExtensionDefault
	return p
}

func (*RuleExtensionDefaultContext) IsRuleExtensionDefaultContext() {}

func NewRuleExtensionDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleExtensionDefaultContext {
	var p = new(RuleExtensionDefaultContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleExtensionDefault

	return p
}

func (s *RuleExtensionDefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleExtensionDefaultContext) EXTENSIBILITY_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserEXTENSIBILITY_SYM, 0)
}

func (s *RuleExtensionDefaultContext) IMPLIED_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserIMPLIED_SYM, 0)
}

func (s *RuleExtensionDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleExtensionDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleExtensionDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleExtensionDefault(s)
	}
}

func (s *RuleExtensionDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleExtensionDefault(s)
	}
}

func (s *RuleExtensionDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleExtensionDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleExtensionDefault() (localctx IRuleExtensionDefaultContext) {
	this := p
	_ = this

	localctx = NewRuleExtensionDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, asn1ParserRULE_ruleExtensionDefault)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(730)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case asn1ParserEXTENSIBILITY_SYM:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(727)
			p.Match(asn1ParserEXTENSIBILITY_SYM)
		}
		{
			p.SetState(728)
			p.Match(asn1ParserIMPLIED_SYM)
		}

	case asn1ParserASSIGNMENT:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRuleModuleBodyContext is an interface to support dynamic dispatch.
type IRuleModuleBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleModuleBodyContext differentiates from other interfaces.
	IsRuleModuleBodyContext()
}

type RuleModuleBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleModuleBodyContext() *RuleModuleBodyContext {
	var p = new(RuleModuleBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleModuleBody
	return p
}

func (*RuleModuleBodyContext) IsRuleModuleBodyContext() {}

func NewRuleModuleBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleModuleBodyContext {
	var p = new(RuleModuleBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleModuleBody

	return p
}

func (s *RuleModuleBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleModuleBodyContext) RuleExports() IRuleExportsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleExportsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleExportsContext)
}

func (s *RuleModuleBodyContext) RuleImports() IRuleImportsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleImportsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleImportsContext)
}

func (s *RuleModuleBodyContext) RuleAssignmentList() IRuleAssignmentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleAssignmentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleAssignmentListContext)
}

func (s *RuleModuleBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleModuleBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleModuleBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleModuleBody(s)
	}
}

func (s *RuleModuleBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleModuleBody(s)
	}
}

func (s *RuleModuleBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleModuleBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleModuleBody() (localctx IRuleModuleBodyContext) {
	this := p
	_ = this

	localctx = NewRuleModuleBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, asn1ParserRULE_ruleModuleBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(737)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(732)
			p.RuleExports()
		}
		{
			p.SetState(733)
			p.RuleImports()
		}
		{
			p.SetState(734)
			p.ruleAssignmentList(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)

	}

	return localctx
}

// IRuleExportsContext is an interface to support dynamic dispatch.
type IRuleExportsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleExportsContext differentiates from other interfaces.
	IsRuleExportsContext()
}

type RuleExportsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleExportsContext() *RuleExportsContext {
	var p = new(RuleExportsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleExports
	return p
}

func (*RuleExportsContext) IsRuleExportsContext() {}

func NewRuleExportsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleExportsContext {
	var p = new(RuleExportsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleExports

	return p
}

func (s *RuleExportsContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleExportsContext) EXPORTS_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserEXPORTS_SYM, 0)
}

func (s *RuleExportsContext) RuleSymbolsExported() IRuleSymbolsExportedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSymbolsExportedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSymbolsExportedContext)
}

func (s *RuleExportsContext) SEMI_COMMA() antlr.TerminalNode {
	return s.GetToken(asn1ParserSEMI_COMMA, 0)
}

func (s *RuleExportsContext) ALL_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserALL_SYM, 0)
}

func (s *RuleExportsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleExportsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleExportsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleExports(s)
	}
}

func (s *RuleExportsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleExports(s)
	}
}

func (s *RuleExportsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleExports(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleExports() (localctx IRuleExportsContext) {
	this := p
	_ = this

	localctx = NewRuleExportsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, asn1ParserRULE_ruleExports)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(747)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(739)
			p.Match(asn1ParserEXPORTS_SYM)
		}
		{
			p.SetState(740)
			p.RuleSymbolsExported()
		}
		{
			p.SetState(741)
			p.Match(asn1ParserSEMI_COMMA)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(743)
			p.Match(asn1ParserEXPORTS_SYM)
		}
		{
			p.SetState(744)
			p.Match(asn1ParserALL_SYM)
		}
		{
			p.SetState(745)
			p.Match(asn1ParserSEMI_COMMA)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)

	}

	return localctx
}

// IRuleSymbolsExportedContext is an interface to support dynamic dispatch.
type IRuleSymbolsExportedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleSymbolsExportedContext differentiates from other interfaces.
	IsRuleSymbolsExportedContext()
}

type RuleSymbolsExportedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleSymbolsExportedContext() *RuleSymbolsExportedContext {
	var p = new(RuleSymbolsExportedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleSymbolsExported
	return p
}

func (*RuleSymbolsExportedContext) IsRuleSymbolsExportedContext() {}

func NewRuleSymbolsExportedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleSymbolsExportedContext {
	var p = new(RuleSymbolsExportedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleSymbolsExported

	return p
}

func (s *RuleSymbolsExportedContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleSymbolsExportedContext) RuleSymbolList() IRuleSymbolListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSymbolListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSymbolListContext)
}

func (s *RuleSymbolsExportedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleSymbolsExportedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleSymbolsExportedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleSymbolsExported(s)
	}
}

func (s *RuleSymbolsExportedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleSymbolsExported(s)
	}
}

func (s *RuleSymbolsExportedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleSymbolsExported(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleSymbolsExported() (localctx IRuleSymbolsExportedContext) {
	this := p
	_ = this

	localctx = NewRuleSymbolsExportedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, asn1ParserRULE_ruleSymbolsExported)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(751)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case asn1ParserUCASE_ID, asn1ParserLCASE_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(749)
			p.ruleSymbolList(0)
		}

	case asn1ParserSEMI_COMMA:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRuleSymbolListContext is an interface to support dynamic dispatch.
type IRuleSymbolListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleSymbolListContext differentiates from other interfaces.
	IsRuleSymbolListContext()
}

type RuleSymbolListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleSymbolListContext() *RuleSymbolListContext {
	var p = new(RuleSymbolListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleSymbolList
	return p
}

func (*RuleSymbolListContext) IsRuleSymbolListContext() {}

func NewRuleSymbolListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleSymbolListContext {
	var p = new(RuleSymbolListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleSymbolList

	return p
}

func (s *RuleSymbolListContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleSymbolListContext) RuleSymbol() IRuleSymbolContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSymbolContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSymbolContext)
}

func (s *RuleSymbolListContext) RuleSymbolList() IRuleSymbolListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSymbolListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSymbolListContext)
}

func (s *RuleSymbolListContext) COMMA() antlr.TerminalNode {
	return s.GetToken(asn1ParserCOMMA, 0)
}

func (s *RuleSymbolListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleSymbolListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleSymbolListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleSymbolList(s)
	}
}

func (s *RuleSymbolListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleSymbolList(s)
	}
}

func (s *RuleSymbolListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleSymbolList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleSymbolList() (localctx IRuleSymbolListContext) {
	return p.ruleSymbolList(0)
}

func (p *asn1Parser) ruleSymbolList(_p int) (localctx IRuleSymbolListContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRuleSymbolListContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRuleSymbolListContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 44
	p.EnterRecursionRule(localctx, 44, asn1ParserRULE_ruleSymbolList, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(754)
		p.RuleSymbol()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(761)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 10, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewRuleSymbolListContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, asn1ParserRULE_ruleSymbolList)
			p.SetState(756)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(757)
				p.Match(asn1ParserCOMMA)
			}
			{
				p.SetState(758)
				p.RuleSymbol()
			}

		}
		p.SetState(763)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 10, p.GetParserRuleContext())
	}

	return localctx
}

// IRuleSymbolContext is an interface to support dynamic dispatch.
type IRuleSymbolContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleSymbolContext differentiates from other interfaces.
	IsRuleSymbolContext()
}

type RuleSymbolContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleSymbolContext() *RuleSymbolContext {
	var p = new(RuleSymbolContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleSymbol
	return p
}

func (*RuleSymbolContext) IsRuleSymbolContext() {}

func NewRuleSymbolContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleSymbolContext {
	var p = new(RuleSymbolContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleSymbol

	return p
}

func (s *RuleSymbolContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleSymbolContext) RuleReference() IRuleReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleReferenceContext)
}

func (s *RuleSymbolContext) RuleParameterizedReference() IRuleParameterizedReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleParameterizedReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleParameterizedReferenceContext)
}

func (s *RuleSymbolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleSymbolContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleSymbolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleSymbol(s)
	}
}

func (s *RuleSymbolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleSymbol(s)
	}
}

func (s *RuleSymbolContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleSymbol(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleSymbol() (localctx IRuleSymbolContext) {
	this := p
	_ = this

	localctx = NewRuleSymbolContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, asn1ParserRULE_ruleSymbol)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(766)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 11, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(764)
			p.RuleReference()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(765)
			p.RuleParameterizedReference()
		}

	}

	return localctx
}

// IRuleReferenceContext is an interface to support dynamic dispatch.
type IRuleReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleReferenceContext differentiates from other interfaces.
	IsRuleReferenceContext()
}

type RuleReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleReferenceContext() *RuleReferenceContext {
	var p = new(RuleReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleReference
	return p
}

func (*RuleReferenceContext) IsRuleReferenceContext() {}

func NewRuleReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleReferenceContext {
	var p = new(RuleReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleReference

	return p
}

func (s *RuleReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleReferenceContext) RuleTypeReference() IRuleTypeReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeReferenceContext)
}

func (s *RuleReferenceContext) RuleValueReference() IRuleValueReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueReferenceContext)
}

func (s *RuleReferenceContext) RuleObjectClassReference() IRuleObjectClassReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectClassReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectClassReferenceContext)
}

func (s *RuleReferenceContext) RuleObjectReference() IRuleObjectReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectReferenceContext)
}

func (s *RuleReferenceContext) RuleObjectSetReference() IRuleObjectSetReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectSetReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectSetReferenceContext)
}

func (s *RuleReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleReference(s)
	}
}

func (s *RuleReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleReference(s)
	}
}

func (s *RuleReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleReference() (localctx IRuleReferenceContext) {
	this := p
	_ = this

	localctx = NewRuleReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, asn1ParserRULE_ruleReference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(773)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(768)
			p.RuleTypeReference()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(769)
			p.RuleValueReference()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(770)
			p.RuleObjectClassReference()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(771)
			p.RuleObjectReference()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(772)
			p.RuleObjectSetReference()
		}

	}

	return localctx
}

// IRuleIdentifierContext is an interface to support dynamic dispatch.
type IRuleIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleIdentifierContext differentiates from other interfaces.
	IsRuleIdentifierContext()
}

type RuleIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleIdentifierContext() *RuleIdentifierContext {
	var p = new(RuleIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleIdentifier
	return p
}

func (*RuleIdentifierContext) IsRuleIdentifierContext() {}

func NewRuleIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleIdentifierContext {
	var p = new(RuleIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleIdentifier

	return p
}

func (s *RuleIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleIdentifierContext) LCASE_ID() antlr.TerminalNode {
	return s.GetToken(asn1ParserLCASE_ID, 0)
}

func (s *RuleIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleIdentifier(s)
	}
}

func (s *RuleIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleIdentifier(s)
	}
}

func (s *RuleIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleIdentifier() (localctx IRuleIdentifierContext) {
	this := p
	_ = this

	localctx = NewRuleIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, asn1ParserRULE_ruleIdentifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(775)
		p.Match(asn1ParserLCASE_ID)
	}

	return localctx
}

// IRuleTypeReferenceContext is an interface to support dynamic dispatch.
type IRuleTypeReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleTypeReferenceContext differentiates from other interfaces.
	IsRuleTypeReferenceContext()
}

type RuleTypeReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleTypeReferenceContext() *RuleTypeReferenceContext {
	var p = new(RuleTypeReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleTypeReference
	return p
}

func (*RuleTypeReferenceContext) IsRuleTypeReferenceContext() {}

func NewRuleTypeReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleTypeReferenceContext {
	var p = new(RuleTypeReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleTypeReference

	return p
}

func (s *RuleTypeReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleTypeReferenceContext) UCASE_ID() antlr.TerminalNode {
	return s.GetToken(asn1ParserUCASE_ID, 0)
}

func (s *RuleTypeReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleTypeReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleTypeReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleTypeReference(s)
	}
}

func (s *RuleTypeReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleTypeReference(s)
	}
}

func (s *RuleTypeReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleTypeReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleTypeReference() (localctx IRuleTypeReferenceContext) {
	this := p
	_ = this

	localctx = NewRuleTypeReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, asn1ParserRULE_ruleTypeReference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(777)
		p.Match(asn1ParserUCASE_ID)
	}

	return localctx
}

// IRuleValueReferenceContext is an interface to support dynamic dispatch.
type IRuleValueReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleValueReferenceContext differentiates from other interfaces.
	IsRuleValueReferenceContext()
}

type RuleValueReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleValueReferenceContext() *RuleValueReferenceContext {
	var p = new(RuleValueReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleValueReference
	return p
}

func (*RuleValueReferenceContext) IsRuleValueReferenceContext() {}

func NewRuleValueReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleValueReferenceContext {
	var p = new(RuleValueReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleValueReference

	return p
}

func (s *RuleValueReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleValueReferenceContext) LCASE_ID() antlr.TerminalNode {
	return s.GetToken(asn1ParserLCASE_ID, 0)
}

func (s *RuleValueReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleValueReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleValueReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleValueReference(s)
	}
}

func (s *RuleValueReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleValueReference(s)
	}
}

func (s *RuleValueReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleValueReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleValueReference() (localctx IRuleValueReferenceContext) {
	this := p
	_ = this

	localctx = NewRuleValueReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, asn1ParserRULE_ruleValueReference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(779)
		p.Match(asn1ParserLCASE_ID)
	}

	return localctx
}

// IRuleObjectReferenceContext is an interface to support dynamic dispatch.
type IRuleObjectReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleObjectReferenceContext differentiates from other interfaces.
	IsRuleObjectReferenceContext()
}

type RuleObjectReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleObjectReferenceContext() *RuleObjectReferenceContext {
	var p = new(RuleObjectReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleObjectReference
	return p
}

func (*RuleObjectReferenceContext) IsRuleObjectReferenceContext() {}

func NewRuleObjectReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleObjectReferenceContext {
	var p = new(RuleObjectReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleObjectReference

	return p
}

func (s *RuleObjectReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleObjectReferenceContext) LCASE_ID() antlr.TerminalNode {
	return s.GetToken(asn1ParserLCASE_ID, 0)
}

func (s *RuleObjectReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleObjectReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleObjectReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleObjectReference(s)
	}
}

func (s *RuleObjectReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleObjectReference(s)
	}
}

func (s *RuleObjectReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleObjectReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleObjectReference() (localctx IRuleObjectReferenceContext) {
	this := p
	_ = this

	localctx = NewRuleObjectReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, asn1ParserRULE_ruleObjectReference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(781)
		p.Match(asn1ParserLCASE_ID)
	}

	return localctx
}

// IRuleObjectClassReferenceContext is an interface to support dynamic dispatch.
type IRuleObjectClassReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleObjectClassReferenceContext differentiates from other interfaces.
	IsRuleObjectClassReferenceContext()
}

type RuleObjectClassReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleObjectClassReferenceContext() *RuleObjectClassReferenceContext {
	var p = new(RuleObjectClassReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleObjectClassReference
	return p
}

func (*RuleObjectClassReferenceContext) IsRuleObjectClassReferenceContext() {}

func NewRuleObjectClassReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleObjectClassReferenceContext {
	var p = new(RuleObjectClassReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleObjectClassReference

	return p
}

func (s *RuleObjectClassReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleObjectClassReferenceContext) UCASE_ID() antlr.TerminalNode {
	return s.GetToken(asn1ParserUCASE_ID, 0)
}

func (s *RuleObjectClassReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleObjectClassReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleObjectClassReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleObjectClassReference(s)
	}
}

func (s *RuleObjectClassReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleObjectClassReference(s)
	}
}

func (s *RuleObjectClassReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleObjectClassReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleObjectClassReference() (localctx IRuleObjectClassReferenceContext) {
	this := p
	_ = this

	localctx = NewRuleObjectClassReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, asn1ParserRULE_ruleObjectClassReference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(783)
		p.Match(asn1ParserUCASE_ID)
	}

	return localctx
}

// IRuleObjectSetReferenceContext is an interface to support dynamic dispatch.
type IRuleObjectSetReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleObjectSetReferenceContext differentiates from other interfaces.
	IsRuleObjectSetReferenceContext()
}

type RuleObjectSetReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleObjectSetReferenceContext() *RuleObjectSetReferenceContext {
	var p = new(RuleObjectSetReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleObjectSetReference
	return p
}

func (*RuleObjectSetReferenceContext) IsRuleObjectSetReferenceContext() {}

func NewRuleObjectSetReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleObjectSetReferenceContext {
	var p = new(RuleObjectSetReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleObjectSetReference

	return p
}

func (s *RuleObjectSetReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleObjectSetReferenceContext) UCASE_ID() antlr.TerminalNode {
	return s.GetToken(asn1ParserUCASE_ID, 0)
}

func (s *RuleObjectSetReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleObjectSetReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleObjectSetReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleObjectSetReference(s)
	}
}

func (s *RuleObjectSetReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleObjectSetReference(s)
	}
}

func (s *RuleObjectSetReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleObjectSetReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleObjectSetReference() (localctx IRuleObjectSetReferenceContext) {
	this := p
	_ = this

	localctx = NewRuleObjectSetReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, asn1ParserRULE_ruleObjectSetReference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(785)
		p.Match(asn1ParserUCASE_ID)
	}

	return localctx
}

// IRuleParameterizedReferenceContext is an interface to support dynamic dispatch.
type IRuleParameterizedReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleParameterizedReferenceContext differentiates from other interfaces.
	IsRuleParameterizedReferenceContext()
}

type RuleParameterizedReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleParameterizedReferenceContext() *RuleParameterizedReferenceContext {
	var p = new(RuleParameterizedReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleParameterizedReference
	return p
}

func (*RuleParameterizedReferenceContext) IsRuleParameterizedReferenceContext() {}

func NewRuleParameterizedReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleParameterizedReferenceContext {
	var p = new(RuleParameterizedReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleParameterizedReference

	return p
}

func (s *RuleParameterizedReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleParameterizedReferenceContext) RuleReference() IRuleReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleReferenceContext)
}

func (s *RuleParameterizedReferenceContext) CURLY_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_START, 0)
}

func (s *RuleParameterizedReferenceContext) CURLY_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_END, 0)
}

func (s *RuleParameterizedReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleParameterizedReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleParameterizedReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleParameterizedReference(s)
	}
}

func (s *RuleParameterizedReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleParameterizedReference(s)
	}
}

func (s *RuleParameterizedReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleParameterizedReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleParameterizedReference() (localctx IRuleParameterizedReferenceContext) {
	this := p
	_ = this

	localctx = NewRuleParameterizedReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, asn1ParserRULE_ruleParameterizedReference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(792)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 13, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(787)
			p.RuleReference()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(788)
			p.RuleReference()
		}
		{
			p.SetState(789)
			p.Match(asn1ParserCURLY_START)
		}
		{
			p.SetState(790)
			p.Match(asn1ParserCURLY_END)
		}

	}

	return localctx
}

// IRuleExternalTypeReferenceContext is an interface to support dynamic dispatch.
type IRuleExternalTypeReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleExternalTypeReferenceContext differentiates from other interfaces.
	IsRuleExternalTypeReferenceContext()
}

type RuleExternalTypeReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleExternalTypeReferenceContext() *RuleExternalTypeReferenceContext {
	var p = new(RuleExternalTypeReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleExternalTypeReference
	return p
}

func (*RuleExternalTypeReferenceContext) IsRuleExternalTypeReferenceContext() {}

func NewRuleExternalTypeReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleExternalTypeReferenceContext {
	var p = new(RuleExternalTypeReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleExternalTypeReference

	return p
}

func (s *RuleExternalTypeReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleExternalTypeReferenceContext) RuleModuleReference() IRuleModuleReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleModuleReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleModuleReferenceContext)
}

func (s *RuleExternalTypeReferenceContext) DOT() antlr.TerminalNode {
	return s.GetToken(asn1ParserDOT, 0)
}

func (s *RuleExternalTypeReferenceContext) RuleTypeReference() IRuleTypeReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeReferenceContext)
}

func (s *RuleExternalTypeReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleExternalTypeReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleExternalTypeReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleExternalTypeReference(s)
	}
}

func (s *RuleExternalTypeReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleExternalTypeReference(s)
	}
}

func (s *RuleExternalTypeReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleExternalTypeReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleExternalTypeReference() (localctx IRuleExternalTypeReferenceContext) {
	this := p
	_ = this

	localctx = NewRuleExternalTypeReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, asn1ParserRULE_ruleExternalTypeReference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(794)
		p.RuleModuleReference()
	}
	{
		p.SetState(795)
		p.Match(asn1ParserDOT)
	}
	{
		p.SetState(796)
		p.RuleTypeReference()
	}

	return localctx
}

// IRuleExternalValueReferenceContext is an interface to support dynamic dispatch.
type IRuleExternalValueReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleExternalValueReferenceContext differentiates from other interfaces.
	IsRuleExternalValueReferenceContext()
}

type RuleExternalValueReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleExternalValueReferenceContext() *RuleExternalValueReferenceContext {
	var p = new(RuleExternalValueReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleExternalValueReference
	return p
}

func (*RuleExternalValueReferenceContext) IsRuleExternalValueReferenceContext() {}

func NewRuleExternalValueReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleExternalValueReferenceContext {
	var p = new(RuleExternalValueReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleExternalValueReference

	return p
}

func (s *RuleExternalValueReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleExternalValueReferenceContext) RuleModuleReference() IRuleModuleReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleModuleReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleModuleReferenceContext)
}

func (s *RuleExternalValueReferenceContext) DOT() antlr.TerminalNode {
	return s.GetToken(asn1ParserDOT, 0)
}

func (s *RuleExternalValueReferenceContext) RuleValueReference() IRuleValueReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueReferenceContext)
}

func (s *RuleExternalValueReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleExternalValueReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleExternalValueReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleExternalValueReference(s)
	}
}

func (s *RuleExternalValueReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleExternalValueReference(s)
	}
}

func (s *RuleExternalValueReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleExternalValueReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleExternalValueReference() (localctx IRuleExternalValueReferenceContext) {
	this := p
	_ = this

	localctx = NewRuleExternalValueReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, asn1ParserRULE_ruleExternalValueReference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(798)
		p.RuleModuleReference()
	}
	{
		p.SetState(799)
		p.Match(asn1ParserDOT)
	}
	{
		p.SetState(800)
		p.RuleValueReference()
	}

	return localctx
}

// IRuleExternalObjectClassReferenceContext is an interface to support dynamic dispatch.
type IRuleExternalObjectClassReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleExternalObjectClassReferenceContext differentiates from other interfaces.
	IsRuleExternalObjectClassReferenceContext()
}

type RuleExternalObjectClassReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleExternalObjectClassReferenceContext() *RuleExternalObjectClassReferenceContext {
	var p = new(RuleExternalObjectClassReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleExternalObjectClassReference
	return p
}

func (*RuleExternalObjectClassReferenceContext) IsRuleExternalObjectClassReferenceContext() {}

func NewRuleExternalObjectClassReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleExternalObjectClassReferenceContext {
	var p = new(RuleExternalObjectClassReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleExternalObjectClassReference

	return p
}

func (s *RuleExternalObjectClassReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleExternalObjectClassReferenceContext) RuleModuleReference() IRuleModuleReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleModuleReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleModuleReferenceContext)
}

func (s *RuleExternalObjectClassReferenceContext) DOT() antlr.TerminalNode {
	return s.GetToken(asn1ParserDOT, 0)
}

func (s *RuleExternalObjectClassReferenceContext) RuleObjectClassReference() IRuleObjectClassReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectClassReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectClassReferenceContext)
}

func (s *RuleExternalObjectClassReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleExternalObjectClassReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleExternalObjectClassReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleExternalObjectClassReference(s)
	}
}

func (s *RuleExternalObjectClassReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleExternalObjectClassReference(s)
	}
}

func (s *RuleExternalObjectClassReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleExternalObjectClassReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleExternalObjectClassReference() (localctx IRuleExternalObjectClassReferenceContext) {
	this := p
	_ = this

	localctx = NewRuleExternalObjectClassReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, asn1ParserRULE_ruleExternalObjectClassReference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(802)
		p.RuleModuleReference()
	}
	{
		p.SetState(803)
		p.Match(asn1ParserDOT)
	}
	{
		p.SetState(804)
		p.RuleObjectClassReference()
	}

	return localctx
}

// IRuleExternalObjectReferenceContext is an interface to support dynamic dispatch.
type IRuleExternalObjectReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleExternalObjectReferenceContext differentiates from other interfaces.
	IsRuleExternalObjectReferenceContext()
}

type RuleExternalObjectReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleExternalObjectReferenceContext() *RuleExternalObjectReferenceContext {
	var p = new(RuleExternalObjectReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleExternalObjectReference
	return p
}

func (*RuleExternalObjectReferenceContext) IsRuleExternalObjectReferenceContext() {}

func NewRuleExternalObjectReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleExternalObjectReferenceContext {
	var p = new(RuleExternalObjectReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleExternalObjectReference

	return p
}

func (s *RuleExternalObjectReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleExternalObjectReferenceContext) RuleModuleReference() IRuleModuleReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleModuleReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleModuleReferenceContext)
}

func (s *RuleExternalObjectReferenceContext) DOT() antlr.TerminalNode {
	return s.GetToken(asn1ParserDOT, 0)
}

func (s *RuleExternalObjectReferenceContext) RuleObjectReference() IRuleObjectReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectReferenceContext)
}

func (s *RuleExternalObjectReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleExternalObjectReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleExternalObjectReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleExternalObjectReference(s)
	}
}

func (s *RuleExternalObjectReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleExternalObjectReference(s)
	}
}

func (s *RuleExternalObjectReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleExternalObjectReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleExternalObjectReference() (localctx IRuleExternalObjectReferenceContext) {
	this := p
	_ = this

	localctx = NewRuleExternalObjectReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, asn1ParserRULE_ruleExternalObjectReference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(806)
		p.RuleModuleReference()
	}
	{
		p.SetState(807)
		p.Match(asn1ParserDOT)
	}
	{
		p.SetState(808)
		p.RuleObjectReference()
	}

	return localctx
}

// IRuleExternalObjectSetReferenceContext is an interface to support dynamic dispatch.
type IRuleExternalObjectSetReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleExternalObjectSetReferenceContext differentiates from other interfaces.
	IsRuleExternalObjectSetReferenceContext()
}

type RuleExternalObjectSetReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleExternalObjectSetReferenceContext() *RuleExternalObjectSetReferenceContext {
	var p = new(RuleExternalObjectSetReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleExternalObjectSetReference
	return p
}

func (*RuleExternalObjectSetReferenceContext) IsRuleExternalObjectSetReferenceContext() {}

func NewRuleExternalObjectSetReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleExternalObjectSetReferenceContext {
	var p = new(RuleExternalObjectSetReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleExternalObjectSetReference

	return p
}

func (s *RuleExternalObjectSetReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleExternalObjectSetReferenceContext) RuleModuleReference() IRuleModuleReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleModuleReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleModuleReferenceContext)
}

func (s *RuleExternalObjectSetReferenceContext) DOT() antlr.TerminalNode {
	return s.GetToken(asn1ParserDOT, 0)
}

func (s *RuleExternalObjectSetReferenceContext) RuleObjectSetReference() IRuleObjectSetReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectSetReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectSetReferenceContext)
}

func (s *RuleExternalObjectSetReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleExternalObjectSetReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleExternalObjectSetReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleExternalObjectSetReference(s)
	}
}

func (s *RuleExternalObjectSetReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleExternalObjectSetReference(s)
	}
}

func (s *RuleExternalObjectSetReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleExternalObjectSetReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleExternalObjectSetReference() (localctx IRuleExternalObjectSetReferenceContext) {
	this := p
	_ = this

	localctx = NewRuleExternalObjectSetReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, asn1ParserRULE_ruleExternalObjectSetReference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(810)
		p.RuleModuleReference()
	}
	{
		p.SetState(811)
		p.Match(asn1ParserDOT)
	}
	{
		p.SetState(812)
		p.RuleObjectSetReference()
	}

	return localctx
}

// IRuleTypeFieldReferenceContext is an interface to support dynamic dispatch.
type IRuleTypeFieldReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleTypeFieldReferenceContext differentiates from other interfaces.
	IsRuleTypeFieldReferenceContext()
}

type RuleTypeFieldReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleTypeFieldReferenceContext() *RuleTypeFieldReferenceContext {
	var p = new(RuleTypeFieldReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleTypeFieldReference
	return p
}

func (*RuleTypeFieldReferenceContext) IsRuleTypeFieldReferenceContext() {}

func NewRuleTypeFieldReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleTypeFieldReferenceContext {
	var p = new(RuleTypeFieldReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleTypeFieldReference

	return p
}

func (s *RuleTypeFieldReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleTypeFieldReferenceContext) AND() antlr.TerminalNode {
	return s.GetToken(asn1ParserAND, 0)
}

func (s *RuleTypeFieldReferenceContext) UCASE_ID() antlr.TerminalNode {
	return s.GetToken(asn1ParserUCASE_ID, 0)
}

func (s *RuleTypeFieldReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleTypeFieldReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleTypeFieldReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleTypeFieldReference(s)
	}
}

func (s *RuleTypeFieldReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleTypeFieldReference(s)
	}
}

func (s *RuleTypeFieldReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleTypeFieldReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleTypeFieldReference() (localctx IRuleTypeFieldReferenceContext) {
	this := p
	_ = this

	localctx = NewRuleTypeFieldReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, asn1ParserRULE_ruleTypeFieldReference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(814)
		p.Match(asn1ParserAND)
	}
	{
		p.SetState(815)
		p.Match(asn1ParserUCASE_ID)
	}

	return localctx
}

// IRuleValueFieldReferenceContext is an interface to support dynamic dispatch.
type IRuleValueFieldReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleValueFieldReferenceContext differentiates from other interfaces.
	IsRuleValueFieldReferenceContext()
}

type RuleValueFieldReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleValueFieldReferenceContext() *RuleValueFieldReferenceContext {
	var p = new(RuleValueFieldReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleValueFieldReference
	return p
}

func (*RuleValueFieldReferenceContext) IsRuleValueFieldReferenceContext() {}

func NewRuleValueFieldReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleValueFieldReferenceContext {
	var p = new(RuleValueFieldReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleValueFieldReference

	return p
}

func (s *RuleValueFieldReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleValueFieldReferenceContext) AND() antlr.TerminalNode {
	return s.GetToken(asn1ParserAND, 0)
}

func (s *RuleValueFieldReferenceContext) LCASE_ID() antlr.TerminalNode {
	return s.GetToken(asn1ParserLCASE_ID, 0)
}

func (s *RuleValueFieldReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleValueFieldReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleValueFieldReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleValueFieldReference(s)
	}
}

func (s *RuleValueFieldReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleValueFieldReference(s)
	}
}

func (s *RuleValueFieldReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleValueFieldReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleValueFieldReference() (localctx IRuleValueFieldReferenceContext) {
	this := p
	_ = this

	localctx = NewRuleValueFieldReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, asn1ParserRULE_ruleValueFieldReference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(817)
		p.Match(asn1ParserAND)
	}
	{
		p.SetState(818)
		p.Match(asn1ParserLCASE_ID)
	}

	return localctx
}

// IRuleValueSetFieldReferenceContext is an interface to support dynamic dispatch.
type IRuleValueSetFieldReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleValueSetFieldReferenceContext differentiates from other interfaces.
	IsRuleValueSetFieldReferenceContext()
}

type RuleValueSetFieldReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleValueSetFieldReferenceContext() *RuleValueSetFieldReferenceContext {
	var p = new(RuleValueSetFieldReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleValueSetFieldReference
	return p
}

func (*RuleValueSetFieldReferenceContext) IsRuleValueSetFieldReferenceContext() {}

func NewRuleValueSetFieldReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleValueSetFieldReferenceContext {
	var p = new(RuleValueSetFieldReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleValueSetFieldReference

	return p
}

func (s *RuleValueSetFieldReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleValueSetFieldReferenceContext) AND() antlr.TerminalNode {
	return s.GetToken(asn1ParserAND, 0)
}

func (s *RuleValueSetFieldReferenceContext) UCASE_ID() antlr.TerminalNode {
	return s.GetToken(asn1ParserUCASE_ID, 0)
}

func (s *RuleValueSetFieldReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleValueSetFieldReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleValueSetFieldReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleValueSetFieldReference(s)
	}
}

func (s *RuleValueSetFieldReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleValueSetFieldReference(s)
	}
}

func (s *RuleValueSetFieldReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleValueSetFieldReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleValueSetFieldReference() (localctx IRuleValueSetFieldReferenceContext) {
	this := p
	_ = this

	localctx = NewRuleValueSetFieldReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, asn1ParserRULE_ruleValueSetFieldReference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(820)
		p.Match(asn1ParserAND)
	}
	{
		p.SetState(821)
		p.Match(asn1ParserUCASE_ID)
	}

	return localctx
}

// IRuleObjectFieldReferenceContext is an interface to support dynamic dispatch.
type IRuleObjectFieldReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleObjectFieldReferenceContext differentiates from other interfaces.
	IsRuleObjectFieldReferenceContext()
}

type RuleObjectFieldReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleObjectFieldReferenceContext() *RuleObjectFieldReferenceContext {
	var p = new(RuleObjectFieldReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleObjectFieldReference
	return p
}

func (*RuleObjectFieldReferenceContext) IsRuleObjectFieldReferenceContext() {}

func NewRuleObjectFieldReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleObjectFieldReferenceContext {
	var p = new(RuleObjectFieldReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleObjectFieldReference

	return p
}

func (s *RuleObjectFieldReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleObjectFieldReferenceContext) AND() antlr.TerminalNode {
	return s.GetToken(asn1ParserAND, 0)
}

func (s *RuleObjectFieldReferenceContext) LCASE_ID() antlr.TerminalNode {
	return s.GetToken(asn1ParserLCASE_ID, 0)
}

func (s *RuleObjectFieldReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleObjectFieldReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleObjectFieldReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleObjectFieldReference(s)
	}
}

func (s *RuleObjectFieldReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleObjectFieldReference(s)
	}
}

func (s *RuleObjectFieldReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleObjectFieldReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleObjectFieldReference() (localctx IRuleObjectFieldReferenceContext) {
	this := p
	_ = this

	localctx = NewRuleObjectFieldReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, asn1ParserRULE_ruleObjectFieldReference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(823)
		p.Match(asn1ParserAND)
	}
	{
		p.SetState(824)
		p.Match(asn1ParserLCASE_ID)
	}

	return localctx
}

// IRuleObjectSetFieldReferenceContext is an interface to support dynamic dispatch.
type IRuleObjectSetFieldReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleObjectSetFieldReferenceContext differentiates from other interfaces.
	IsRuleObjectSetFieldReferenceContext()
}

type RuleObjectSetFieldReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleObjectSetFieldReferenceContext() *RuleObjectSetFieldReferenceContext {
	var p = new(RuleObjectSetFieldReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleObjectSetFieldReference
	return p
}

func (*RuleObjectSetFieldReferenceContext) IsRuleObjectSetFieldReferenceContext() {}

func NewRuleObjectSetFieldReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleObjectSetFieldReferenceContext {
	var p = new(RuleObjectSetFieldReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleObjectSetFieldReference

	return p
}

func (s *RuleObjectSetFieldReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleObjectSetFieldReferenceContext) AND() antlr.TerminalNode {
	return s.GetToken(asn1ParserAND, 0)
}

func (s *RuleObjectSetFieldReferenceContext) UCASE_ID() antlr.TerminalNode {
	return s.GetToken(asn1ParserUCASE_ID, 0)
}

func (s *RuleObjectSetFieldReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleObjectSetFieldReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleObjectSetFieldReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleObjectSetFieldReference(s)
	}
}

func (s *RuleObjectSetFieldReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleObjectSetFieldReference(s)
	}
}

func (s *RuleObjectSetFieldReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleObjectSetFieldReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleObjectSetFieldReference() (localctx IRuleObjectSetFieldReferenceContext) {
	this := p
	_ = this

	localctx = NewRuleObjectSetFieldReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, asn1ParserRULE_ruleObjectSetFieldReference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(826)
		p.Match(asn1ParserAND)
	}
	{
		p.SetState(827)
		p.Match(asn1ParserUCASE_ID)
	}

	return localctx
}

// IRuleUsefulObjectClassReferenceContext is an interface to support dynamic dispatch.
type IRuleUsefulObjectClassReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleUsefulObjectClassReferenceContext differentiates from other interfaces.
	IsRuleUsefulObjectClassReferenceContext()
}

type RuleUsefulObjectClassReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleUsefulObjectClassReferenceContext() *RuleUsefulObjectClassReferenceContext {
	var p = new(RuleUsefulObjectClassReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleUsefulObjectClassReference
	return p
}

func (*RuleUsefulObjectClassReferenceContext) IsRuleUsefulObjectClassReferenceContext() {}

func NewRuleUsefulObjectClassReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleUsefulObjectClassReferenceContext {
	var p = new(RuleUsefulObjectClassReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleUsefulObjectClassReference

	return p
}

func (s *RuleUsefulObjectClassReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleUsefulObjectClassReferenceContext) TYPE_IDENTIFIER_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserTYPE_IDENTIFIER_SYM, 0)
}

func (s *RuleUsefulObjectClassReferenceContext) ABSTRACT_SYNTAX_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserABSTRACT_SYNTAX_SYM, 0)
}

func (s *RuleUsefulObjectClassReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleUsefulObjectClassReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleUsefulObjectClassReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleUsefulObjectClassReference(s)
	}
}

func (s *RuleUsefulObjectClassReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleUsefulObjectClassReference(s)
	}
}

func (s *RuleUsefulObjectClassReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleUsefulObjectClassReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleUsefulObjectClassReference() (localctx IRuleUsefulObjectClassReferenceContext) {
	this := p
	_ = this

	localctx = NewRuleUsefulObjectClassReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, asn1ParserRULE_ruleUsefulObjectClassReference)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(829)
		_la = p.GetTokenStream().LA(1)

		if !(_la == asn1ParserABSTRACT_SYNTAX_SYM || _la == asn1ParserTYPE_IDENTIFIER_SYM) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IRuleImportsContext is an interface to support dynamic dispatch.
type IRuleImportsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleImportsContext differentiates from other interfaces.
	IsRuleImportsContext()
}

type RuleImportsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleImportsContext() *RuleImportsContext {
	var p = new(RuleImportsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleImports
	return p
}

func (*RuleImportsContext) IsRuleImportsContext() {}

func NewRuleImportsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleImportsContext {
	var p = new(RuleImportsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleImports

	return p
}

func (s *RuleImportsContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleImportsContext) IMPORTS_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserIMPORTS_SYM, 0)
}

func (s *RuleImportsContext) RuleSymbolsImported() IRuleSymbolsImportedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSymbolsImportedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSymbolsImportedContext)
}

func (s *RuleImportsContext) SEMI_COMMA() antlr.TerminalNode {
	return s.GetToken(asn1ParserSEMI_COMMA, 0)
}

func (s *RuleImportsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleImportsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleImportsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleImports(s)
	}
}

func (s *RuleImportsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleImports(s)
	}
}

func (s *RuleImportsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleImports(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleImports() (localctx IRuleImportsContext) {
	this := p
	_ = this

	localctx = NewRuleImportsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, asn1ParserRULE_ruleImports)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(836)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(831)
			p.Match(asn1ParserIMPORTS_SYM)
		}
		{
			p.SetState(832)
			p.RuleSymbolsImported()
		}
		{
			p.SetState(833)
			p.Match(asn1ParserSEMI_COMMA)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)

	}

	return localctx
}

// IRuleSymbolsImportedContext is an interface to support dynamic dispatch.
type IRuleSymbolsImportedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleSymbolsImportedContext differentiates from other interfaces.
	IsRuleSymbolsImportedContext()
}

type RuleSymbolsImportedContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleSymbolsImportedContext() *RuleSymbolsImportedContext {
	var p = new(RuleSymbolsImportedContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleSymbolsImported
	return p
}

func (*RuleSymbolsImportedContext) IsRuleSymbolsImportedContext() {}

func NewRuleSymbolsImportedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleSymbolsImportedContext {
	var p = new(RuleSymbolsImportedContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleSymbolsImported

	return p
}

func (s *RuleSymbolsImportedContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleSymbolsImportedContext) RuleSymbolsFromModuleList() IRuleSymbolsFromModuleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSymbolsFromModuleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSymbolsFromModuleListContext)
}

func (s *RuleSymbolsImportedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleSymbolsImportedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleSymbolsImportedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleSymbolsImported(s)
	}
}

func (s *RuleSymbolsImportedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleSymbolsImported(s)
	}
}

func (s *RuleSymbolsImportedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleSymbolsImported(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleSymbolsImported() (localctx IRuleSymbolsImportedContext) {
	this := p
	_ = this

	localctx = NewRuleSymbolsImportedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, asn1ParserRULE_ruleSymbolsImported)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(840)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case asn1ParserUCASE_ID, asn1ParserLCASE_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(838)
			p.ruleSymbolsFromModuleList(0)
		}

	case asn1ParserSEMI_COMMA:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRuleSymbolsFromModuleListContext is an interface to support dynamic dispatch.
type IRuleSymbolsFromModuleListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleSymbolsFromModuleListContext differentiates from other interfaces.
	IsRuleSymbolsFromModuleListContext()
}

type RuleSymbolsFromModuleListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleSymbolsFromModuleListContext() *RuleSymbolsFromModuleListContext {
	var p = new(RuleSymbolsFromModuleListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleSymbolsFromModuleList
	return p
}

func (*RuleSymbolsFromModuleListContext) IsRuleSymbolsFromModuleListContext() {}

func NewRuleSymbolsFromModuleListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleSymbolsFromModuleListContext {
	var p = new(RuleSymbolsFromModuleListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleSymbolsFromModuleList

	return p
}

func (s *RuleSymbolsFromModuleListContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleSymbolsFromModuleListContext) RuleSymbolsFromModule() IRuleSymbolsFromModuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSymbolsFromModuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSymbolsFromModuleContext)
}

func (s *RuleSymbolsFromModuleListContext) RuleSymbolsFromModuleList() IRuleSymbolsFromModuleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSymbolsFromModuleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSymbolsFromModuleListContext)
}

func (s *RuleSymbolsFromModuleListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleSymbolsFromModuleListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleSymbolsFromModuleListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleSymbolsFromModuleList(s)
	}
}

func (s *RuleSymbolsFromModuleListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleSymbolsFromModuleList(s)
	}
}

func (s *RuleSymbolsFromModuleListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleSymbolsFromModuleList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleSymbolsFromModuleList() (localctx IRuleSymbolsFromModuleListContext) {
	return p.ruleSymbolsFromModuleList(0)
}

func (p *asn1Parser) ruleSymbolsFromModuleList(_p int) (localctx IRuleSymbolsFromModuleListContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRuleSymbolsFromModuleListContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRuleSymbolsFromModuleListContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 90
	p.EnterRecursionRule(localctx, 90, asn1ParserRULE_ruleSymbolsFromModuleList, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(843)
		p.RuleSymbolsFromModule()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(849)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewRuleSymbolsFromModuleListContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, asn1ParserRULE_ruleSymbolsFromModuleList)
			p.SetState(845)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(846)
				p.RuleSymbolsFromModule()
			}

		}
		p.SetState(851)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 16, p.GetParserRuleContext())
	}

	return localctx
}

// IRuleSymbolsFromModuleContext is an interface to support dynamic dispatch.
type IRuleSymbolsFromModuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleSymbolsFromModuleContext differentiates from other interfaces.
	IsRuleSymbolsFromModuleContext()
}

type RuleSymbolsFromModuleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleSymbolsFromModuleContext() *RuleSymbolsFromModuleContext {
	var p = new(RuleSymbolsFromModuleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleSymbolsFromModule
	return p
}

func (*RuleSymbolsFromModuleContext) IsRuleSymbolsFromModuleContext() {}

func NewRuleSymbolsFromModuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleSymbolsFromModuleContext {
	var p = new(RuleSymbolsFromModuleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleSymbolsFromModule

	return p
}

func (s *RuleSymbolsFromModuleContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleSymbolsFromModuleContext) RuleSymbolList() IRuleSymbolListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSymbolListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSymbolListContext)
}

func (s *RuleSymbolsFromModuleContext) FROM_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserFROM_SYM, 0)
}

func (s *RuleSymbolsFromModuleContext) RuleGlobalModuleReference() IRuleGlobalModuleReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleGlobalModuleReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleGlobalModuleReferenceContext)
}

func (s *RuleSymbolsFromModuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleSymbolsFromModuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleSymbolsFromModuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleSymbolsFromModule(s)
	}
}

func (s *RuleSymbolsFromModuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleSymbolsFromModule(s)
	}
}

func (s *RuleSymbolsFromModuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleSymbolsFromModule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleSymbolsFromModule() (localctx IRuleSymbolsFromModuleContext) {
	this := p
	_ = this

	localctx = NewRuleSymbolsFromModuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, asn1ParserRULE_ruleSymbolsFromModule)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(852)
		p.ruleSymbolList(0)
	}
	{
		p.SetState(853)
		p.Match(asn1ParserFROM_SYM)
	}
	{
		p.SetState(854)
		p.RuleGlobalModuleReference()
	}

	return localctx
}

// IRuleGlobalModuleReferenceContext is an interface to support dynamic dispatch.
type IRuleGlobalModuleReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleGlobalModuleReferenceContext differentiates from other interfaces.
	IsRuleGlobalModuleReferenceContext()
}

type RuleGlobalModuleReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleGlobalModuleReferenceContext() *RuleGlobalModuleReferenceContext {
	var p = new(RuleGlobalModuleReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleGlobalModuleReference
	return p
}

func (*RuleGlobalModuleReferenceContext) IsRuleGlobalModuleReferenceContext() {}

func NewRuleGlobalModuleReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleGlobalModuleReferenceContext {
	var p = new(RuleGlobalModuleReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleGlobalModuleReference

	return p
}

func (s *RuleGlobalModuleReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleGlobalModuleReferenceContext) RuleModuleReference() IRuleModuleReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleModuleReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleModuleReferenceContext)
}

func (s *RuleGlobalModuleReferenceContext) RuleAssignedIdentifier() IRuleAssignedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleAssignedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleAssignedIdentifierContext)
}

func (s *RuleGlobalModuleReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleGlobalModuleReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleGlobalModuleReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleGlobalModuleReference(s)
	}
}

func (s *RuleGlobalModuleReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleGlobalModuleReference(s)
	}
}

func (s *RuleGlobalModuleReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleGlobalModuleReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleGlobalModuleReference() (localctx IRuleGlobalModuleReferenceContext) {
	this := p
	_ = this

	localctx = NewRuleGlobalModuleReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, asn1ParserRULE_ruleGlobalModuleReference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(856)
		p.RuleModuleReference()
	}
	{
		p.SetState(857)
		p.RuleAssignedIdentifier()
	}

	return localctx
}

// IRuleAssignedIdentifierContext is an interface to support dynamic dispatch.
type IRuleAssignedIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleAssignedIdentifierContext differentiates from other interfaces.
	IsRuleAssignedIdentifierContext()
}

type RuleAssignedIdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleAssignedIdentifierContext() *RuleAssignedIdentifierContext {
	var p = new(RuleAssignedIdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleAssignedIdentifier
	return p
}

func (*RuleAssignedIdentifierContext) IsRuleAssignedIdentifierContext() {}

func NewRuleAssignedIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleAssignedIdentifierContext {
	var p = new(RuleAssignedIdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleAssignedIdentifier

	return p
}

func (s *RuleAssignedIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleAssignedIdentifierContext) RuleObjectIdentifierValue() IRuleObjectIdentifierValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectIdentifierValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectIdentifierValueContext)
}

func (s *RuleAssignedIdentifierContext) RuleDefinedValue() IRuleDefinedValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinedValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinedValueContext)
}

func (s *RuleAssignedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleAssignedIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleAssignedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleAssignedIdentifier(s)
	}
}

func (s *RuleAssignedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleAssignedIdentifier(s)
	}
}

func (s *RuleAssignedIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleAssignedIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleAssignedIdentifier() (localctx IRuleAssignedIdentifierContext) {
	this := p
	_ = this

	localctx = NewRuleAssignedIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, asn1ParserRULE_ruleAssignedIdentifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(862)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(859)
			p.RuleObjectIdentifierValue()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(860)
			p.RuleDefinedValue()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)

	}

	return localctx
}

// IRuleAssignmentListContext is an interface to support dynamic dispatch.
type IRuleAssignmentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleAssignmentListContext differentiates from other interfaces.
	IsRuleAssignmentListContext()
}

type RuleAssignmentListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleAssignmentListContext() *RuleAssignmentListContext {
	var p = new(RuleAssignmentListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleAssignmentList
	return p
}

func (*RuleAssignmentListContext) IsRuleAssignmentListContext() {}

func NewRuleAssignmentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleAssignmentListContext {
	var p = new(RuleAssignmentListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleAssignmentList

	return p
}

func (s *RuleAssignmentListContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleAssignmentListContext) RuleAssignment() IRuleAssignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleAssignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleAssignmentContext)
}

func (s *RuleAssignmentListContext) RuleAssignmentList() IRuleAssignmentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleAssignmentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleAssignmentListContext)
}

func (s *RuleAssignmentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleAssignmentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleAssignmentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleAssignmentList(s)
	}
}

func (s *RuleAssignmentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleAssignmentList(s)
	}
}

func (s *RuleAssignmentListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleAssignmentList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleAssignmentList() (localctx IRuleAssignmentListContext) {
	return p.ruleAssignmentList(0)
}

func (p *asn1Parser) ruleAssignmentList(_p int) (localctx IRuleAssignmentListContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRuleAssignmentListContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRuleAssignmentListContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 98
	p.EnterRecursionRule(localctx, 98, asn1ParserRULE_ruleAssignmentList, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(867)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(865)
			p.RuleAssignment()
		}

	case 2:

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(873)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewRuleAssignmentListContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, asn1ParserRULE_ruleAssignmentList)
			p.SetState(869)

			if !(p.Precpred(p.GetParserRuleContext(), 3)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
			}
			{
				p.SetState(870)
				p.RuleAssignment()
			}

		}
		p.SetState(875)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 19, p.GetParserRuleContext())
	}

	return localctx
}

// IRuleAssignmentContext is an interface to support dynamic dispatch.
type IRuleAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleAssignmentContext differentiates from other interfaces.
	IsRuleAssignmentContext()
}

type RuleAssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleAssignmentContext() *RuleAssignmentContext {
	var p = new(RuleAssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleAssignment
	return p
}

func (*RuleAssignmentContext) IsRuleAssignmentContext() {}

func NewRuleAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleAssignmentContext {
	var p = new(RuleAssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleAssignment

	return p
}

func (s *RuleAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleAssignmentContext) RuleTypeAssignment() IRuleTypeAssignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeAssignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeAssignmentContext)
}

func (s *RuleAssignmentContext) RuleValueAssignment() IRuleValueAssignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueAssignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueAssignmentContext)
}

func (s *RuleAssignmentContext) RuleValueSetTypeAssignment() IRuleValueSetTypeAssignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueSetTypeAssignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueSetTypeAssignmentContext)
}

func (s *RuleAssignmentContext) RuleObjectClassAssignment() IRuleObjectClassAssignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectClassAssignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectClassAssignmentContext)
}

func (s *RuleAssignmentContext) RuleObjectAssignment() IRuleObjectAssignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectAssignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectAssignmentContext)
}

func (s *RuleAssignmentContext) RuleObjectSetAssignment() IRuleObjectSetAssignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectSetAssignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectSetAssignmentContext)
}

func (s *RuleAssignmentContext) RuleParameterizedAssignment() IRuleParameterizedAssignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleParameterizedAssignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleParameterizedAssignmentContext)
}

func (s *RuleAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleAssignment(s)
	}
}

func (s *RuleAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleAssignment(s)
	}
}

func (s *RuleAssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleAssignment() (localctx IRuleAssignmentContext) {
	this := p
	_ = this

	localctx = NewRuleAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, asn1ParserRULE_ruleAssignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(883)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 20, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(876)
			p.RuleTypeAssignment()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(877)
			p.RuleValueAssignment()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(878)
			p.RuleValueSetTypeAssignment()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(879)
			p.RuleObjectClassAssignment()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(880)
			p.RuleObjectAssignment()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(881)
			p.RuleObjectSetAssignment()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(882)
			p.RuleParameterizedAssignment()
		}

	}

	return localctx
}

// IRuleTypeAssignmentContext is an interface to support dynamic dispatch.
type IRuleTypeAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleTypeAssignmentContext differentiates from other interfaces.
	IsRuleTypeAssignmentContext()
}

type RuleTypeAssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleTypeAssignmentContext() *RuleTypeAssignmentContext {
	var p = new(RuleTypeAssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleTypeAssignment
	return p
}

func (*RuleTypeAssignmentContext) IsRuleTypeAssignmentContext() {}

func NewRuleTypeAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleTypeAssignmentContext {
	var p = new(RuleTypeAssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleTypeAssignment

	return p
}

func (s *RuleTypeAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleTypeAssignmentContext) RuleTypeReference() IRuleTypeReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeReferenceContext)
}

func (s *RuleTypeAssignmentContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(asn1ParserASSIGNMENT, 0)
}

func (s *RuleTypeAssignmentContext) RuleType() IRuleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeContext)
}

func (s *RuleTypeAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleTypeAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleTypeAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleTypeAssignment(s)
	}
}

func (s *RuleTypeAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleTypeAssignment(s)
	}
}

func (s *RuleTypeAssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleTypeAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleTypeAssignment() (localctx IRuleTypeAssignmentContext) {
	this := p
	_ = this

	localctx = NewRuleTypeAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, asn1ParserRULE_ruleTypeAssignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(885)
		p.RuleTypeReference()
	}
	{
		p.SetState(886)
		p.Match(asn1ParserASSIGNMENT)
	}
	{
		p.SetState(887)
		p.RuleType()
	}

	return localctx
}

// IRuleValueAssignmentContext is an interface to support dynamic dispatch.
type IRuleValueAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleValueAssignmentContext differentiates from other interfaces.
	IsRuleValueAssignmentContext()
}

type RuleValueAssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleValueAssignmentContext() *RuleValueAssignmentContext {
	var p = new(RuleValueAssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleValueAssignment
	return p
}

func (*RuleValueAssignmentContext) IsRuleValueAssignmentContext() {}

func NewRuleValueAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleValueAssignmentContext {
	var p = new(RuleValueAssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleValueAssignment

	return p
}

func (s *RuleValueAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleValueAssignmentContext) RuleValueReference() IRuleValueReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueReferenceContext)
}

func (s *RuleValueAssignmentContext) RuleType() IRuleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeContext)
}

func (s *RuleValueAssignmentContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(asn1ParserASSIGNMENT, 0)
}

func (s *RuleValueAssignmentContext) RuleValue() IRuleValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueContext)
}

func (s *RuleValueAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleValueAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleValueAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleValueAssignment(s)
	}
}

func (s *RuleValueAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleValueAssignment(s)
	}
}

func (s *RuleValueAssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleValueAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleValueAssignment() (localctx IRuleValueAssignmentContext) {
	this := p
	_ = this

	localctx = NewRuleValueAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, asn1ParserRULE_ruleValueAssignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(889)
		p.RuleValueReference()
	}
	{
		p.SetState(890)
		p.RuleType()
	}
	{
		p.SetState(891)
		p.Match(asn1ParserASSIGNMENT)
	}
	{
		p.SetState(892)
		p.RuleValue()
	}

	return localctx
}

// IRuleXMLValueAssignmentContext is an interface to support dynamic dispatch.
type IRuleXMLValueAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleXMLValueAssignmentContext differentiates from other interfaces.
	IsRuleXMLValueAssignmentContext()
}

type RuleXMLValueAssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleXMLValueAssignmentContext() *RuleXMLValueAssignmentContext {
	var p = new(RuleXMLValueAssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleXMLValueAssignment
	return p
}

func (*RuleXMLValueAssignmentContext) IsRuleXMLValueAssignmentContext() {}

func NewRuleXMLValueAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleXMLValueAssignmentContext {
	var p = new(RuleXMLValueAssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleXMLValueAssignment

	return p
}

func (s *RuleXMLValueAssignmentContext) GetParser() antlr.Parser { return s.parser }
func (s *RuleXMLValueAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleXMLValueAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleXMLValueAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleXMLValueAssignment(s)
	}
}

func (s *RuleXMLValueAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleXMLValueAssignment(s)
	}
}

func (s *RuleXMLValueAssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleXMLValueAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleXMLValueAssignment() (localctx IRuleXMLValueAssignmentContext) {
	this := p
	_ = this

	localctx = NewRuleXMLValueAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, asn1ParserRULE_ruleXMLValueAssignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)

	return localctx
}

// IRuleValueSetTypeAssignmentContext is an interface to support dynamic dispatch.
type IRuleValueSetTypeAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleValueSetTypeAssignmentContext differentiates from other interfaces.
	IsRuleValueSetTypeAssignmentContext()
}

type RuleValueSetTypeAssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleValueSetTypeAssignmentContext() *RuleValueSetTypeAssignmentContext {
	var p = new(RuleValueSetTypeAssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleValueSetTypeAssignment
	return p
}

func (*RuleValueSetTypeAssignmentContext) IsRuleValueSetTypeAssignmentContext() {}

func NewRuleValueSetTypeAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleValueSetTypeAssignmentContext {
	var p = new(RuleValueSetTypeAssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleValueSetTypeAssignment

	return p
}

func (s *RuleValueSetTypeAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleValueSetTypeAssignmentContext) RuleTypeReference() IRuleTypeReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeReferenceContext)
}

func (s *RuleValueSetTypeAssignmentContext) RuleType() IRuleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeContext)
}

func (s *RuleValueSetTypeAssignmentContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(asn1ParserASSIGNMENT, 0)
}

func (s *RuleValueSetTypeAssignmentContext) RuleValueSet() IRuleValueSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueSetContext)
}

func (s *RuleValueSetTypeAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleValueSetTypeAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleValueSetTypeAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleValueSetTypeAssignment(s)
	}
}

func (s *RuleValueSetTypeAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleValueSetTypeAssignment(s)
	}
}

func (s *RuleValueSetTypeAssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleValueSetTypeAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleValueSetTypeAssignment() (localctx IRuleValueSetTypeAssignmentContext) {
	this := p
	_ = this

	localctx = NewRuleValueSetTypeAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, asn1ParserRULE_ruleValueSetTypeAssignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(896)
		p.RuleTypeReference()
	}
	{
		p.SetState(897)
		p.RuleType()
	}
	{
		p.SetState(898)
		p.Match(asn1ParserASSIGNMENT)
	}
	{
		p.SetState(899)
		p.RuleValueSet()
	}

	return localctx
}

// IRuleObjectAssignmentContext is an interface to support dynamic dispatch.
type IRuleObjectAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleObjectAssignmentContext differentiates from other interfaces.
	IsRuleObjectAssignmentContext()
}

type RuleObjectAssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleObjectAssignmentContext() *RuleObjectAssignmentContext {
	var p = new(RuleObjectAssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleObjectAssignment
	return p
}

func (*RuleObjectAssignmentContext) IsRuleObjectAssignmentContext() {}

func NewRuleObjectAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleObjectAssignmentContext {
	var p = new(RuleObjectAssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleObjectAssignment

	return p
}

func (s *RuleObjectAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleObjectAssignmentContext) RuleObjectReference() IRuleObjectReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectReferenceContext)
}

func (s *RuleObjectAssignmentContext) RuleDefinedObjectClass() IRuleDefinedObjectClassContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinedObjectClassContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinedObjectClassContext)
}

func (s *RuleObjectAssignmentContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(asn1ParserASSIGNMENT, 0)
}

func (s *RuleObjectAssignmentContext) RuleObject() IRuleObjectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectContext)
}

func (s *RuleObjectAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleObjectAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleObjectAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleObjectAssignment(s)
	}
}

func (s *RuleObjectAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleObjectAssignment(s)
	}
}

func (s *RuleObjectAssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleObjectAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleObjectAssignment() (localctx IRuleObjectAssignmentContext) {
	this := p
	_ = this

	localctx = NewRuleObjectAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, asn1ParserRULE_ruleObjectAssignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(901)
		p.RuleObjectReference()
	}
	{
		p.SetState(902)
		p.RuleDefinedObjectClass()
	}
	{
		p.SetState(903)
		p.Match(asn1ParserASSIGNMENT)
	}
	{
		p.SetState(904)
		p.RuleObject()
	}

	return localctx
}

// IRuleObjectClassAssignmentContext is an interface to support dynamic dispatch.
type IRuleObjectClassAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleObjectClassAssignmentContext differentiates from other interfaces.
	IsRuleObjectClassAssignmentContext()
}

type RuleObjectClassAssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleObjectClassAssignmentContext() *RuleObjectClassAssignmentContext {
	var p = new(RuleObjectClassAssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleObjectClassAssignment
	return p
}

func (*RuleObjectClassAssignmentContext) IsRuleObjectClassAssignmentContext() {}

func NewRuleObjectClassAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleObjectClassAssignmentContext {
	var p = new(RuleObjectClassAssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleObjectClassAssignment

	return p
}

func (s *RuleObjectClassAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleObjectClassAssignmentContext) RuleObjectClassReference() IRuleObjectClassReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectClassReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectClassReferenceContext)
}

func (s *RuleObjectClassAssignmentContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(asn1ParserASSIGNMENT, 0)
}

func (s *RuleObjectClassAssignmentContext) RuleObjectClass() IRuleObjectClassContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectClassContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectClassContext)
}

func (s *RuleObjectClassAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleObjectClassAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleObjectClassAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleObjectClassAssignment(s)
	}
}

func (s *RuleObjectClassAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleObjectClassAssignment(s)
	}
}

func (s *RuleObjectClassAssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleObjectClassAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleObjectClassAssignment() (localctx IRuleObjectClassAssignmentContext) {
	this := p
	_ = this

	localctx = NewRuleObjectClassAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, asn1ParserRULE_ruleObjectClassAssignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(906)
		p.RuleObjectClassReference()
	}
	{
		p.SetState(907)
		p.Match(asn1ParserASSIGNMENT)
	}
	{
		p.SetState(908)
		p.RuleObjectClass()
	}

	return localctx
}

// IRuleObjectSetAssignmentContext is an interface to support dynamic dispatch.
type IRuleObjectSetAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleObjectSetAssignmentContext differentiates from other interfaces.
	IsRuleObjectSetAssignmentContext()
}

type RuleObjectSetAssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleObjectSetAssignmentContext() *RuleObjectSetAssignmentContext {
	var p = new(RuleObjectSetAssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleObjectSetAssignment
	return p
}

func (*RuleObjectSetAssignmentContext) IsRuleObjectSetAssignmentContext() {}

func NewRuleObjectSetAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleObjectSetAssignmentContext {
	var p = new(RuleObjectSetAssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleObjectSetAssignment

	return p
}

func (s *RuleObjectSetAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleObjectSetAssignmentContext) RuleObjectSetReference() IRuleObjectSetReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectSetReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectSetReferenceContext)
}

func (s *RuleObjectSetAssignmentContext) RuleDefinedObjectClass() IRuleDefinedObjectClassContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinedObjectClassContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinedObjectClassContext)
}

func (s *RuleObjectSetAssignmentContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(asn1ParserASSIGNMENT, 0)
}

func (s *RuleObjectSetAssignmentContext) RuleObjectSet() IRuleObjectSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectSetContext)
}

func (s *RuleObjectSetAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleObjectSetAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleObjectSetAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleObjectSetAssignment(s)
	}
}

func (s *RuleObjectSetAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleObjectSetAssignment(s)
	}
}

func (s *RuleObjectSetAssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleObjectSetAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleObjectSetAssignment() (localctx IRuleObjectSetAssignmentContext) {
	this := p
	_ = this

	localctx = NewRuleObjectSetAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, asn1ParserRULE_ruleObjectSetAssignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(910)
		p.RuleObjectSetReference()
	}
	{
		p.SetState(911)
		p.RuleDefinedObjectClass()
	}
	{
		p.SetState(912)
		p.Match(asn1ParserASSIGNMENT)
	}
	{
		p.SetState(913)
		p.RuleObjectSet()
	}

	return localctx
}

// IRuleParameterizedAssignmentContext is an interface to support dynamic dispatch.
type IRuleParameterizedAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleParameterizedAssignmentContext differentiates from other interfaces.
	IsRuleParameterizedAssignmentContext()
}

type RuleParameterizedAssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleParameterizedAssignmentContext() *RuleParameterizedAssignmentContext {
	var p = new(RuleParameterizedAssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleParameterizedAssignment
	return p
}

func (*RuleParameterizedAssignmentContext) IsRuleParameterizedAssignmentContext() {}

func NewRuleParameterizedAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleParameterizedAssignmentContext {
	var p = new(RuleParameterizedAssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleParameterizedAssignment

	return p
}

func (s *RuleParameterizedAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleParameterizedAssignmentContext) RuleParameterizedTypeAssignment() IRuleParameterizedTypeAssignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleParameterizedTypeAssignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleParameterizedTypeAssignmentContext)
}

func (s *RuleParameterizedAssignmentContext) RuleParameterizedValueAssignment() IRuleParameterizedValueAssignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleParameterizedValueAssignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleParameterizedValueAssignmentContext)
}

func (s *RuleParameterizedAssignmentContext) RuleParameterizedValueSetTypeAssignment() IRuleParameterizedValueSetTypeAssignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleParameterizedValueSetTypeAssignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleParameterizedValueSetTypeAssignmentContext)
}

func (s *RuleParameterizedAssignmentContext) RuleParameterizedObjectClassAssignment() IRuleParameterizedObjectClassAssignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleParameterizedObjectClassAssignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleParameterizedObjectClassAssignmentContext)
}

func (s *RuleParameterizedAssignmentContext) RuleParameterizedObjectAssignment() IRuleParameterizedObjectAssignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleParameterizedObjectAssignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleParameterizedObjectAssignmentContext)
}

func (s *RuleParameterizedAssignmentContext) RuleParameterizedObjectSetAssignment() IRuleParameterizedObjectSetAssignmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleParameterizedObjectSetAssignmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleParameterizedObjectSetAssignmentContext)
}

func (s *RuleParameterizedAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleParameterizedAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleParameterizedAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleParameterizedAssignment(s)
	}
}

func (s *RuleParameterizedAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleParameterizedAssignment(s)
	}
}

func (s *RuleParameterizedAssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleParameterizedAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleParameterizedAssignment() (localctx IRuleParameterizedAssignmentContext) {
	this := p
	_ = this

	localctx = NewRuleParameterizedAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, asn1ParserRULE_ruleParameterizedAssignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(921)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(915)
			p.RuleParameterizedTypeAssignment()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(916)
			p.RuleParameterizedValueAssignment()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(917)
			p.RuleParameterizedValueSetTypeAssignment()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(918)
			p.RuleParameterizedObjectClassAssignment()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(919)
			p.RuleParameterizedObjectAssignment()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(920)
			p.RuleParameterizedObjectSetAssignment()
		}

	}

	return localctx
}

// IRuleObjectIdentifierValueContext is an interface to support dynamic dispatch.
type IRuleObjectIdentifierValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleObjectIdentifierValueContext differentiates from other interfaces.
	IsRuleObjectIdentifierValueContext()
}

type RuleObjectIdentifierValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleObjectIdentifierValueContext() *RuleObjectIdentifierValueContext {
	var p = new(RuleObjectIdentifierValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleObjectIdentifierValue
	return p
}

func (*RuleObjectIdentifierValueContext) IsRuleObjectIdentifierValueContext() {}

func NewRuleObjectIdentifierValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleObjectIdentifierValueContext {
	var p = new(RuleObjectIdentifierValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleObjectIdentifierValue

	return p
}

func (s *RuleObjectIdentifierValueContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleObjectIdentifierValueContext) CURLY_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_START, 0)
}

func (s *RuleObjectIdentifierValueContext) RuleObjIdComponentsList() IRuleObjIdComponentsListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjIdComponentsListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjIdComponentsListContext)
}

func (s *RuleObjectIdentifierValueContext) CURLY_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_END, 0)
}

func (s *RuleObjectIdentifierValueContext) RuleDefinedValue() IRuleDefinedValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinedValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinedValueContext)
}

func (s *RuleObjectIdentifierValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleObjectIdentifierValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleObjectIdentifierValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleObjectIdentifierValue(s)
	}
}

func (s *RuleObjectIdentifierValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleObjectIdentifierValue(s)
	}
}

func (s *RuleObjectIdentifierValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleObjectIdentifierValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleObjectIdentifierValue() (localctx IRuleObjectIdentifierValueContext) {
	this := p
	_ = this

	localctx = NewRuleObjectIdentifierValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, asn1ParserRULE_ruleObjectIdentifierValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(932)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(923)
			p.Match(asn1ParserCURLY_START)
		}
		{
			p.SetState(924)
			p.ruleObjIdComponentsList(0)
		}
		{
			p.SetState(925)
			p.Match(asn1ParserCURLY_END)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(927)
			p.Match(asn1ParserCURLY_START)
		}
		{
			p.SetState(928)
			p.RuleDefinedValue()
		}
		{
			p.SetState(929)
			p.ruleObjIdComponentsList(0)
		}
		{
			p.SetState(930)
			p.Match(asn1ParserCURLY_END)
		}

	}

	return localctx
}

// IRuleObjIdComponentsListContext is an interface to support dynamic dispatch.
type IRuleObjIdComponentsListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleObjIdComponentsListContext differentiates from other interfaces.
	IsRuleObjIdComponentsListContext()
}

type RuleObjIdComponentsListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleObjIdComponentsListContext() *RuleObjIdComponentsListContext {
	var p = new(RuleObjIdComponentsListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleObjIdComponentsList
	return p
}

func (*RuleObjIdComponentsListContext) IsRuleObjIdComponentsListContext() {}

func NewRuleObjIdComponentsListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleObjIdComponentsListContext {
	var p = new(RuleObjIdComponentsListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleObjIdComponentsList

	return p
}

func (s *RuleObjIdComponentsListContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleObjIdComponentsListContext) RuleObjIdComponents() IRuleObjIdComponentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjIdComponentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjIdComponentsContext)
}

func (s *RuleObjIdComponentsListContext) RuleObjIdComponentsList() IRuleObjIdComponentsListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjIdComponentsListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjIdComponentsListContext)
}

func (s *RuleObjIdComponentsListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleObjIdComponentsListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleObjIdComponentsListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleObjIdComponentsList(s)
	}
}

func (s *RuleObjIdComponentsListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleObjIdComponentsList(s)
	}
}

func (s *RuleObjIdComponentsListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleObjIdComponentsList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleObjIdComponentsList() (localctx IRuleObjIdComponentsListContext) {
	return p.ruleObjIdComponentsList(0)
}

func (p *asn1Parser) ruleObjIdComponentsList(_p int) (localctx IRuleObjIdComponentsListContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRuleObjIdComponentsListContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRuleObjIdComponentsListContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 120
	p.EnterRecursionRule(localctx, 120, asn1ParserRULE_ruleObjIdComponentsList, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(935)
		p.RuleObjIdComponents()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(941)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewRuleObjIdComponentsListContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, asn1ParserRULE_ruleObjIdComponentsList)
			p.SetState(937)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(938)
				p.RuleObjIdComponents()
			}

		}
		p.SetState(943)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext())
	}

	return localctx
}

// IRuleObjIdComponentsContext is an interface to support dynamic dispatch.
type IRuleObjIdComponentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleObjIdComponentsContext differentiates from other interfaces.
	IsRuleObjIdComponentsContext()
}

type RuleObjIdComponentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleObjIdComponentsContext() *RuleObjIdComponentsContext {
	var p = new(RuleObjIdComponentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleObjIdComponents
	return p
}

func (*RuleObjIdComponentsContext) IsRuleObjIdComponentsContext() {}

func NewRuleObjIdComponentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleObjIdComponentsContext {
	var p = new(RuleObjIdComponentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleObjIdComponents

	return p
}

func (s *RuleObjIdComponentsContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleObjIdComponentsContext) RuleNameForm() IRuleNameFormContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleNameFormContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleNameFormContext)
}

func (s *RuleObjIdComponentsContext) RuleNumberForm() IRuleNumberFormContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleNumberFormContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleNumberFormContext)
}

func (s *RuleObjIdComponentsContext) RuleNameAndNumberForm() IRuleNameAndNumberFormContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleNameAndNumberFormContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleNameAndNumberFormContext)
}

func (s *RuleObjIdComponentsContext) RuleDefinedValue() IRuleDefinedValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinedValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinedValueContext)
}

func (s *RuleObjIdComponentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleObjIdComponentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleObjIdComponentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleObjIdComponents(s)
	}
}

func (s *RuleObjIdComponentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleObjIdComponents(s)
	}
}

func (s *RuleObjIdComponentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleObjIdComponents(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleObjIdComponents() (localctx IRuleObjIdComponentsContext) {
	this := p
	_ = this

	localctx = NewRuleObjIdComponentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, asn1ParserRULE_ruleObjIdComponents)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(948)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(944)
			p.RuleNameForm()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(945)
			p.RuleNumberForm()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(946)
			p.RuleNameAndNumberForm()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(947)
			p.RuleDefinedValue()
		}

	}

	return localctx
}

// IRuleNumberFormContext is an interface to support dynamic dispatch.
type IRuleNumberFormContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleNumberFormContext differentiates from other interfaces.
	IsRuleNumberFormContext()
}

type RuleNumberFormContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleNumberFormContext() *RuleNumberFormContext {
	var p = new(RuleNumberFormContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleNumberForm
	return p
}

func (*RuleNumberFormContext) IsRuleNumberFormContext() {}

func NewRuleNumberFormContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleNumberFormContext {
	var p = new(RuleNumberFormContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleNumberForm

	return p
}

func (s *RuleNumberFormContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleNumberFormContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(asn1ParserNUMBER, 0)
}

func (s *RuleNumberFormContext) RuleDefinedValue() IRuleDefinedValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinedValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinedValueContext)
}

func (s *RuleNumberFormContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleNumberFormContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleNumberFormContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleNumberForm(s)
	}
}

func (s *RuleNumberFormContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleNumberForm(s)
	}
}

func (s *RuleNumberFormContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleNumberForm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleNumberForm() (localctx IRuleNumberFormContext) {
	this := p
	_ = this

	localctx = NewRuleNumberFormContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, asn1ParserRULE_ruleNumberForm)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(952)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case asn1ParserNUMBER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(950)
			p.Match(asn1ParserNUMBER)
		}

	case asn1ParserUCASE_ID, asn1ParserLCASE_ID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(951)
			p.RuleDefinedValue()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRuleNameAndNumberFormContext is an interface to support dynamic dispatch.
type IRuleNameAndNumberFormContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleNameAndNumberFormContext differentiates from other interfaces.
	IsRuleNameAndNumberFormContext()
}

type RuleNameAndNumberFormContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleNameAndNumberFormContext() *RuleNameAndNumberFormContext {
	var p = new(RuleNameAndNumberFormContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleNameAndNumberForm
	return p
}

func (*RuleNameAndNumberFormContext) IsRuleNameAndNumberFormContext() {}

func NewRuleNameAndNumberFormContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleNameAndNumberFormContext {
	var p = new(RuleNameAndNumberFormContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleNameAndNumberForm

	return p
}

func (s *RuleNameAndNumberFormContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleNameAndNumberFormContext) RuleIdentifier() IRuleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleIdentifierContext)
}

func (s *RuleNameAndNumberFormContext) CURLY_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_START, 0)
}

func (s *RuleNameAndNumberFormContext) RuleNumberForm() IRuleNumberFormContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleNumberFormContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleNumberFormContext)
}

func (s *RuleNameAndNumberFormContext) CURLY_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_END, 0)
}

func (s *RuleNameAndNumberFormContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleNameAndNumberFormContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleNameAndNumberFormContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleNameAndNumberForm(s)
	}
}

func (s *RuleNameAndNumberFormContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleNameAndNumberForm(s)
	}
}

func (s *RuleNameAndNumberFormContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleNameAndNumberForm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleNameAndNumberForm() (localctx IRuleNameAndNumberFormContext) {
	this := p
	_ = this

	localctx = NewRuleNameAndNumberFormContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, asn1ParserRULE_ruleNameAndNumberForm)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(954)
		p.RuleIdentifier()
	}
	{
		p.SetState(955)
		p.Match(asn1ParserCURLY_START)
	}
	{
		p.SetState(956)
		p.RuleNumberForm()
	}
	{
		p.SetState(957)
		p.Match(asn1ParserCURLY_END)
	}

	return localctx
}

// IRuleDefinedValueContext is an interface to support dynamic dispatch.
type IRuleDefinedValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleDefinedValueContext differentiates from other interfaces.
	IsRuleDefinedValueContext()
}

type RuleDefinedValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleDefinedValueContext() *RuleDefinedValueContext {
	var p = new(RuleDefinedValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleDefinedValue
	return p
}

func (*RuleDefinedValueContext) IsRuleDefinedValueContext() {}

func NewRuleDefinedValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleDefinedValueContext {
	var p = new(RuleDefinedValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleDefinedValue

	return p
}

func (s *RuleDefinedValueContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleDefinedValueContext) RuleExternalValueReference() IRuleExternalValueReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleExternalValueReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleExternalValueReferenceContext)
}

func (s *RuleDefinedValueContext) RuleValueReference() IRuleValueReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueReferenceContext)
}

func (s *RuleDefinedValueContext) RuleParameterizedValue() IRuleParameterizedValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleParameterizedValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleParameterizedValueContext)
}

func (s *RuleDefinedValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleDefinedValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleDefinedValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleDefinedValue(s)
	}
}

func (s *RuleDefinedValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleDefinedValue(s)
	}
}

func (s *RuleDefinedValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleDefinedValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleDefinedValue() (localctx IRuleDefinedValueContext) {
	this := p
	_ = this

	localctx = NewRuleDefinedValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, asn1ParserRULE_ruleDefinedValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(962)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 26, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(959)
			p.RuleExternalValueReference()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(960)
			p.RuleValueReference()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(961)
			p.RuleParameterizedValue()
		}

	}

	return localctx
}

// IRuleNamedBitContext is an interface to support dynamic dispatch.
type IRuleNamedBitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleNamedBitContext differentiates from other interfaces.
	IsRuleNamedBitContext()
}

type RuleNamedBitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleNamedBitContext() *RuleNamedBitContext {
	var p = new(RuleNamedBitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleNamedBit
	return p
}

func (*RuleNamedBitContext) IsRuleNamedBitContext() {}

func NewRuleNamedBitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleNamedBitContext {
	var p = new(RuleNamedBitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleNamedBit

	return p
}

func (s *RuleNamedBitContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleNamedBitContext) RuleIdentifier() IRuleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleIdentifierContext)
}

func (s *RuleNamedBitContext) ROUND_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserROUND_START, 0)
}

func (s *RuleNamedBitContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(asn1ParserNUMBER, 0)
}

func (s *RuleNamedBitContext) ROUND_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserROUND_END, 0)
}

func (s *RuleNamedBitContext) RuleDefinedValue() IRuleDefinedValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinedValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinedValueContext)
}

func (s *RuleNamedBitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleNamedBitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleNamedBitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleNamedBit(s)
	}
}

func (s *RuleNamedBitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleNamedBit(s)
	}
}

func (s *RuleNamedBitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleNamedBit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleNamedBit() (localctx IRuleNamedBitContext) {
	this := p
	_ = this

	localctx = NewRuleNamedBitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, asn1ParserRULE_ruleNamedBit)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(974)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(964)
			p.RuleIdentifier()
		}
		{
			p.SetState(965)
			p.Match(asn1ParserROUND_START)
		}
		{
			p.SetState(966)
			p.Match(asn1ParserNUMBER)
		}
		{
			p.SetState(967)
			p.Match(asn1ParserROUND_END)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(969)
			p.RuleIdentifier()
		}
		{
			p.SetState(970)
			p.Match(asn1ParserROUND_START)
		}
		{
			p.SetState(971)
			p.RuleDefinedValue()
		}
		{
			p.SetState(972)
			p.Match(asn1ParserROUND_END)
		}

	}

	return localctx
}

// IRuleNamedBitListContext is an interface to support dynamic dispatch.
type IRuleNamedBitListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleNamedBitListContext differentiates from other interfaces.
	IsRuleNamedBitListContext()
}

type RuleNamedBitListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleNamedBitListContext() *RuleNamedBitListContext {
	var p = new(RuleNamedBitListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleNamedBitList
	return p
}

func (*RuleNamedBitListContext) IsRuleNamedBitListContext() {}

func NewRuleNamedBitListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleNamedBitListContext {
	var p = new(RuleNamedBitListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleNamedBitList

	return p
}

func (s *RuleNamedBitListContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleNamedBitListContext) RuleNamedBit() IRuleNamedBitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleNamedBitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleNamedBitContext)
}

func (s *RuleNamedBitListContext) RuleNamedBitList() IRuleNamedBitListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleNamedBitListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleNamedBitListContext)
}

func (s *RuleNamedBitListContext) COMMA() antlr.TerminalNode {
	return s.GetToken(asn1ParserCOMMA, 0)
}

func (s *RuleNamedBitListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleNamedBitListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleNamedBitListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleNamedBitList(s)
	}
}

func (s *RuleNamedBitListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleNamedBitList(s)
	}
}

func (s *RuleNamedBitListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleNamedBitList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleNamedBitList() (localctx IRuleNamedBitListContext) {
	return p.ruleNamedBitList(0)
}

func (p *asn1Parser) ruleNamedBitList(_p int) (localctx IRuleNamedBitListContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRuleNamedBitListContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRuleNamedBitListContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 132
	p.EnterRecursionRule(localctx, 132, asn1ParserRULE_ruleNamedBitList, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(977)
		p.RuleNamedBit()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(984)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewRuleNamedBitListContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, asn1ParserRULE_ruleNamedBitList)
			p.SetState(979)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(980)
				p.Match(asn1ParserCOMMA)
			}
			{
				p.SetState(981)
				p.RuleNamedBit()
			}

		}
		p.SetState(986)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext())
	}

	return localctx
}

// IRuleRestrictedCharacterStringTypeContext is an interface to support dynamic dispatch.
type IRuleRestrictedCharacterStringTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleRestrictedCharacterStringTypeContext differentiates from other interfaces.
	IsRuleRestrictedCharacterStringTypeContext()
}

type RuleRestrictedCharacterStringTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleRestrictedCharacterStringTypeContext() *RuleRestrictedCharacterStringTypeContext {
	var p = new(RuleRestrictedCharacterStringTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleRestrictedCharacterStringType
	return p
}

func (*RuleRestrictedCharacterStringTypeContext) IsRuleRestrictedCharacterStringTypeContext() {}

func NewRuleRestrictedCharacterStringTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleRestrictedCharacterStringTypeContext {
	var p = new(RuleRestrictedCharacterStringTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleRestrictedCharacterStringType

	return p
}

func (s *RuleRestrictedCharacterStringTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleRestrictedCharacterStringTypeContext) BMP_STRING_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserBMP_STRING_SYM, 0)
}

func (s *RuleRestrictedCharacterStringTypeContext) GENERAL_STRING_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserGENERAL_STRING_SYM, 0)
}

func (s *RuleRestrictedCharacterStringTypeContext) GRAPHIC_STRING_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserGRAPHIC_STRING_SYM, 0)
}

func (s *RuleRestrictedCharacterStringTypeContext) IA5_STRING_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserIA5_STRING_SYM, 0)
}

func (s *RuleRestrictedCharacterStringTypeContext) ISO646_STRING_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserISO646_STRING_SYM, 0)
}

func (s *RuleRestrictedCharacterStringTypeContext) NUMERIC_STRING_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserNUMERIC_STRING_SYM, 0)
}

func (s *RuleRestrictedCharacterStringTypeContext) PRINTABLE_STRING_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserPRINTABLE_STRING_SYM, 0)
}

func (s *RuleRestrictedCharacterStringTypeContext) TELETEX_STRING_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserTELETEX_STRING_SYM, 0)
}

func (s *RuleRestrictedCharacterStringTypeContext) T61_STRING_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserT61_STRING_SYM, 0)
}

func (s *RuleRestrictedCharacterStringTypeContext) UNIVERSAL_STRING_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserUNIVERSAL_STRING_SYM, 0)
}

func (s *RuleRestrictedCharacterStringTypeContext) UTF8_STRING_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserUTF8_STRING_SYM, 0)
}

func (s *RuleRestrictedCharacterStringTypeContext) VIDEOTEX_STRING_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserVIDEOTEX_STRING_SYM, 0)
}

func (s *RuleRestrictedCharacterStringTypeContext) VISIBLE_STRING_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserVISIBLE_STRING_SYM, 0)
}

func (s *RuleRestrictedCharacterStringTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleRestrictedCharacterStringTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleRestrictedCharacterStringTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleRestrictedCharacterStringType(s)
	}
}

func (s *RuleRestrictedCharacterStringTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleRestrictedCharacterStringType(s)
	}
}

func (s *RuleRestrictedCharacterStringTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleRestrictedCharacterStringType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleRestrictedCharacterStringType() (localctx IRuleRestrictedCharacterStringTypeContext) {
	this := p
	_ = this

	localctx = NewRuleRestrictedCharacterStringTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, asn1ParserRULE_ruleRestrictedCharacterStringType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(987)
		_la = p.GetTokenStream().LA(1)

		if !(_la == asn1ParserBMP_STRING_SYM || (((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(asn1ParserGENERAL_STRING_SYM-36))|(1<<(asn1ParserGRAPHIC_STRING_SYM-36))|(1<<(asn1ParserIA5_STRING_SYM-36))|(1<<(asn1ParserISO646_STRING_SYM-36))|(1<<(asn1ParserNUMERIC_STRING_SYM-36))|(1<<(asn1ParserPRINTABLE_STRING_SYM-36)))) != 0) || (((_la-76)&-(0x1f+1)) == 0 && ((1<<uint((_la-76)))&((1<<(asn1ParserT61_STRING_SYM-76))|(1<<(asn1ParserTELETEX_STRING_SYM-76))|(1<<(asn1ParserUNIVERSAL_STRING_SYM-76))|(1<<(asn1ParserUTF8_STRING_SYM-76))|(1<<(asn1ParserVIDEOTEX_STRING_SYM-76))|(1<<(asn1ParserVISIBLE_STRING_SYM-76)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IRuleUnrestrictedCharacterStringTypeContext is an interface to support dynamic dispatch.
type IRuleUnrestrictedCharacterStringTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleUnrestrictedCharacterStringTypeContext differentiates from other interfaces.
	IsRuleUnrestrictedCharacterStringTypeContext()
}

type RuleUnrestrictedCharacterStringTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleUnrestrictedCharacterStringTypeContext() *RuleUnrestrictedCharacterStringTypeContext {
	var p = new(RuleUnrestrictedCharacterStringTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleUnrestrictedCharacterStringType
	return p
}

func (*RuleUnrestrictedCharacterStringTypeContext) IsRuleUnrestrictedCharacterStringTypeContext() {}

func NewRuleUnrestrictedCharacterStringTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleUnrestrictedCharacterStringTypeContext {
	var p = new(RuleUnrestrictedCharacterStringTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleUnrestrictedCharacterStringType

	return p
}

func (s *RuleUnrestrictedCharacterStringTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleUnrestrictedCharacterStringTypeContext) CHARACTER_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserCHARACTER_SYM, 0)
}

func (s *RuleUnrestrictedCharacterStringTypeContext) STRING_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserSTRING_SYM, 0)
}

func (s *RuleUnrestrictedCharacterStringTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleUnrestrictedCharacterStringTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleUnrestrictedCharacterStringTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleUnrestrictedCharacterStringType(s)
	}
}

func (s *RuleUnrestrictedCharacterStringTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleUnrestrictedCharacterStringType(s)
	}
}

func (s *RuleUnrestrictedCharacterStringTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleUnrestrictedCharacterStringType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleUnrestrictedCharacterStringType() (localctx IRuleUnrestrictedCharacterStringTypeContext) {
	this := p
	_ = this

	localctx = NewRuleUnrestrictedCharacterStringTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, asn1ParserRULE_ruleUnrestrictedCharacterStringType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(989)
		p.Match(asn1ParserCHARACTER_SYM)
	}
	{
		p.SetState(990)
		p.Match(asn1ParserSTRING_SYM)
	}

	return localctx
}

// IRuleAlternativeTypeListContext is an interface to support dynamic dispatch.
type IRuleAlternativeTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleAlternativeTypeListContext differentiates from other interfaces.
	IsRuleAlternativeTypeListContext()
}

type RuleAlternativeTypeListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleAlternativeTypeListContext() *RuleAlternativeTypeListContext {
	var p = new(RuleAlternativeTypeListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleAlternativeTypeList
	return p
}

func (*RuleAlternativeTypeListContext) IsRuleAlternativeTypeListContext() {}

func NewRuleAlternativeTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleAlternativeTypeListContext {
	var p = new(RuleAlternativeTypeListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleAlternativeTypeList

	return p
}

func (s *RuleAlternativeTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleAlternativeTypeListContext) RuleNamedType() IRuleNamedTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleNamedTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleNamedTypeContext)
}

func (s *RuleAlternativeTypeListContext) RuleAlternativeTypeList() IRuleAlternativeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleAlternativeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleAlternativeTypeListContext)
}

func (s *RuleAlternativeTypeListContext) COMMA() antlr.TerminalNode {
	return s.GetToken(asn1ParserCOMMA, 0)
}

func (s *RuleAlternativeTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleAlternativeTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleAlternativeTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleAlternativeTypeList(s)
	}
}

func (s *RuleAlternativeTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleAlternativeTypeList(s)
	}
}

func (s *RuleAlternativeTypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleAlternativeTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleAlternativeTypeList() (localctx IRuleAlternativeTypeListContext) {
	return p.ruleAlternativeTypeList(0)
}

func (p *asn1Parser) ruleAlternativeTypeList(_p int) (localctx IRuleAlternativeTypeListContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRuleAlternativeTypeListContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRuleAlternativeTypeListContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 138
	p.EnterRecursionRule(localctx, 138, asn1ParserRULE_ruleAlternativeTypeList, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(993)
		p.RuleNamedType()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1000)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewRuleAlternativeTypeListContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, asn1ParserRULE_ruleAlternativeTypeList)
			p.SetState(995)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(996)
				p.Match(asn1ParserCOMMA)
			}
			{
				p.SetState(997)
				p.RuleNamedType()
			}

		}
		p.SetState(1002)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext())
	}

	return localctx
}

// IRuleRootAlternativeTypeListContext is an interface to support dynamic dispatch.
type IRuleRootAlternativeTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleRootAlternativeTypeListContext differentiates from other interfaces.
	IsRuleRootAlternativeTypeListContext()
}

type RuleRootAlternativeTypeListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleRootAlternativeTypeListContext() *RuleRootAlternativeTypeListContext {
	var p = new(RuleRootAlternativeTypeListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleRootAlternativeTypeList
	return p
}

func (*RuleRootAlternativeTypeListContext) IsRuleRootAlternativeTypeListContext() {}

func NewRuleRootAlternativeTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleRootAlternativeTypeListContext {
	var p = new(RuleRootAlternativeTypeListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleRootAlternativeTypeList

	return p
}

func (s *RuleRootAlternativeTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleRootAlternativeTypeListContext) RuleAlternativeTypeList() IRuleAlternativeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleAlternativeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleAlternativeTypeListContext)
}

func (s *RuleRootAlternativeTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleRootAlternativeTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleRootAlternativeTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleRootAlternativeTypeList(s)
	}
}

func (s *RuleRootAlternativeTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleRootAlternativeTypeList(s)
	}
}

func (s *RuleRootAlternativeTypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleRootAlternativeTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleRootAlternativeTypeList() (localctx IRuleRootAlternativeTypeListContext) {
	this := p
	_ = this

	localctx = NewRuleRootAlternativeTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, asn1ParserRULE_ruleRootAlternativeTypeList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1003)
		p.ruleAlternativeTypeList(0)
	}

	return localctx
}

// IRuleVersionNumberContext is an interface to support dynamic dispatch.
type IRuleVersionNumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleVersionNumberContext differentiates from other interfaces.
	IsRuleVersionNumberContext()
}

type RuleVersionNumberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleVersionNumberContext() *RuleVersionNumberContext {
	var p = new(RuleVersionNumberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleVersionNumber
	return p
}

func (*RuleVersionNumberContext) IsRuleVersionNumberContext() {}

func NewRuleVersionNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleVersionNumberContext {
	var p = new(RuleVersionNumberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleVersionNumber

	return p
}

func (s *RuleVersionNumberContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleVersionNumberContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(asn1ParserNUMBER, 0)
}

func (s *RuleVersionNumberContext) COLON() antlr.TerminalNode {
	return s.GetToken(asn1ParserCOLON, 0)
}

func (s *RuleVersionNumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleVersionNumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleVersionNumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleVersionNumber(s)
	}
}

func (s *RuleVersionNumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleVersionNumber(s)
	}
}

func (s *RuleVersionNumberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleVersionNumber(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleVersionNumber() (localctx IRuleVersionNumberContext) {
	this := p
	_ = this

	localctx = NewRuleVersionNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, asn1ParserRULE_ruleVersionNumber)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1008)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case asn1ParserNUMBER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1005)
			p.Match(asn1ParserNUMBER)
		}
		{
			p.SetState(1006)
			p.Match(asn1ParserCOLON)
		}

	case asn1ParserCOMPONENTS_SYM, asn1ParserLCASE_ID:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRuleExtensionAdditionAlternativesGroupContext is an interface to support dynamic dispatch.
type IRuleExtensionAdditionAlternativesGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleExtensionAdditionAlternativesGroupContext differentiates from other interfaces.
	IsRuleExtensionAdditionAlternativesGroupContext()
}

type RuleExtensionAdditionAlternativesGroupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleExtensionAdditionAlternativesGroupContext() *RuleExtensionAdditionAlternativesGroupContext {
	var p = new(RuleExtensionAdditionAlternativesGroupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleExtensionAdditionAlternativesGroup
	return p
}

func (*RuleExtensionAdditionAlternativesGroupContext) IsRuleExtensionAdditionAlternativesGroupContext() {
}

func NewRuleExtensionAdditionAlternativesGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleExtensionAdditionAlternativesGroupContext {
	var p = new(RuleExtensionAdditionAlternativesGroupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleExtensionAdditionAlternativesGroup

	return p
}

func (s *RuleExtensionAdditionAlternativesGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleExtensionAdditionAlternativesGroupContext) VERSION_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserVERSION_START, 0)
}

func (s *RuleExtensionAdditionAlternativesGroupContext) RuleVersionNumber() IRuleVersionNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleVersionNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleVersionNumberContext)
}

func (s *RuleExtensionAdditionAlternativesGroupContext) RuleAlternativeTypeList() IRuleAlternativeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleAlternativeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleAlternativeTypeListContext)
}

func (s *RuleExtensionAdditionAlternativesGroupContext) VERSION_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserVERSION_END, 0)
}

func (s *RuleExtensionAdditionAlternativesGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleExtensionAdditionAlternativesGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleExtensionAdditionAlternativesGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleExtensionAdditionAlternativesGroup(s)
	}
}

func (s *RuleExtensionAdditionAlternativesGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleExtensionAdditionAlternativesGroup(s)
	}
}

func (s *RuleExtensionAdditionAlternativesGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleExtensionAdditionAlternativesGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleExtensionAdditionAlternativesGroup() (localctx IRuleExtensionAdditionAlternativesGroupContext) {
	this := p
	_ = this

	localctx = NewRuleExtensionAdditionAlternativesGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, asn1ParserRULE_ruleExtensionAdditionAlternativesGroup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1010)
		p.Match(asn1ParserVERSION_START)
	}
	{
		p.SetState(1011)
		p.RuleVersionNumber()
	}
	{
		p.SetState(1012)
		p.ruleAlternativeTypeList(0)
	}
	{
		p.SetState(1013)
		p.Match(asn1ParserVERSION_END)
	}

	return localctx
}

// IRuleExtensionAdditionAlternativeContext is an interface to support dynamic dispatch.
type IRuleExtensionAdditionAlternativeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleExtensionAdditionAlternativeContext differentiates from other interfaces.
	IsRuleExtensionAdditionAlternativeContext()
}

type RuleExtensionAdditionAlternativeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleExtensionAdditionAlternativeContext() *RuleExtensionAdditionAlternativeContext {
	var p = new(RuleExtensionAdditionAlternativeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleExtensionAdditionAlternative
	return p
}

func (*RuleExtensionAdditionAlternativeContext) IsRuleExtensionAdditionAlternativeContext() {}

func NewRuleExtensionAdditionAlternativeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleExtensionAdditionAlternativeContext {
	var p = new(RuleExtensionAdditionAlternativeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleExtensionAdditionAlternative

	return p
}

func (s *RuleExtensionAdditionAlternativeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleExtensionAdditionAlternativeContext) RuleExtensionAdditionAlternativesGroup() IRuleExtensionAdditionAlternativesGroupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleExtensionAdditionAlternativesGroupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleExtensionAdditionAlternativesGroupContext)
}

func (s *RuleExtensionAdditionAlternativeContext) RuleNamedType() IRuleNamedTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleNamedTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleNamedTypeContext)
}

func (s *RuleExtensionAdditionAlternativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleExtensionAdditionAlternativeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleExtensionAdditionAlternativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleExtensionAdditionAlternative(s)
	}
}

func (s *RuleExtensionAdditionAlternativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleExtensionAdditionAlternative(s)
	}
}

func (s *RuleExtensionAdditionAlternativeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleExtensionAdditionAlternative(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleExtensionAdditionAlternative() (localctx IRuleExtensionAdditionAlternativeContext) {
	this := p
	_ = this

	localctx = NewRuleExtensionAdditionAlternativeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, asn1ParserRULE_ruleExtensionAdditionAlternative)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1017)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case asn1ParserVERSION_START:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1015)
			p.RuleExtensionAdditionAlternativesGroup()
		}

	case asn1ParserLCASE_ID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1016)
			p.RuleNamedType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRuleExtensionAdditionAlternativesListContext is an interface to support dynamic dispatch.
type IRuleExtensionAdditionAlternativesListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleExtensionAdditionAlternativesListContext differentiates from other interfaces.
	IsRuleExtensionAdditionAlternativesListContext()
}

type RuleExtensionAdditionAlternativesListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleExtensionAdditionAlternativesListContext() *RuleExtensionAdditionAlternativesListContext {
	var p = new(RuleExtensionAdditionAlternativesListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleExtensionAdditionAlternativesList
	return p
}

func (*RuleExtensionAdditionAlternativesListContext) IsRuleExtensionAdditionAlternativesListContext() {
}

func NewRuleExtensionAdditionAlternativesListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleExtensionAdditionAlternativesListContext {
	var p = new(RuleExtensionAdditionAlternativesListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleExtensionAdditionAlternativesList

	return p
}

func (s *RuleExtensionAdditionAlternativesListContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleExtensionAdditionAlternativesListContext) RuleExtensionAdditionAlternative() IRuleExtensionAdditionAlternativeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleExtensionAdditionAlternativeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleExtensionAdditionAlternativeContext)
}

func (s *RuleExtensionAdditionAlternativesListContext) RuleExtensionAdditionAlternativesList() IRuleExtensionAdditionAlternativesListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleExtensionAdditionAlternativesListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleExtensionAdditionAlternativesListContext)
}

func (s *RuleExtensionAdditionAlternativesListContext) COMMA() antlr.TerminalNode {
	return s.GetToken(asn1ParserCOMMA, 0)
}

func (s *RuleExtensionAdditionAlternativesListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleExtensionAdditionAlternativesListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleExtensionAdditionAlternativesListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleExtensionAdditionAlternativesList(s)
	}
}

func (s *RuleExtensionAdditionAlternativesListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleExtensionAdditionAlternativesList(s)
	}
}

func (s *RuleExtensionAdditionAlternativesListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleExtensionAdditionAlternativesList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleExtensionAdditionAlternativesList() (localctx IRuleExtensionAdditionAlternativesListContext) {
	return p.ruleExtensionAdditionAlternativesList(0)
}

func (p *asn1Parser) ruleExtensionAdditionAlternativesList(_p int) (localctx IRuleExtensionAdditionAlternativesListContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRuleExtensionAdditionAlternativesListContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRuleExtensionAdditionAlternativesListContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 148
	p.EnterRecursionRule(localctx, 148, asn1ParserRULE_ruleExtensionAdditionAlternativesList, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1020)
		p.RuleExtensionAdditionAlternative()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1027)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 32, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewRuleExtensionAdditionAlternativesListContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, asn1ParserRULE_ruleExtensionAdditionAlternativesList)
			p.SetState(1022)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(1023)
				p.Match(asn1ParserCOMMA)
			}
			{
				p.SetState(1024)
				p.RuleExtensionAdditionAlternative()
			}

		}
		p.SetState(1029)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 32, p.GetParserRuleContext())
	}

	return localctx
}

// IRuleExtensionAdditionAlternativesContext is an interface to support dynamic dispatch.
type IRuleExtensionAdditionAlternativesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleExtensionAdditionAlternativesContext differentiates from other interfaces.
	IsRuleExtensionAdditionAlternativesContext()
}

type RuleExtensionAdditionAlternativesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleExtensionAdditionAlternativesContext() *RuleExtensionAdditionAlternativesContext {
	var p = new(RuleExtensionAdditionAlternativesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleExtensionAdditionAlternatives
	return p
}

func (*RuleExtensionAdditionAlternativesContext) IsRuleExtensionAdditionAlternativesContext() {}

func NewRuleExtensionAdditionAlternativesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleExtensionAdditionAlternativesContext {
	var p = new(RuleExtensionAdditionAlternativesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleExtensionAdditionAlternatives

	return p
}

func (s *RuleExtensionAdditionAlternativesContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleExtensionAdditionAlternativesContext) COMMA() antlr.TerminalNode {
	return s.GetToken(asn1ParserCOMMA, 0)
}

func (s *RuleExtensionAdditionAlternativesContext) RuleExtensionAdditionAlternativesList() IRuleExtensionAdditionAlternativesListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleExtensionAdditionAlternativesListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleExtensionAdditionAlternativesListContext)
}

func (s *RuleExtensionAdditionAlternativesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleExtensionAdditionAlternativesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleExtensionAdditionAlternativesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleExtensionAdditionAlternatives(s)
	}
}

func (s *RuleExtensionAdditionAlternativesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleExtensionAdditionAlternatives(s)
	}
}

func (s *RuleExtensionAdditionAlternativesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleExtensionAdditionAlternatives(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleExtensionAdditionAlternatives() (localctx IRuleExtensionAdditionAlternativesContext) {
	this := p
	_ = this

	localctx = NewRuleExtensionAdditionAlternativesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, asn1ParserRULE_ruleExtensionAdditionAlternatives)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1033)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1030)
			p.Match(asn1ParserCOMMA)
		}
		{
			p.SetState(1031)
			p.ruleExtensionAdditionAlternativesList(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)

	}

	return localctx
}

// IRuleEnumerationItemContext is an interface to support dynamic dispatch.
type IRuleEnumerationItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleEnumerationItemContext differentiates from other interfaces.
	IsRuleEnumerationItemContext()
}

type RuleEnumerationItemContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleEnumerationItemContext() *RuleEnumerationItemContext {
	var p = new(RuleEnumerationItemContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleEnumerationItem
	return p
}

func (*RuleEnumerationItemContext) IsRuleEnumerationItemContext() {}

func NewRuleEnumerationItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleEnumerationItemContext {
	var p = new(RuleEnumerationItemContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleEnumerationItem

	return p
}

func (s *RuleEnumerationItemContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleEnumerationItemContext) RuleNamedNumber() IRuleNamedNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleNamedNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleNamedNumberContext)
}

func (s *RuleEnumerationItemContext) RuleIdentifier() IRuleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleIdentifierContext)
}

func (s *RuleEnumerationItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleEnumerationItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleEnumerationItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleEnumerationItem(s)
	}
}

func (s *RuleEnumerationItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleEnumerationItem(s)
	}
}

func (s *RuleEnumerationItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleEnumerationItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleEnumerationItem() (localctx IRuleEnumerationItemContext) {
	this := p
	_ = this

	localctx = NewRuleEnumerationItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, asn1ParserRULE_ruleEnumerationItem)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1037)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1035)
			p.RuleNamedNumber()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1036)
			p.RuleIdentifier()
		}

	}

	return localctx
}

// IRuleEnumerationContext is an interface to support dynamic dispatch.
type IRuleEnumerationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleEnumerationContext differentiates from other interfaces.
	IsRuleEnumerationContext()
}

type RuleEnumerationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleEnumerationContext() *RuleEnumerationContext {
	var p = new(RuleEnumerationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleEnumeration
	return p
}

func (*RuleEnumerationContext) IsRuleEnumerationContext() {}

func NewRuleEnumerationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleEnumerationContext {
	var p = new(RuleEnumerationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleEnumeration

	return p
}

func (s *RuleEnumerationContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleEnumerationContext) RuleEnumerationItem() IRuleEnumerationItemContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleEnumerationItemContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleEnumerationItemContext)
}

func (s *RuleEnumerationContext) RuleEnumeration() IRuleEnumerationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleEnumerationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleEnumerationContext)
}

func (s *RuleEnumerationContext) COMMA() antlr.TerminalNode {
	return s.GetToken(asn1ParserCOMMA, 0)
}

func (s *RuleEnumerationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleEnumerationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleEnumerationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleEnumeration(s)
	}
}

func (s *RuleEnumerationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleEnumeration(s)
	}
}

func (s *RuleEnumerationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleEnumeration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleEnumeration() (localctx IRuleEnumerationContext) {
	return p.ruleEnumeration(0)
}

func (p *asn1Parser) ruleEnumeration(_p int) (localctx IRuleEnumerationContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRuleEnumerationContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRuleEnumerationContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 154
	p.EnterRecursionRule(localctx, 154, asn1ParserRULE_ruleEnumeration, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1040)
		p.RuleEnumerationItem()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1047)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewRuleEnumerationContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, asn1ParserRULE_ruleEnumeration)
			p.SetState(1042)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(1043)
				p.Match(asn1ParserCOMMA)
			}
			{
				p.SetState(1044)
				p.RuleEnumerationItem()
			}

		}
		p.SetState(1049)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext())
	}

	return localctx
}

// IRuleRootEnumerationContext is an interface to support dynamic dispatch.
type IRuleRootEnumerationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleRootEnumerationContext differentiates from other interfaces.
	IsRuleRootEnumerationContext()
}

type RuleRootEnumerationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleRootEnumerationContext() *RuleRootEnumerationContext {
	var p = new(RuleRootEnumerationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleRootEnumeration
	return p
}

func (*RuleRootEnumerationContext) IsRuleRootEnumerationContext() {}

func NewRuleRootEnumerationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleRootEnumerationContext {
	var p = new(RuleRootEnumerationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleRootEnumeration

	return p
}

func (s *RuleRootEnumerationContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleRootEnumerationContext) RuleEnumeration() IRuleEnumerationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleEnumerationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleEnumerationContext)
}

func (s *RuleRootEnumerationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleRootEnumerationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleRootEnumerationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleRootEnumeration(s)
	}
}

func (s *RuleRootEnumerationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleRootEnumeration(s)
	}
}

func (s *RuleRootEnumerationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleRootEnumeration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleRootEnumeration() (localctx IRuleRootEnumerationContext) {
	this := p
	_ = this

	localctx = NewRuleRootEnumerationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, asn1ParserRULE_ruleRootEnumeration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1050)
		p.ruleEnumeration(0)
	}

	return localctx
}

// IRuleAdditionalEnumerationContext is an interface to support dynamic dispatch.
type IRuleAdditionalEnumerationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleAdditionalEnumerationContext differentiates from other interfaces.
	IsRuleAdditionalEnumerationContext()
}

type RuleAdditionalEnumerationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleAdditionalEnumerationContext() *RuleAdditionalEnumerationContext {
	var p = new(RuleAdditionalEnumerationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleAdditionalEnumeration
	return p
}

func (*RuleAdditionalEnumerationContext) IsRuleAdditionalEnumerationContext() {}

func NewRuleAdditionalEnumerationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleAdditionalEnumerationContext {
	var p = new(RuleAdditionalEnumerationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleAdditionalEnumeration

	return p
}

func (s *RuleAdditionalEnumerationContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleAdditionalEnumerationContext) RuleEnumeration() IRuleEnumerationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleEnumerationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleEnumerationContext)
}

func (s *RuleAdditionalEnumerationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleAdditionalEnumerationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleAdditionalEnumerationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleAdditionalEnumeration(s)
	}
}

func (s *RuleAdditionalEnumerationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleAdditionalEnumeration(s)
	}
}

func (s *RuleAdditionalEnumerationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleAdditionalEnumeration(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleAdditionalEnumeration() (localctx IRuleAdditionalEnumerationContext) {
	this := p
	_ = this

	localctx = NewRuleAdditionalEnumerationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, asn1ParserRULE_ruleAdditionalEnumeration)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1052)
		p.ruleEnumeration(0)
	}

	return localctx
}

// IRuleAlternativeTypeListsContext is an interface to support dynamic dispatch.
type IRuleAlternativeTypeListsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleAlternativeTypeListsContext differentiates from other interfaces.
	IsRuleAlternativeTypeListsContext()
}

type RuleAlternativeTypeListsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleAlternativeTypeListsContext() *RuleAlternativeTypeListsContext {
	var p = new(RuleAlternativeTypeListsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleAlternativeTypeLists
	return p
}

func (*RuleAlternativeTypeListsContext) IsRuleAlternativeTypeListsContext() {}

func NewRuleAlternativeTypeListsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleAlternativeTypeListsContext {
	var p = new(RuleAlternativeTypeListsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleAlternativeTypeLists

	return p
}

func (s *RuleAlternativeTypeListsContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleAlternativeTypeListsContext) RuleRootAlternativeTypeList() IRuleRootAlternativeTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleRootAlternativeTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleRootAlternativeTypeListContext)
}

func (s *RuleAlternativeTypeListsContext) COMMA() antlr.TerminalNode {
	return s.GetToken(asn1ParserCOMMA, 0)
}

func (s *RuleAlternativeTypeListsContext) RuleExtensionAndException() IRuleExtensionAndExceptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleExtensionAndExceptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleExtensionAndExceptionContext)
}

func (s *RuleAlternativeTypeListsContext) RuleExtensionAdditionAlternatives() IRuleExtensionAdditionAlternativesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleExtensionAdditionAlternativesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleExtensionAdditionAlternativesContext)
}

func (s *RuleAlternativeTypeListsContext) RuleOptionalExtensionMarker() IRuleOptionalExtensionMarkerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleOptionalExtensionMarkerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleOptionalExtensionMarkerContext)
}

func (s *RuleAlternativeTypeListsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleAlternativeTypeListsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleAlternativeTypeListsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleAlternativeTypeLists(s)
	}
}

func (s *RuleAlternativeTypeListsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleAlternativeTypeLists(s)
	}
}

func (s *RuleAlternativeTypeListsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleAlternativeTypeLists(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleAlternativeTypeLists() (localctx IRuleAlternativeTypeListsContext) {
	this := p
	_ = this

	localctx = NewRuleAlternativeTypeListsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, asn1ParserRULE_ruleAlternativeTypeLists)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1061)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1054)
			p.RuleRootAlternativeTypeList()
		}
		{
			p.SetState(1055)
			p.Match(asn1ParserCOMMA)
		}
		{
			p.SetState(1056)
			p.RuleExtensionAndException()
		}
		{
			p.SetState(1057)
			p.RuleExtensionAdditionAlternatives()
		}
		{
			p.SetState(1058)
			p.RuleOptionalExtensionMarker()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1060)
			p.RuleRootAlternativeTypeList()
		}

	}

	return localctx
}

// IRuleEnumerationsContext is an interface to support dynamic dispatch.
type IRuleEnumerationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleEnumerationsContext differentiates from other interfaces.
	IsRuleEnumerationsContext()
}

type RuleEnumerationsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleEnumerationsContext() *RuleEnumerationsContext {
	var p = new(RuleEnumerationsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleEnumerations
	return p
}

func (*RuleEnumerationsContext) IsRuleEnumerationsContext() {}

func NewRuleEnumerationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleEnumerationsContext {
	var p = new(RuleEnumerationsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleEnumerations

	return p
}

func (s *RuleEnumerationsContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleEnumerationsContext) RuleRootEnumeration() IRuleRootEnumerationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleRootEnumerationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleRootEnumerationContext)
}

func (s *RuleEnumerationsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(asn1ParserCOMMA)
}

func (s *RuleEnumerationsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(asn1ParserCOMMA, i)
}

func (s *RuleEnumerationsContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(asn1ParserELLIPSIS, 0)
}

func (s *RuleEnumerationsContext) RuleExceptionSpec() IRuleExceptionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleExceptionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleExceptionSpecContext)
}

func (s *RuleEnumerationsContext) RuleAdditionalEnumeration() IRuleAdditionalEnumerationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleAdditionalEnumerationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleAdditionalEnumerationContext)
}

func (s *RuleEnumerationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleEnumerationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleEnumerationsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleEnumerations(s)
	}
}

func (s *RuleEnumerationsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleEnumerations(s)
	}
}

func (s *RuleEnumerationsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleEnumerations(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleEnumerations() (localctx IRuleEnumerationsContext) {
	this := p
	_ = this

	localctx = NewRuleEnumerationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, asn1ParserRULE_ruleEnumerations)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1076)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1063)
			p.RuleRootEnumeration()
		}
		{
			p.SetState(1064)
			p.Match(asn1ParserCOMMA)
		}
		{
			p.SetState(1065)
			p.Match(asn1ParserELLIPSIS)
		}
		{
			p.SetState(1066)
			p.RuleExceptionSpec()
		}
		{
			p.SetState(1067)
			p.Match(asn1ParserCOMMA)
		}
		{
			p.SetState(1068)
			p.RuleAdditionalEnumeration()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1070)
			p.RuleRootEnumeration()
		}
		{
			p.SetState(1071)
			p.Match(asn1ParserCOMMA)
		}
		{
			p.SetState(1072)
			p.Match(asn1ParserELLIPSIS)
		}
		{
			p.SetState(1073)
			p.RuleExceptionSpec()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1075)
			p.RuleRootEnumeration()
		}

	}

	return localctx
}

// IRuleNamedNumberContext is an interface to support dynamic dispatch.
type IRuleNamedNumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleNamedNumberContext differentiates from other interfaces.
	IsRuleNamedNumberContext()
}

type RuleNamedNumberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleNamedNumberContext() *RuleNamedNumberContext {
	var p = new(RuleNamedNumberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleNamedNumber
	return p
}

func (*RuleNamedNumberContext) IsRuleNamedNumberContext() {}

func NewRuleNamedNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleNamedNumberContext {
	var p = new(RuleNamedNumberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleNamedNumber

	return p
}

func (s *RuleNamedNumberContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleNamedNumberContext) RuleIdentifier() IRuleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleIdentifierContext)
}

func (s *RuleNamedNumberContext) ROUND_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserROUND_START, 0)
}

func (s *RuleNamedNumberContext) RuleSignedNumber() IRuleSignedNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSignedNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSignedNumberContext)
}

func (s *RuleNamedNumberContext) ROUND_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserROUND_END, 0)
}

func (s *RuleNamedNumberContext) RuleDefinedValue() IRuleDefinedValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinedValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinedValueContext)
}

func (s *RuleNamedNumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleNamedNumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleNamedNumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleNamedNumber(s)
	}
}

func (s *RuleNamedNumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleNamedNumber(s)
	}
}

func (s *RuleNamedNumberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleNamedNumber(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleNamedNumber() (localctx IRuleNamedNumberContext) {
	this := p
	_ = this

	localctx = NewRuleNamedNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, asn1ParserRULE_ruleNamedNumber)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1088)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1078)
			p.RuleIdentifier()
		}
		{
			p.SetState(1079)
			p.Match(asn1ParserROUND_START)
		}
		{
			p.SetState(1080)
			p.RuleSignedNumber()
		}
		{
			p.SetState(1081)
			p.Match(asn1ParserROUND_END)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1083)
			p.RuleIdentifier()
		}
		{
			p.SetState(1084)
			p.Match(asn1ParserROUND_START)
		}
		{
			p.SetState(1085)
			p.RuleDefinedValue()
		}
		{
			p.SetState(1086)
			p.Match(asn1ParserROUND_END)
		}

	}

	return localctx
}

// IRuleNamedNumberListContext is an interface to support dynamic dispatch.
type IRuleNamedNumberListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleNamedNumberListContext differentiates from other interfaces.
	IsRuleNamedNumberListContext()
}

type RuleNamedNumberListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleNamedNumberListContext() *RuleNamedNumberListContext {
	var p = new(RuleNamedNumberListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleNamedNumberList
	return p
}

func (*RuleNamedNumberListContext) IsRuleNamedNumberListContext() {}

func NewRuleNamedNumberListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleNamedNumberListContext {
	var p = new(RuleNamedNumberListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleNamedNumberList

	return p
}

func (s *RuleNamedNumberListContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleNamedNumberListContext) RuleNamedNumber() IRuleNamedNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleNamedNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleNamedNumberContext)
}

func (s *RuleNamedNumberListContext) RuleNamedNumberList() IRuleNamedNumberListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleNamedNumberListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleNamedNumberListContext)
}

func (s *RuleNamedNumberListContext) COMMA() antlr.TerminalNode {
	return s.GetToken(asn1ParserCOMMA, 0)
}

func (s *RuleNamedNumberListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleNamedNumberListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleNamedNumberListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleNamedNumberList(s)
	}
}

func (s *RuleNamedNumberListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleNamedNumberList(s)
	}
}

func (s *RuleNamedNumberListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleNamedNumberList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleNamedNumberList() (localctx IRuleNamedNumberListContext) {
	return p.ruleNamedNumberList(0)
}

func (p *asn1Parser) ruleNamedNumberList(_p int) (localctx IRuleNamedNumberListContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRuleNamedNumberListContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRuleNamedNumberListContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 166
	p.EnterRecursionRule(localctx, 166, asn1ParserRULE_ruleNamedNumberList, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1091)
		p.RuleNamedNumber()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1098)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewRuleNamedNumberListContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, asn1ParserRULE_ruleNamedNumberList)
			p.SetState(1093)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(1094)
				p.Match(asn1ParserCOMMA)
			}
			{
				p.SetState(1095)
				p.RuleNamedNumber()
			}

		}
		p.SetState(1100)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext())
	}

	return localctx
}

// IRuleComponentTypeContext is an interface to support dynamic dispatch.
type IRuleComponentTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleComponentTypeContext differentiates from other interfaces.
	IsRuleComponentTypeContext()
}

type RuleComponentTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleComponentTypeContext() *RuleComponentTypeContext {
	var p = new(RuleComponentTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleComponentType
	return p
}

func (*RuleComponentTypeContext) IsRuleComponentTypeContext() {}

func NewRuleComponentTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleComponentTypeContext {
	var p = new(RuleComponentTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleComponentType

	return p
}

func (s *RuleComponentTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleComponentTypeContext) COMPONENTS_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserCOMPONENTS_SYM, 0)
}

func (s *RuleComponentTypeContext) OF_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserOF_SYM, 0)
}

func (s *RuleComponentTypeContext) RuleType() IRuleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeContext)
}

func (s *RuleComponentTypeContext) RuleNamedType() IRuleNamedTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleNamedTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleNamedTypeContext)
}

func (s *RuleComponentTypeContext) DEFAULT_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserDEFAULT_SYM, 0)
}

func (s *RuleComponentTypeContext) RuleValue() IRuleValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueContext)
}

func (s *RuleComponentTypeContext) OPTIONAL_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserOPTIONAL_SYM, 0)
}

func (s *RuleComponentTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleComponentTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleComponentTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleComponentType(s)
	}
}

func (s *RuleComponentTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleComponentType(s)
	}
}

func (s *RuleComponentTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleComponentType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleComponentType() (localctx IRuleComponentTypeContext) {
	this := p
	_ = this

	localctx = NewRuleComponentTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, asn1ParserRULE_ruleComponentType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1112)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1101)
			p.Match(asn1ParserCOMPONENTS_SYM)
		}
		{
			p.SetState(1102)
			p.Match(asn1ParserOF_SYM)
		}
		{
			p.SetState(1103)
			p.RuleType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1104)
			p.RuleNamedType()
		}
		{
			p.SetState(1105)
			p.Match(asn1ParserDEFAULT_SYM)
		}
		{
			p.SetState(1106)
			p.RuleValue()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1108)
			p.RuleNamedType()
		}
		{
			p.SetState(1109)
			p.Match(asn1ParserOPTIONAL_SYM)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1111)
			p.RuleNamedType()
		}

	}

	return localctx
}

// IRuleExtensionAdditionGroupContext is an interface to support dynamic dispatch.
type IRuleExtensionAdditionGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleExtensionAdditionGroupContext differentiates from other interfaces.
	IsRuleExtensionAdditionGroupContext()
}

type RuleExtensionAdditionGroupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleExtensionAdditionGroupContext() *RuleExtensionAdditionGroupContext {
	var p = new(RuleExtensionAdditionGroupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleExtensionAdditionGroup
	return p
}

func (*RuleExtensionAdditionGroupContext) IsRuleExtensionAdditionGroupContext() {}

func NewRuleExtensionAdditionGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleExtensionAdditionGroupContext {
	var p = new(RuleExtensionAdditionGroupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleExtensionAdditionGroup

	return p
}

func (s *RuleExtensionAdditionGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleExtensionAdditionGroupContext) VERSION_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserVERSION_START, 0)
}

func (s *RuleExtensionAdditionGroupContext) RuleVersionNumber() IRuleVersionNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleVersionNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleVersionNumberContext)
}

func (s *RuleExtensionAdditionGroupContext) RuleComponentTypeList() IRuleComponentTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleComponentTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleComponentTypeListContext)
}

func (s *RuleExtensionAdditionGroupContext) VERSION_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserVERSION_END, 0)
}

func (s *RuleExtensionAdditionGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleExtensionAdditionGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleExtensionAdditionGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleExtensionAdditionGroup(s)
	}
}

func (s *RuleExtensionAdditionGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleExtensionAdditionGroup(s)
	}
}

func (s *RuleExtensionAdditionGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleExtensionAdditionGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleExtensionAdditionGroup() (localctx IRuleExtensionAdditionGroupContext) {
	this := p
	_ = this

	localctx = NewRuleExtensionAdditionGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, asn1ParserRULE_ruleExtensionAdditionGroup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1114)
		p.Match(asn1ParserVERSION_START)
	}
	{
		p.SetState(1115)
		p.RuleVersionNumber()
	}
	{
		p.SetState(1116)
		p.ruleComponentTypeList(0)
	}
	{
		p.SetState(1117)
		p.Match(asn1ParserVERSION_END)
	}

	return localctx
}

// IRuleExtensionAdditionContext is an interface to support dynamic dispatch.
type IRuleExtensionAdditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleExtensionAdditionContext differentiates from other interfaces.
	IsRuleExtensionAdditionContext()
}

type RuleExtensionAdditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleExtensionAdditionContext() *RuleExtensionAdditionContext {
	var p = new(RuleExtensionAdditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleExtensionAddition
	return p
}

func (*RuleExtensionAdditionContext) IsRuleExtensionAdditionContext() {}

func NewRuleExtensionAdditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleExtensionAdditionContext {
	var p = new(RuleExtensionAdditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleExtensionAddition

	return p
}

func (s *RuleExtensionAdditionContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleExtensionAdditionContext) RuleComponentType() IRuleComponentTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleComponentTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleComponentTypeContext)
}

func (s *RuleExtensionAdditionContext) RuleExtensionAdditionGroup() IRuleExtensionAdditionGroupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleExtensionAdditionGroupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleExtensionAdditionGroupContext)
}

func (s *RuleExtensionAdditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleExtensionAdditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleExtensionAdditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleExtensionAddition(s)
	}
}

func (s *RuleExtensionAdditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleExtensionAddition(s)
	}
}

func (s *RuleExtensionAdditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleExtensionAddition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleExtensionAddition() (localctx IRuleExtensionAdditionContext) {
	this := p
	_ = this

	localctx = NewRuleExtensionAdditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, asn1ParserRULE_ruleExtensionAddition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1121)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case asn1ParserCOMPONENTS_SYM, asn1ParserLCASE_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1119)
			p.RuleComponentType()
		}

	case asn1ParserVERSION_START:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1120)
			p.RuleExtensionAdditionGroup()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRuleComponentTypeListContext is an interface to support dynamic dispatch.
type IRuleComponentTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleComponentTypeListContext differentiates from other interfaces.
	IsRuleComponentTypeListContext()
}

type RuleComponentTypeListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleComponentTypeListContext() *RuleComponentTypeListContext {
	var p = new(RuleComponentTypeListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleComponentTypeList
	return p
}

func (*RuleComponentTypeListContext) IsRuleComponentTypeListContext() {}

func NewRuleComponentTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleComponentTypeListContext {
	var p = new(RuleComponentTypeListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleComponentTypeList

	return p
}

func (s *RuleComponentTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleComponentTypeListContext) RuleComponentType() IRuleComponentTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleComponentTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleComponentTypeContext)
}

func (s *RuleComponentTypeListContext) RuleComponentTypeList() IRuleComponentTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleComponentTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleComponentTypeListContext)
}

func (s *RuleComponentTypeListContext) COMMA() antlr.TerminalNode {
	return s.GetToken(asn1ParserCOMMA, 0)
}

func (s *RuleComponentTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleComponentTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleComponentTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleComponentTypeList(s)
	}
}

func (s *RuleComponentTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleComponentTypeList(s)
	}
}

func (s *RuleComponentTypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleComponentTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleComponentTypeList() (localctx IRuleComponentTypeListContext) {
	return p.ruleComponentTypeList(0)
}

func (p *asn1Parser) ruleComponentTypeList(_p int) (localctx IRuleComponentTypeListContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRuleComponentTypeListContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRuleComponentTypeListContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 174
	p.EnterRecursionRule(localctx, 174, asn1ParserRULE_ruleComponentTypeList, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1124)
		p.RuleComponentType()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1131)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 42, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewRuleComponentTypeListContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, asn1ParserRULE_ruleComponentTypeList)
			p.SetState(1126)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(1127)
				p.Match(asn1ParserCOMMA)
			}
			{
				p.SetState(1128)
				p.RuleComponentType()
			}

		}
		p.SetState(1133)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 42, p.GetParserRuleContext())
	}

	return localctx
}

// IRuleExtensionAdditionListContext is an interface to support dynamic dispatch.
type IRuleExtensionAdditionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleExtensionAdditionListContext differentiates from other interfaces.
	IsRuleExtensionAdditionListContext()
}

type RuleExtensionAdditionListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleExtensionAdditionListContext() *RuleExtensionAdditionListContext {
	var p = new(RuleExtensionAdditionListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleExtensionAdditionList
	return p
}

func (*RuleExtensionAdditionListContext) IsRuleExtensionAdditionListContext() {}

func NewRuleExtensionAdditionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleExtensionAdditionListContext {
	var p = new(RuleExtensionAdditionListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleExtensionAdditionList

	return p
}

func (s *RuleExtensionAdditionListContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleExtensionAdditionListContext) RuleExtensionAddition() IRuleExtensionAdditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleExtensionAdditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleExtensionAdditionContext)
}

func (s *RuleExtensionAdditionListContext) RuleExtensionAdditionList() IRuleExtensionAdditionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleExtensionAdditionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleExtensionAdditionListContext)
}

func (s *RuleExtensionAdditionListContext) COMMA() antlr.TerminalNode {
	return s.GetToken(asn1ParserCOMMA, 0)
}

func (s *RuleExtensionAdditionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleExtensionAdditionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleExtensionAdditionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleExtensionAdditionList(s)
	}
}

func (s *RuleExtensionAdditionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleExtensionAdditionList(s)
	}
}

func (s *RuleExtensionAdditionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleExtensionAdditionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleExtensionAdditionList() (localctx IRuleExtensionAdditionListContext) {
	return p.ruleExtensionAdditionList(0)
}

func (p *asn1Parser) ruleExtensionAdditionList(_p int) (localctx IRuleExtensionAdditionListContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRuleExtensionAdditionListContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRuleExtensionAdditionListContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 176
	p.EnterRecursionRule(localctx, 176, asn1ParserRULE_ruleExtensionAdditionList, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1135)
		p.RuleExtensionAddition()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1142)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewRuleExtensionAdditionListContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, asn1ParserRULE_ruleExtensionAdditionList)
			p.SetState(1137)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(1138)
				p.Match(asn1ParserCOMMA)
			}
			{
				p.SetState(1139)
				p.RuleExtensionAddition()
			}

		}
		p.SetState(1144)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext())
	}

	return localctx
}

// IRuleRootComponentTypeListContext is an interface to support dynamic dispatch.
type IRuleRootComponentTypeListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleRootComponentTypeListContext differentiates from other interfaces.
	IsRuleRootComponentTypeListContext()
}

type RuleRootComponentTypeListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleRootComponentTypeListContext() *RuleRootComponentTypeListContext {
	var p = new(RuleRootComponentTypeListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleRootComponentTypeList
	return p
}

func (*RuleRootComponentTypeListContext) IsRuleRootComponentTypeListContext() {}

func NewRuleRootComponentTypeListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleRootComponentTypeListContext {
	var p = new(RuleRootComponentTypeListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleRootComponentTypeList

	return p
}

func (s *RuleRootComponentTypeListContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleRootComponentTypeListContext) RuleComponentTypeList() IRuleComponentTypeListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleComponentTypeListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleComponentTypeListContext)
}

func (s *RuleRootComponentTypeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleRootComponentTypeListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleRootComponentTypeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleRootComponentTypeList(s)
	}
}

func (s *RuleRootComponentTypeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleRootComponentTypeList(s)
	}
}

func (s *RuleRootComponentTypeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleRootComponentTypeList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleRootComponentTypeList() (localctx IRuleRootComponentTypeListContext) {
	this := p
	_ = this

	localctx = NewRuleRootComponentTypeListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, asn1ParserRULE_ruleRootComponentTypeList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1145)
		p.ruleComponentTypeList(0)
	}

	return localctx
}

// IRuleExtensionAdditionsContext is an interface to support dynamic dispatch.
type IRuleExtensionAdditionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleExtensionAdditionsContext differentiates from other interfaces.
	IsRuleExtensionAdditionsContext()
}

type RuleExtensionAdditionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleExtensionAdditionsContext() *RuleExtensionAdditionsContext {
	var p = new(RuleExtensionAdditionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleExtensionAdditions
	return p
}

func (*RuleExtensionAdditionsContext) IsRuleExtensionAdditionsContext() {}

func NewRuleExtensionAdditionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleExtensionAdditionsContext {
	var p = new(RuleExtensionAdditionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleExtensionAdditions

	return p
}

func (s *RuleExtensionAdditionsContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleExtensionAdditionsContext) COMMA() antlr.TerminalNode {
	return s.GetToken(asn1ParserCOMMA, 0)
}

func (s *RuleExtensionAdditionsContext) RuleExtensionAdditionList() IRuleExtensionAdditionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleExtensionAdditionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleExtensionAdditionListContext)
}

func (s *RuleExtensionAdditionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleExtensionAdditionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleExtensionAdditionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleExtensionAdditions(s)
	}
}

func (s *RuleExtensionAdditionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleExtensionAdditions(s)
	}
}

func (s *RuleExtensionAdditionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleExtensionAdditions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleExtensionAdditions() (localctx IRuleExtensionAdditionsContext) {
	this := p
	_ = this

	localctx = NewRuleExtensionAdditionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, asn1ParserRULE_ruleExtensionAdditions)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1150)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1147)
			p.Match(asn1ParserCOMMA)
		}
		{
			p.SetState(1148)
			p.ruleExtensionAdditionList(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)

	}

	return localctx
}

// IRuleExtensionEndMarkerContext is an interface to support dynamic dispatch.
type IRuleExtensionEndMarkerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleExtensionEndMarkerContext differentiates from other interfaces.
	IsRuleExtensionEndMarkerContext()
}

type RuleExtensionEndMarkerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleExtensionEndMarkerContext() *RuleExtensionEndMarkerContext {
	var p = new(RuleExtensionEndMarkerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleExtensionEndMarker
	return p
}

func (*RuleExtensionEndMarkerContext) IsRuleExtensionEndMarkerContext() {}

func NewRuleExtensionEndMarkerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleExtensionEndMarkerContext {
	var p = new(RuleExtensionEndMarkerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleExtensionEndMarker

	return p
}

func (s *RuleExtensionEndMarkerContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleExtensionEndMarkerContext) COMMA() antlr.TerminalNode {
	return s.GetToken(asn1ParserCOMMA, 0)
}

func (s *RuleExtensionEndMarkerContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(asn1ParserELLIPSIS, 0)
}

func (s *RuleExtensionEndMarkerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleExtensionEndMarkerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleExtensionEndMarkerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleExtensionEndMarker(s)
	}
}

func (s *RuleExtensionEndMarkerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleExtensionEndMarker(s)
	}
}

func (s *RuleExtensionEndMarkerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleExtensionEndMarker(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleExtensionEndMarker() (localctx IRuleExtensionEndMarkerContext) {
	this := p
	_ = this

	localctx = NewRuleExtensionEndMarkerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, asn1ParserRULE_ruleExtensionEndMarker)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1152)
		p.Match(asn1ParserCOMMA)
	}
	{
		p.SetState(1153)
		p.Match(asn1ParserELLIPSIS)
	}

	return localctx
}

// IRuleComponentTypeListsContext is an interface to support dynamic dispatch.
type IRuleComponentTypeListsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleComponentTypeListsContext differentiates from other interfaces.
	IsRuleComponentTypeListsContext()
}

type RuleComponentTypeListsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleComponentTypeListsContext() *RuleComponentTypeListsContext {
	var p = new(RuleComponentTypeListsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleComponentTypeLists
	return p
}

func (*RuleComponentTypeListsContext) IsRuleComponentTypeListsContext() {}

func NewRuleComponentTypeListsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleComponentTypeListsContext {
	var p = new(RuleComponentTypeListsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleComponentTypeLists

	return p
}

func (s *RuleComponentTypeListsContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleComponentTypeListsContext) AllRuleRootComponentTypeList() []IRuleRootComponentTypeListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRuleRootComponentTypeListContext); ok {
			len++
		}
	}

	tst := make([]IRuleRootComponentTypeListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRuleRootComponentTypeListContext); ok {
			tst[i] = t.(IRuleRootComponentTypeListContext)
			i++
		}
	}

	return tst
}

func (s *RuleComponentTypeListsContext) RuleRootComponentTypeList(i int) IRuleRootComponentTypeListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleRootComponentTypeListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleRootComponentTypeListContext)
}

func (s *RuleComponentTypeListsContext) RuleExtensionAdditions() IRuleExtensionAdditionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleExtensionAdditionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleExtensionAdditionsContext)
}

func (s *RuleComponentTypeListsContext) RuleExtensionEndMarker() IRuleExtensionEndMarkerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleExtensionEndMarkerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleExtensionEndMarkerContext)
}

func (s *RuleComponentTypeListsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(asn1ParserCOMMA)
}

func (s *RuleComponentTypeListsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(asn1ParserCOMMA, i)
}

func (s *RuleComponentTypeListsContext) RuleOptionalExtensionMarker() IRuleOptionalExtensionMarkerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleOptionalExtensionMarkerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleOptionalExtensionMarkerContext)
}

func (s *RuleComponentTypeListsContext) RuleExtensionAndException() IRuleExtensionAndExceptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleExtensionAndExceptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleExtensionAndExceptionContext)
}

func (s *RuleComponentTypeListsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleComponentTypeListsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleComponentTypeListsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleComponentTypeLists(s)
	}
}

func (s *RuleComponentTypeListsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleComponentTypeLists(s)
	}
}

func (s *RuleComponentTypeListsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleComponentTypeLists(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleComponentTypeLists() (localctx IRuleComponentTypeListsContext) {
	this := p
	_ = this

	localctx = NewRuleComponentTypeListsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, asn1ParserRULE_ruleComponentTypeLists)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1180)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1155)
			p.RuleRootComponentTypeList()
		}
		{
			p.SetState(1156)
			p.RuleExtensionAdditions()
		}
		{
			p.SetState(1157)
			p.RuleExtensionEndMarker()
		}
		{
			p.SetState(1158)
			p.Match(asn1ParserCOMMA)
		}
		{
			p.SetState(1159)
			p.RuleRootComponentTypeList()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1161)
			p.RuleRootComponentTypeList()
		}
		{
			p.SetState(1162)
			p.RuleExtensionAdditions()
		}
		{
			p.SetState(1163)
			p.RuleOptionalExtensionMarker()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1165)
			p.RuleRootComponentTypeList()
		}
		{
			p.SetState(1166)
			p.Match(asn1ParserCOMMA)
		}
		{
			p.SetState(1167)
			p.RuleExtensionAndException()
		}
		{
			p.SetState(1168)
			p.RuleExtensionAdditions()
		}
		{
			p.SetState(1169)
			p.RuleExtensionEndMarker()
		}
		{
			p.SetState(1170)
			p.Match(asn1ParserCOMMA)
		}
		{
			p.SetState(1171)
			p.RuleRootComponentTypeList()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1173)
			p.RuleRootComponentTypeList()
		}
		{
			p.SetState(1174)
			p.Match(asn1ParserCOMMA)
		}
		{
			p.SetState(1175)
			p.RuleExtensionAndException()
		}
		{
			p.SetState(1176)
			p.RuleExtensionAdditions()
		}
		{
			p.SetState(1177)
			p.RuleOptionalExtensionMarker()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1179)
			p.RuleRootComponentTypeList()
		}

	}

	return localctx
}

// IRuleExtensionAndExceptionContext is an interface to support dynamic dispatch.
type IRuleExtensionAndExceptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleExtensionAndExceptionContext differentiates from other interfaces.
	IsRuleExtensionAndExceptionContext()
}

type RuleExtensionAndExceptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleExtensionAndExceptionContext() *RuleExtensionAndExceptionContext {
	var p = new(RuleExtensionAndExceptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleExtensionAndException
	return p
}

func (*RuleExtensionAndExceptionContext) IsRuleExtensionAndExceptionContext() {}

func NewRuleExtensionAndExceptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleExtensionAndExceptionContext {
	var p = new(RuleExtensionAndExceptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleExtensionAndException

	return p
}

func (s *RuleExtensionAndExceptionContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleExtensionAndExceptionContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(asn1ParserELLIPSIS, 0)
}

func (s *RuleExtensionAndExceptionContext) RuleExceptionSpec() IRuleExceptionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleExceptionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleExceptionSpecContext)
}

func (s *RuleExtensionAndExceptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleExtensionAndExceptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleExtensionAndExceptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleExtensionAndException(s)
	}
}

func (s *RuleExtensionAndExceptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleExtensionAndException(s)
	}
}

func (s *RuleExtensionAndExceptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleExtensionAndException(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleExtensionAndException() (localctx IRuleExtensionAndExceptionContext) {
	this := p
	_ = this

	localctx = NewRuleExtensionAndExceptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, asn1ParserRULE_ruleExtensionAndException)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1185)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1182)
			p.Match(asn1ParserELLIPSIS)
		}
		{
			p.SetState(1183)
			p.RuleExceptionSpec()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1184)
			p.Match(asn1ParserELLIPSIS)
		}

	}

	return localctx
}

// IRuleOptionalExtensionMarkerContext is an interface to support dynamic dispatch.
type IRuleOptionalExtensionMarkerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleOptionalExtensionMarkerContext differentiates from other interfaces.
	IsRuleOptionalExtensionMarkerContext()
}

type RuleOptionalExtensionMarkerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleOptionalExtensionMarkerContext() *RuleOptionalExtensionMarkerContext {
	var p = new(RuleOptionalExtensionMarkerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleOptionalExtensionMarker
	return p
}

func (*RuleOptionalExtensionMarkerContext) IsRuleOptionalExtensionMarkerContext() {}

func NewRuleOptionalExtensionMarkerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleOptionalExtensionMarkerContext {
	var p = new(RuleOptionalExtensionMarkerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleOptionalExtensionMarker

	return p
}

func (s *RuleOptionalExtensionMarkerContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleOptionalExtensionMarkerContext) COMMA() antlr.TerminalNode {
	return s.GetToken(asn1ParserCOMMA, 0)
}

func (s *RuleOptionalExtensionMarkerContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(asn1ParserELLIPSIS, 0)
}

func (s *RuleOptionalExtensionMarkerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleOptionalExtensionMarkerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleOptionalExtensionMarkerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleOptionalExtensionMarker(s)
	}
}

func (s *RuleOptionalExtensionMarkerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleOptionalExtensionMarker(s)
	}
}

func (s *RuleOptionalExtensionMarkerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleOptionalExtensionMarker(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleOptionalExtensionMarker() (localctx IRuleOptionalExtensionMarkerContext) {
	this := p
	_ = this

	localctx = NewRuleOptionalExtensionMarkerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, asn1ParserRULE_ruleOptionalExtensionMarker)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1190)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case asn1ParserCOMMA:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1187)
			p.Match(asn1ParserCOMMA)
		}
		{
			p.SetState(1188)
			p.Match(asn1ParserELLIPSIS)
		}

	case asn1ParserCURLY_END:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRuleEncodingReferenceContext is an interface to support dynamic dispatch.
type IRuleEncodingReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleEncodingReferenceContext differentiates from other interfaces.
	IsRuleEncodingReferenceContext()
}

type RuleEncodingReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleEncodingReferenceContext() *RuleEncodingReferenceContext {
	var p = new(RuleEncodingReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleEncodingReference
	return p
}

func (*RuleEncodingReferenceContext) IsRuleEncodingReferenceContext() {}

func NewRuleEncodingReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleEncodingReferenceContext {
	var p = new(RuleEncodingReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleEncodingReference

	return p
}

func (s *RuleEncodingReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleEncodingReferenceContext) UCASE_ID() antlr.TerminalNode {
	return s.GetToken(asn1ParserUCASE_ID, 0)
}

func (s *RuleEncodingReferenceContext) COLON() antlr.TerminalNode {
	return s.GetToken(asn1ParserCOLON, 0)
}

func (s *RuleEncodingReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleEncodingReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleEncodingReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleEncodingReference(s)
	}
}

func (s *RuleEncodingReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleEncodingReference(s)
	}
}

func (s *RuleEncodingReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleEncodingReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleEncodingReference() (localctx IRuleEncodingReferenceContext) {
	this := p
	_ = this

	localctx = NewRuleEncodingReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, asn1ParserRULE_ruleEncodingReference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1195)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1192)
			p.Match(asn1ParserUCASE_ID)
		}
		{
			p.SetState(1193)
			p.Match(asn1ParserCOLON)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)

	}

	return localctx
}

// IRuleClassContext is an interface to support dynamic dispatch.
type IRuleClassContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleClassContext differentiates from other interfaces.
	IsRuleClassContext()
}

type RuleClassContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleClassContext() *RuleClassContext {
	var p = new(RuleClassContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleClass
	return p
}

func (*RuleClassContext) IsRuleClassContext() {}

func NewRuleClassContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleClassContext {
	var p = new(RuleClassContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleClass

	return p
}

func (s *RuleClassContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleClassContext) UNIVERSAL_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserUNIVERSAL_SYM, 0)
}

func (s *RuleClassContext) APPLICATION_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserAPPLICATION_SYM, 0)
}

func (s *RuleClassContext) PRIVATE_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserPRIVATE_SYM, 0)
}

func (s *RuleClassContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleClassContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleClassContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleClass(s)
	}
}

func (s *RuleClassContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleClass(s)
	}
}

func (s *RuleClassContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleClass(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleClass() (localctx IRuleClassContext) {
	this := p
	_ = this

	localctx = NewRuleClassContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, asn1ParserRULE_ruleClass)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1201)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case asn1ParserUNIVERSAL_SYM:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1197)
			p.Match(asn1ParserUNIVERSAL_SYM)
		}

	case asn1ParserAPPLICATION_SYM:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1198)
			p.Match(asn1ParserAPPLICATION_SYM)
		}

	case asn1ParserPRIVATE_SYM:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1199)
			p.Match(asn1ParserPRIVATE_SYM)
		}

	case asn1ParserNUMBER, asn1ParserUCASE_ID, asn1ParserLCASE_ID:
		p.EnterOuterAlt(localctx, 4)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRuleClassNumberContext is an interface to support dynamic dispatch.
type IRuleClassNumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleClassNumberContext differentiates from other interfaces.
	IsRuleClassNumberContext()
}

type RuleClassNumberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleClassNumberContext() *RuleClassNumberContext {
	var p = new(RuleClassNumberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleClassNumber
	return p
}

func (*RuleClassNumberContext) IsRuleClassNumberContext() {}

func NewRuleClassNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleClassNumberContext {
	var p = new(RuleClassNumberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleClassNumber

	return p
}

func (s *RuleClassNumberContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleClassNumberContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(asn1ParserNUMBER, 0)
}

func (s *RuleClassNumberContext) RuleDefinedValue() IRuleDefinedValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinedValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinedValueContext)
}

func (s *RuleClassNumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleClassNumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleClassNumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleClassNumber(s)
	}
}

func (s *RuleClassNumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleClassNumber(s)
	}
}

func (s *RuleClassNumberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleClassNumber(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleClassNumber() (localctx IRuleClassNumberContext) {
	this := p
	_ = this

	localctx = NewRuleClassNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, asn1ParserRULE_ruleClassNumber)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1205)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case asn1ParserNUMBER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1203)
			p.Match(asn1ParserNUMBER)
		}

	case asn1ParserUCASE_ID, asn1ParserLCASE_ID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1204)
			p.RuleDefinedValue()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRuleEncodingInstructionContext is an interface to support dynamic dispatch.
type IRuleEncodingInstructionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleEncodingInstructionContext differentiates from other interfaces.
	IsRuleEncodingInstructionContext()
}

type RuleEncodingInstructionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleEncodingInstructionContext() *RuleEncodingInstructionContext {
	var p = new(RuleEncodingInstructionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleEncodingInstruction
	return p
}

func (*RuleEncodingInstructionContext) IsRuleEncodingInstructionContext() {}

func NewRuleEncodingInstructionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleEncodingInstructionContext {
	var p = new(RuleEncodingInstructionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleEncodingInstruction

	return p
}

func (s *RuleEncodingInstructionContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleEncodingInstructionContext) LCASE_ID() antlr.TerminalNode {
	return s.GetToken(asn1ParserLCASE_ID, 0)
}

func (s *RuleEncodingInstructionContext) UCASE_ID() antlr.TerminalNode {
	return s.GetToken(asn1ParserUCASE_ID, 0)
}

func (s *RuleEncodingInstructionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleEncodingInstructionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleEncodingInstructionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleEncodingInstruction(s)
	}
}

func (s *RuleEncodingInstructionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleEncodingInstruction(s)
	}
}

func (s *RuleEncodingInstructionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleEncodingInstruction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleEncodingInstruction() (localctx IRuleEncodingInstructionContext) {
	this := p
	_ = this

	localctx = NewRuleEncodingInstructionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, asn1ParserRULE_ruleEncodingInstruction)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1207)
		_la = p.GetTokenStream().LA(1)

		if !(_la == asn1ParserUCASE_ID || _la == asn1ParserLCASE_ID) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IRuleTagContext is an interface to support dynamic dispatch.
type IRuleTagContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleTagContext differentiates from other interfaces.
	IsRuleTagContext()
}

type RuleTagContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleTagContext() *RuleTagContext {
	var p = new(RuleTagContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleTag
	return p
}

func (*RuleTagContext) IsRuleTagContext() {}

func NewRuleTagContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleTagContext {
	var p = new(RuleTagContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleTag

	return p
}

func (s *RuleTagContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleTagContext) SQUARE_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserSQUARE_START, 0)
}

func (s *RuleTagContext) RuleEncodingReference() IRuleEncodingReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleEncodingReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleEncodingReferenceContext)
}

func (s *RuleTagContext) RuleClass() IRuleClassContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleClassContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleClassContext)
}

func (s *RuleTagContext) RuleClassNumber() IRuleClassNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleClassNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleClassNumberContext)
}

func (s *RuleTagContext) SQUARE_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserSQUARE_END, 0)
}

func (s *RuleTagContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleTagContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleTagContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleTag(s)
	}
}

func (s *RuleTagContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleTag(s)
	}
}

func (s *RuleTagContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleTag(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleTag() (localctx IRuleTagContext) {
	this := p
	_ = this

	localctx = NewRuleTagContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, asn1ParserRULE_ruleTag)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1209)
		p.Match(asn1ParserSQUARE_START)
	}
	{
		p.SetState(1210)
		p.RuleEncodingReference()
	}
	{
		p.SetState(1211)
		p.RuleClass()
	}
	{
		p.SetState(1212)
		p.RuleClassNumber()
	}
	{
		p.SetState(1213)
		p.Match(asn1ParserSQUARE_END)
	}

	return localctx
}

// IRuleEncodingPrefixContext is an interface to support dynamic dispatch.
type IRuleEncodingPrefixContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleEncodingPrefixContext differentiates from other interfaces.
	IsRuleEncodingPrefixContext()
}

type RuleEncodingPrefixContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleEncodingPrefixContext() *RuleEncodingPrefixContext {
	var p = new(RuleEncodingPrefixContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleEncodingPrefix
	return p
}

func (*RuleEncodingPrefixContext) IsRuleEncodingPrefixContext() {}

func NewRuleEncodingPrefixContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleEncodingPrefixContext {
	var p = new(RuleEncodingPrefixContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleEncodingPrefix

	return p
}

func (s *RuleEncodingPrefixContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleEncodingPrefixContext) SQUARE_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserSQUARE_START, 0)
}

func (s *RuleEncodingPrefixContext) RuleEncodingReference() IRuleEncodingReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleEncodingReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleEncodingReferenceContext)
}

func (s *RuleEncodingPrefixContext) RuleEncodingInstruction() IRuleEncodingInstructionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleEncodingInstructionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleEncodingInstructionContext)
}

func (s *RuleEncodingPrefixContext) SQUARE_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserSQUARE_END, 0)
}

func (s *RuleEncodingPrefixContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleEncodingPrefixContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleEncodingPrefixContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleEncodingPrefix(s)
	}
}

func (s *RuleEncodingPrefixContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleEncodingPrefix(s)
	}
}

func (s *RuleEncodingPrefixContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleEncodingPrefix(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleEncodingPrefix() (localctx IRuleEncodingPrefixContext) {
	this := p
	_ = this

	localctx = NewRuleEncodingPrefixContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, asn1ParserRULE_ruleEncodingPrefix)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1215)
		p.Match(asn1ParserSQUARE_START)
	}
	{
		p.SetState(1216)
		p.RuleEncodingReference()
	}
	{
		p.SetState(1217)
		p.RuleEncodingInstruction()
	}
	{
		p.SetState(1218)
		p.Match(asn1ParserSQUARE_END)
	}

	return localctx
}

// IRuleTaggedTypeContext is an interface to support dynamic dispatch.
type IRuleTaggedTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleTaggedTypeContext differentiates from other interfaces.
	IsRuleTaggedTypeContext()
}

type RuleTaggedTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleTaggedTypeContext() *RuleTaggedTypeContext {
	var p = new(RuleTaggedTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleTaggedType
	return p
}

func (*RuleTaggedTypeContext) IsRuleTaggedTypeContext() {}

func NewRuleTaggedTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleTaggedTypeContext {
	var p = new(RuleTaggedTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleTaggedType

	return p
}

func (s *RuleTaggedTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleTaggedTypeContext) RuleTag() IRuleTagContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTagContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTagContext)
}

func (s *RuleTaggedTypeContext) IMPLICIT_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserIMPLICIT_SYM, 0)
}

func (s *RuleTaggedTypeContext) RuleType() IRuleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeContext)
}

func (s *RuleTaggedTypeContext) EXPLICIT_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserEXPLICIT_SYM, 0)
}

func (s *RuleTaggedTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleTaggedTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleTaggedTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleTaggedType(s)
	}
}

func (s *RuleTaggedTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleTaggedType(s)
	}
}

func (s *RuleTaggedTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleTaggedType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleTaggedType() (localctx IRuleTaggedTypeContext) {
	this := p
	_ = this

	localctx = NewRuleTaggedTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, asn1ParserRULE_ruleTaggedType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1228)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1220)
			p.RuleTag()
		}
		{
			p.SetState(1221)
			p.Match(asn1ParserIMPLICIT_SYM)
		}
		{
			p.SetState(1222)
			p.RuleType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1224)
			p.RuleTag()
		}
		{
			p.SetState(1225)
			p.Match(asn1ParserEXPLICIT_SYM)
		}
		{
			p.SetState(1226)
			p.RuleType()
		}

	}

	return localctx
}

// IRuleEncodingPrefixedTypeContext is an interface to support dynamic dispatch.
type IRuleEncodingPrefixedTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleEncodingPrefixedTypeContext differentiates from other interfaces.
	IsRuleEncodingPrefixedTypeContext()
}

type RuleEncodingPrefixedTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleEncodingPrefixedTypeContext() *RuleEncodingPrefixedTypeContext {
	var p = new(RuleEncodingPrefixedTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleEncodingPrefixedType
	return p
}

func (*RuleEncodingPrefixedTypeContext) IsRuleEncodingPrefixedTypeContext() {}

func NewRuleEncodingPrefixedTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleEncodingPrefixedTypeContext {
	var p = new(RuleEncodingPrefixedTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleEncodingPrefixedType

	return p
}

func (s *RuleEncodingPrefixedTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleEncodingPrefixedTypeContext) RuleEncodingPrefix() IRuleEncodingPrefixContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleEncodingPrefixContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleEncodingPrefixContext)
}

func (s *RuleEncodingPrefixedTypeContext) RuleType() IRuleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeContext)
}

func (s *RuleEncodingPrefixedTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleEncodingPrefixedTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleEncodingPrefixedTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleEncodingPrefixedType(s)
	}
}

func (s *RuleEncodingPrefixedTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleEncodingPrefixedType(s)
	}
}

func (s *RuleEncodingPrefixedTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleEncodingPrefixedType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleEncodingPrefixedType() (localctx IRuleEncodingPrefixedTypeContext) {
	this := p
	_ = this

	localctx = NewRuleEncodingPrefixedTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, asn1ParserRULE_ruleEncodingPrefixedType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1230)
		p.RuleEncodingPrefix()
	}
	{
		p.SetState(1231)
		p.RuleType()
	}

	return localctx
}

// IRuleBitStringTypeContext is an interface to support dynamic dispatch.
type IRuleBitStringTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleBitStringTypeContext differentiates from other interfaces.
	IsRuleBitStringTypeContext()
}

type RuleBitStringTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleBitStringTypeContext() *RuleBitStringTypeContext {
	var p = new(RuleBitStringTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleBitStringType
	return p
}

func (*RuleBitStringTypeContext) IsRuleBitStringTypeContext() {}

func NewRuleBitStringTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleBitStringTypeContext {
	var p = new(RuleBitStringTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleBitStringType

	return p
}

func (s *RuleBitStringTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleBitStringTypeContext) BIT_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserBIT_SYM, 0)
}

func (s *RuleBitStringTypeContext) STRING_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserSTRING_SYM, 0)
}

func (s *RuleBitStringTypeContext) CURLY_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_START, 0)
}

func (s *RuleBitStringTypeContext) RuleNamedBitList() IRuleNamedBitListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleNamedBitListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleNamedBitListContext)
}

func (s *RuleBitStringTypeContext) CURLY_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_END, 0)
}

func (s *RuleBitStringTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleBitStringTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleBitStringTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleBitStringType(s)
	}
}

func (s *RuleBitStringTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleBitStringType(s)
	}
}

func (s *RuleBitStringTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleBitStringType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleBitStringType() (localctx IRuleBitStringTypeContext) {
	this := p
	_ = this

	localctx = NewRuleBitStringTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, asn1ParserRULE_ruleBitStringType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1241)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1233)
			p.Match(asn1ParserBIT_SYM)
		}
		{
			p.SetState(1234)
			p.Match(asn1ParserSTRING_SYM)
		}
		{
			p.SetState(1235)
			p.Match(asn1ParserCURLY_START)
		}
		{
			p.SetState(1236)
			p.ruleNamedBitList(0)
		}
		{
			p.SetState(1237)
			p.Match(asn1ParserCURLY_END)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1239)
			p.Match(asn1ParserBIT_SYM)
		}
		{
			p.SetState(1240)
			p.Match(asn1ParserSTRING_SYM)
		}

	}

	return localctx
}

// IRuleBooleanTypeContext is an interface to support dynamic dispatch.
type IRuleBooleanTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleBooleanTypeContext differentiates from other interfaces.
	IsRuleBooleanTypeContext()
}

type RuleBooleanTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleBooleanTypeContext() *RuleBooleanTypeContext {
	var p = new(RuleBooleanTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleBooleanType
	return p
}

func (*RuleBooleanTypeContext) IsRuleBooleanTypeContext() {}

func NewRuleBooleanTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleBooleanTypeContext {
	var p = new(RuleBooleanTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleBooleanType

	return p
}

func (s *RuleBooleanTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleBooleanTypeContext) BOOLEAN_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserBOOLEAN_SYM, 0)
}

func (s *RuleBooleanTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleBooleanTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleBooleanTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleBooleanType(s)
	}
}

func (s *RuleBooleanTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleBooleanType(s)
	}
}

func (s *RuleBooleanTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleBooleanType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleBooleanType() (localctx IRuleBooleanTypeContext) {
	this := p
	_ = this

	localctx = NewRuleBooleanTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, asn1ParserRULE_ruleBooleanType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1243)
		p.Match(asn1ParserBOOLEAN_SYM)
	}

	return localctx
}

// IRuleCharacterStringTypeContext is an interface to support dynamic dispatch.
type IRuleCharacterStringTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleCharacterStringTypeContext differentiates from other interfaces.
	IsRuleCharacterStringTypeContext()
}

type RuleCharacterStringTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleCharacterStringTypeContext() *RuleCharacterStringTypeContext {
	var p = new(RuleCharacterStringTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleCharacterStringType
	return p
}

func (*RuleCharacterStringTypeContext) IsRuleCharacterStringTypeContext() {}

func NewRuleCharacterStringTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleCharacterStringTypeContext {
	var p = new(RuleCharacterStringTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleCharacterStringType

	return p
}

func (s *RuleCharacterStringTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleCharacterStringTypeContext) RuleRestrictedCharacterStringType() IRuleRestrictedCharacterStringTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleRestrictedCharacterStringTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleRestrictedCharacterStringTypeContext)
}

func (s *RuleCharacterStringTypeContext) RuleUnrestrictedCharacterStringType() IRuleUnrestrictedCharacterStringTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleUnrestrictedCharacterStringTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleUnrestrictedCharacterStringTypeContext)
}

func (s *RuleCharacterStringTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleCharacterStringTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleCharacterStringTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleCharacterStringType(s)
	}
}

func (s *RuleCharacterStringTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleCharacterStringType(s)
	}
}

func (s *RuleCharacterStringTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleCharacterStringType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleCharacterStringType() (localctx IRuleCharacterStringTypeContext) {
	this := p
	_ = this

	localctx = NewRuleCharacterStringTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, asn1ParserRULE_ruleCharacterStringType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1247)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case asn1ParserBMP_STRING_SYM, asn1ParserGENERAL_STRING_SYM, asn1ParserGRAPHIC_STRING_SYM, asn1ParserIA5_STRING_SYM, asn1ParserISO646_STRING_SYM, asn1ParserNUMERIC_STRING_SYM, asn1ParserPRINTABLE_STRING_SYM, asn1ParserT61_STRING_SYM, asn1ParserTELETEX_STRING_SYM, asn1ParserUNIVERSAL_STRING_SYM, asn1ParserUTF8_STRING_SYM, asn1ParserVIDEOTEX_STRING_SYM, asn1ParserVISIBLE_STRING_SYM:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1245)
			p.RuleRestrictedCharacterStringType()
		}

	case asn1ParserCHARACTER_SYM:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1246)
			p.RuleUnrestrictedCharacterStringType()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRuleChoiceTypeContext is an interface to support dynamic dispatch.
type IRuleChoiceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleChoiceTypeContext differentiates from other interfaces.
	IsRuleChoiceTypeContext()
}

type RuleChoiceTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleChoiceTypeContext() *RuleChoiceTypeContext {
	var p = new(RuleChoiceTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleChoiceType
	return p
}

func (*RuleChoiceTypeContext) IsRuleChoiceTypeContext() {}

func NewRuleChoiceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleChoiceTypeContext {
	var p = new(RuleChoiceTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleChoiceType

	return p
}

func (s *RuleChoiceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleChoiceTypeContext) CHOICE_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserCHOICE_SYM, 0)
}

func (s *RuleChoiceTypeContext) CURLY_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_START, 0)
}

func (s *RuleChoiceTypeContext) RuleAlternativeTypeLists() IRuleAlternativeTypeListsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleAlternativeTypeListsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleAlternativeTypeListsContext)
}

func (s *RuleChoiceTypeContext) CURLY_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_END, 0)
}

func (s *RuleChoiceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleChoiceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleChoiceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleChoiceType(s)
	}
}

func (s *RuleChoiceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleChoiceType(s)
	}
}

func (s *RuleChoiceTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleChoiceType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleChoiceType() (localctx IRuleChoiceTypeContext) {
	this := p
	_ = this

	localctx = NewRuleChoiceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, asn1ParserRULE_ruleChoiceType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1249)
		p.Match(asn1ParserCHOICE_SYM)
	}
	{
		p.SetState(1250)
		p.Match(asn1ParserCURLY_START)
	}
	{
		p.SetState(1251)
		p.RuleAlternativeTypeLists()
	}
	{
		p.SetState(1252)
		p.Match(asn1ParserCURLY_END)
	}

	return localctx
}

// IRuleDateTypeContext is an interface to support dynamic dispatch.
type IRuleDateTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleDateTypeContext differentiates from other interfaces.
	IsRuleDateTypeContext()
}

type RuleDateTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleDateTypeContext() *RuleDateTypeContext {
	var p = new(RuleDateTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleDateType
	return p
}

func (*RuleDateTypeContext) IsRuleDateTypeContext() {}

func NewRuleDateTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleDateTypeContext {
	var p = new(RuleDateTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleDateType

	return p
}

func (s *RuleDateTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleDateTypeContext) DATE_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserDATE_SYM, 0)
}

func (s *RuleDateTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleDateTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleDateTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleDateType(s)
	}
}

func (s *RuleDateTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleDateType(s)
	}
}

func (s *RuleDateTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleDateType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleDateType() (localctx IRuleDateTypeContext) {
	this := p
	_ = this

	localctx = NewRuleDateTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, asn1ParserRULE_ruleDateType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1254)
		p.Match(asn1ParserDATE_SYM)
	}

	return localctx
}

// IRuleDateTimeTypeContext is an interface to support dynamic dispatch.
type IRuleDateTimeTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleDateTimeTypeContext differentiates from other interfaces.
	IsRuleDateTimeTypeContext()
}

type RuleDateTimeTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleDateTimeTypeContext() *RuleDateTimeTypeContext {
	var p = new(RuleDateTimeTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleDateTimeType
	return p
}

func (*RuleDateTimeTypeContext) IsRuleDateTimeTypeContext() {}

func NewRuleDateTimeTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleDateTimeTypeContext {
	var p = new(RuleDateTimeTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleDateTimeType

	return p
}

func (s *RuleDateTimeTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleDateTimeTypeContext) DATE_TIME_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserDATE_TIME_SYM, 0)
}

func (s *RuleDateTimeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleDateTimeTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleDateTimeTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleDateTimeType(s)
	}
}

func (s *RuleDateTimeTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleDateTimeType(s)
	}
}

func (s *RuleDateTimeTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleDateTimeType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleDateTimeType() (localctx IRuleDateTimeTypeContext) {
	this := p
	_ = this

	localctx = NewRuleDateTimeTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, asn1ParserRULE_ruleDateTimeType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1256)
		p.Match(asn1ParserDATE_TIME_SYM)
	}

	return localctx
}

// IRuleDurationTypeContext is an interface to support dynamic dispatch.
type IRuleDurationTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleDurationTypeContext differentiates from other interfaces.
	IsRuleDurationTypeContext()
}

type RuleDurationTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleDurationTypeContext() *RuleDurationTypeContext {
	var p = new(RuleDurationTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleDurationType
	return p
}

func (*RuleDurationTypeContext) IsRuleDurationTypeContext() {}

func NewRuleDurationTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleDurationTypeContext {
	var p = new(RuleDurationTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleDurationType

	return p
}

func (s *RuleDurationTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleDurationTypeContext) DURATION_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserDURATION_SYM, 0)
}

func (s *RuleDurationTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleDurationTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleDurationTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleDurationType(s)
	}
}

func (s *RuleDurationTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleDurationType(s)
	}
}

func (s *RuleDurationTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleDurationType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleDurationType() (localctx IRuleDurationTypeContext) {
	this := p
	_ = this

	localctx = NewRuleDurationTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, asn1ParserRULE_ruleDurationType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1258)
		p.Match(asn1ParserDURATION_SYM)
	}

	return localctx
}

// IRuleEmbeddedPDVTypeContext is an interface to support dynamic dispatch.
type IRuleEmbeddedPDVTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleEmbeddedPDVTypeContext differentiates from other interfaces.
	IsRuleEmbeddedPDVTypeContext()
}

type RuleEmbeddedPDVTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleEmbeddedPDVTypeContext() *RuleEmbeddedPDVTypeContext {
	var p = new(RuleEmbeddedPDVTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleEmbeddedPDVType
	return p
}

func (*RuleEmbeddedPDVTypeContext) IsRuleEmbeddedPDVTypeContext() {}

func NewRuleEmbeddedPDVTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleEmbeddedPDVTypeContext {
	var p = new(RuleEmbeddedPDVTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleEmbeddedPDVType

	return p
}

func (s *RuleEmbeddedPDVTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleEmbeddedPDVTypeContext) EMBEDDED_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserEMBEDDED_SYM, 0)
}

func (s *RuleEmbeddedPDVTypeContext) PDV_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserPDV_SYM, 0)
}

func (s *RuleEmbeddedPDVTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleEmbeddedPDVTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleEmbeddedPDVTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleEmbeddedPDVType(s)
	}
}

func (s *RuleEmbeddedPDVTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleEmbeddedPDVType(s)
	}
}

func (s *RuleEmbeddedPDVTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleEmbeddedPDVType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleEmbeddedPDVType() (localctx IRuleEmbeddedPDVTypeContext) {
	this := p
	_ = this

	localctx = NewRuleEmbeddedPDVTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, asn1ParserRULE_ruleEmbeddedPDVType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1260)
		p.Match(asn1ParserEMBEDDED_SYM)
	}
	{
		p.SetState(1261)
		p.Match(asn1ParserPDV_SYM)
	}

	return localctx
}

// IRuleEnumeratedTypeContext is an interface to support dynamic dispatch.
type IRuleEnumeratedTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleEnumeratedTypeContext differentiates from other interfaces.
	IsRuleEnumeratedTypeContext()
}

type RuleEnumeratedTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleEnumeratedTypeContext() *RuleEnumeratedTypeContext {
	var p = new(RuleEnumeratedTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleEnumeratedType
	return p
}

func (*RuleEnumeratedTypeContext) IsRuleEnumeratedTypeContext() {}

func NewRuleEnumeratedTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleEnumeratedTypeContext {
	var p = new(RuleEnumeratedTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleEnumeratedType

	return p
}

func (s *RuleEnumeratedTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleEnumeratedTypeContext) ENUMERATED_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserENUMERATED_SYM, 0)
}

func (s *RuleEnumeratedTypeContext) CURLY_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_START, 0)
}

func (s *RuleEnumeratedTypeContext) RuleEnumerations() IRuleEnumerationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleEnumerationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleEnumerationsContext)
}

func (s *RuleEnumeratedTypeContext) CURLY_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_END, 0)
}

func (s *RuleEnumeratedTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleEnumeratedTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleEnumeratedTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleEnumeratedType(s)
	}
}

func (s *RuleEnumeratedTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleEnumeratedType(s)
	}
}

func (s *RuleEnumeratedTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleEnumeratedType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleEnumeratedType() (localctx IRuleEnumeratedTypeContext) {
	this := p
	_ = this

	localctx = NewRuleEnumeratedTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, asn1ParserRULE_ruleEnumeratedType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1263)
		p.Match(asn1ParserENUMERATED_SYM)
	}
	{
		p.SetState(1264)
		p.Match(asn1ParserCURLY_START)
	}
	{
		p.SetState(1265)
		p.RuleEnumerations()
	}
	{
		p.SetState(1266)
		p.Match(asn1ParserCURLY_END)
	}

	return localctx
}

// IRuleExternalTypeContext is an interface to support dynamic dispatch.
type IRuleExternalTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleExternalTypeContext differentiates from other interfaces.
	IsRuleExternalTypeContext()
}

type RuleExternalTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleExternalTypeContext() *RuleExternalTypeContext {
	var p = new(RuleExternalTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleExternalType
	return p
}

func (*RuleExternalTypeContext) IsRuleExternalTypeContext() {}

func NewRuleExternalTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleExternalTypeContext {
	var p = new(RuleExternalTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleExternalType

	return p
}

func (s *RuleExternalTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleExternalTypeContext) EXTERNAL_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserEXTERNAL_SYM, 0)
}

func (s *RuleExternalTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleExternalTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleExternalTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleExternalType(s)
	}
}

func (s *RuleExternalTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleExternalType(s)
	}
}

func (s *RuleExternalTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleExternalType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleExternalType() (localctx IRuleExternalTypeContext) {
	this := p
	_ = this

	localctx = NewRuleExternalTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, asn1ParserRULE_ruleExternalType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1268)
		p.Match(asn1ParserEXTERNAL_SYM)
	}

	return localctx
}

// IRuleInstanceOfTypeContext is an interface to support dynamic dispatch.
type IRuleInstanceOfTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleInstanceOfTypeContext differentiates from other interfaces.
	IsRuleInstanceOfTypeContext()
}

type RuleInstanceOfTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleInstanceOfTypeContext() *RuleInstanceOfTypeContext {
	var p = new(RuleInstanceOfTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleInstanceOfType
	return p
}

func (*RuleInstanceOfTypeContext) IsRuleInstanceOfTypeContext() {}

func NewRuleInstanceOfTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleInstanceOfTypeContext {
	var p = new(RuleInstanceOfTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleInstanceOfType

	return p
}

func (s *RuleInstanceOfTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleInstanceOfTypeContext) INSTANCE_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserINSTANCE_SYM, 0)
}

func (s *RuleInstanceOfTypeContext) OF_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserOF_SYM, 0)
}

func (s *RuleInstanceOfTypeContext) RuleDefinedObjectClass() IRuleDefinedObjectClassContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinedObjectClassContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinedObjectClassContext)
}

func (s *RuleInstanceOfTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleInstanceOfTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleInstanceOfTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleInstanceOfType(s)
	}
}

func (s *RuleInstanceOfTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleInstanceOfType(s)
	}
}

func (s *RuleInstanceOfTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleInstanceOfType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleInstanceOfType() (localctx IRuleInstanceOfTypeContext) {
	this := p
	_ = this

	localctx = NewRuleInstanceOfTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, asn1ParserRULE_ruleInstanceOfType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1270)
		p.Match(asn1ParserINSTANCE_SYM)
	}
	{
		p.SetState(1271)
		p.Match(asn1ParserOF_SYM)
	}
	{
		p.SetState(1272)
		p.RuleDefinedObjectClass()
	}

	return localctx
}

// IRuleIntegerTypeContext is an interface to support dynamic dispatch.
type IRuleIntegerTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleIntegerTypeContext differentiates from other interfaces.
	IsRuleIntegerTypeContext()
}

type RuleIntegerTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleIntegerTypeContext() *RuleIntegerTypeContext {
	var p = new(RuleIntegerTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleIntegerType
	return p
}

func (*RuleIntegerTypeContext) IsRuleIntegerTypeContext() {}

func NewRuleIntegerTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleIntegerTypeContext {
	var p = new(RuleIntegerTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleIntegerType

	return p
}

func (s *RuleIntegerTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleIntegerTypeContext) INTEGER_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserINTEGER_SYM, 0)
}

func (s *RuleIntegerTypeContext) CURLY_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_START, 0)
}

func (s *RuleIntegerTypeContext) RuleNamedNumberList() IRuleNamedNumberListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleNamedNumberListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleNamedNumberListContext)
}

func (s *RuleIntegerTypeContext) CURLY_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_END, 0)
}

func (s *RuleIntegerTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleIntegerTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleIntegerTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleIntegerType(s)
	}
}

func (s *RuleIntegerTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleIntegerType(s)
	}
}

func (s *RuleIntegerTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleIntegerType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleIntegerType() (localctx IRuleIntegerTypeContext) {
	this := p
	_ = this

	localctx = NewRuleIntegerTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, asn1ParserRULE_ruleIntegerType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1280)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1274)
			p.Match(asn1ParserINTEGER_SYM)
		}
		{
			p.SetState(1275)
			p.Match(asn1ParserCURLY_START)
		}
		{
			p.SetState(1276)
			p.ruleNamedNumberList(0)
		}
		{
			p.SetState(1277)
			p.Match(asn1ParserCURLY_END)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1279)
			p.Match(asn1ParserINTEGER_SYM)
		}

	}

	return localctx
}

// IRuleIRITypeContext is an interface to support dynamic dispatch.
type IRuleIRITypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleIRITypeContext differentiates from other interfaces.
	IsRuleIRITypeContext()
}

type RuleIRITypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleIRITypeContext() *RuleIRITypeContext {
	var p = new(RuleIRITypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleIRIType
	return p
}

func (*RuleIRITypeContext) IsRuleIRITypeContext() {}

func NewRuleIRITypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleIRITypeContext {
	var p = new(RuleIRITypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleIRIType

	return p
}

func (s *RuleIRITypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleIRITypeContext) OID_IRI_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserOID_IRI_SYM, 0)
}

func (s *RuleIRITypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleIRITypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleIRITypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleIRIType(s)
	}
}

func (s *RuleIRITypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleIRIType(s)
	}
}

func (s *RuleIRITypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleIRIType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleIRIType() (localctx IRuleIRITypeContext) {
	this := p
	_ = this

	localctx = NewRuleIRITypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, asn1ParserRULE_ruleIRIType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1282)
		p.Match(asn1ParserOID_IRI_SYM)
	}

	return localctx
}

// IRuleNullTypeContext is an interface to support dynamic dispatch.
type IRuleNullTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleNullTypeContext differentiates from other interfaces.
	IsRuleNullTypeContext()
}

type RuleNullTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleNullTypeContext() *RuleNullTypeContext {
	var p = new(RuleNullTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleNullType
	return p
}

func (*RuleNullTypeContext) IsRuleNullTypeContext() {}

func NewRuleNullTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleNullTypeContext {
	var p = new(RuleNullTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleNullType

	return p
}

func (s *RuleNullTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleNullTypeContext) NULL_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserNULL_SYM, 0)
}

func (s *RuleNullTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleNullTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleNullTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleNullType(s)
	}
}

func (s *RuleNullTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleNullType(s)
	}
}

func (s *RuleNullTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleNullType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleNullType() (localctx IRuleNullTypeContext) {
	this := p
	_ = this

	localctx = NewRuleNullTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, asn1ParserRULE_ruleNullType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1284)
		p.Match(asn1ParserNULL_SYM)
	}

	return localctx
}

// IRuleObjectClassFieldTypeContext is an interface to support dynamic dispatch.
type IRuleObjectClassFieldTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleObjectClassFieldTypeContext differentiates from other interfaces.
	IsRuleObjectClassFieldTypeContext()
}

type RuleObjectClassFieldTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleObjectClassFieldTypeContext() *RuleObjectClassFieldTypeContext {
	var p = new(RuleObjectClassFieldTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleObjectClassFieldType
	return p
}

func (*RuleObjectClassFieldTypeContext) IsRuleObjectClassFieldTypeContext() {}

func NewRuleObjectClassFieldTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleObjectClassFieldTypeContext {
	var p = new(RuleObjectClassFieldTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleObjectClassFieldType

	return p
}

func (s *RuleObjectClassFieldTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleObjectClassFieldTypeContext) RuleDefinedObjectClass() IRuleDefinedObjectClassContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinedObjectClassContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinedObjectClassContext)
}

func (s *RuleObjectClassFieldTypeContext) DOT() antlr.TerminalNode {
	return s.GetToken(asn1ParserDOT, 0)
}

func (s *RuleObjectClassFieldTypeContext) RuleFieldName() IRuleFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleFieldNameContext)
}

func (s *RuleObjectClassFieldTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleObjectClassFieldTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleObjectClassFieldTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleObjectClassFieldType(s)
	}
}

func (s *RuleObjectClassFieldTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleObjectClassFieldType(s)
	}
}

func (s *RuleObjectClassFieldTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleObjectClassFieldType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleObjectClassFieldType() (localctx IRuleObjectClassFieldTypeContext) {
	this := p
	_ = this

	localctx = NewRuleObjectClassFieldTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, asn1ParserRULE_ruleObjectClassFieldType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1286)
		p.RuleDefinedObjectClass()
	}
	{
		p.SetState(1287)
		p.Match(asn1ParserDOT)
	}
	{
		p.SetState(1288)
		p.ruleFieldName(0)
	}

	return localctx
}

// IRuleObjectIdentifierTypeContext is an interface to support dynamic dispatch.
type IRuleObjectIdentifierTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleObjectIdentifierTypeContext differentiates from other interfaces.
	IsRuleObjectIdentifierTypeContext()
}

type RuleObjectIdentifierTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleObjectIdentifierTypeContext() *RuleObjectIdentifierTypeContext {
	var p = new(RuleObjectIdentifierTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleObjectIdentifierType
	return p
}

func (*RuleObjectIdentifierTypeContext) IsRuleObjectIdentifierTypeContext() {}

func NewRuleObjectIdentifierTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleObjectIdentifierTypeContext {
	var p = new(RuleObjectIdentifierTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleObjectIdentifierType

	return p
}

func (s *RuleObjectIdentifierTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleObjectIdentifierTypeContext) OBJECT_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserOBJECT_SYM, 0)
}

func (s *RuleObjectIdentifierTypeContext) IDENTIFIER_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserIDENTIFIER_SYM, 0)
}

func (s *RuleObjectIdentifierTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleObjectIdentifierTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleObjectIdentifierTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleObjectIdentifierType(s)
	}
}

func (s *RuleObjectIdentifierTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleObjectIdentifierType(s)
	}
}

func (s *RuleObjectIdentifierTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleObjectIdentifierType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleObjectIdentifierType() (localctx IRuleObjectIdentifierTypeContext) {
	this := p
	_ = this

	localctx = NewRuleObjectIdentifierTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, asn1ParserRULE_ruleObjectIdentifierType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1290)
		p.Match(asn1ParserOBJECT_SYM)
	}
	{
		p.SetState(1291)
		p.Match(asn1ParserIDENTIFIER_SYM)
	}

	return localctx
}

// IRuleOctetStringTypeContext is an interface to support dynamic dispatch.
type IRuleOctetStringTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleOctetStringTypeContext differentiates from other interfaces.
	IsRuleOctetStringTypeContext()
}

type RuleOctetStringTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleOctetStringTypeContext() *RuleOctetStringTypeContext {
	var p = new(RuleOctetStringTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleOctetStringType
	return p
}

func (*RuleOctetStringTypeContext) IsRuleOctetStringTypeContext() {}

func NewRuleOctetStringTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleOctetStringTypeContext {
	var p = new(RuleOctetStringTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleOctetStringType

	return p
}

func (s *RuleOctetStringTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleOctetStringTypeContext) OCTET_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserOCTET_SYM, 0)
}

func (s *RuleOctetStringTypeContext) STRING_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserSTRING_SYM, 0)
}

func (s *RuleOctetStringTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleOctetStringTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleOctetStringTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleOctetStringType(s)
	}
}

func (s *RuleOctetStringTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleOctetStringType(s)
	}
}

func (s *RuleOctetStringTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleOctetStringType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleOctetStringType() (localctx IRuleOctetStringTypeContext) {
	this := p
	_ = this

	localctx = NewRuleOctetStringTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, asn1ParserRULE_ruleOctetStringType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1293)
		p.Match(asn1ParserOCTET_SYM)
	}
	{
		p.SetState(1294)
		p.Match(asn1ParserSTRING_SYM)
	}

	return localctx
}

// IRuleRealTypeContext is an interface to support dynamic dispatch.
type IRuleRealTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleRealTypeContext differentiates from other interfaces.
	IsRuleRealTypeContext()
}

type RuleRealTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleRealTypeContext() *RuleRealTypeContext {
	var p = new(RuleRealTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleRealType
	return p
}

func (*RuleRealTypeContext) IsRuleRealTypeContext() {}

func NewRuleRealTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleRealTypeContext {
	var p = new(RuleRealTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleRealType

	return p
}

func (s *RuleRealTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleRealTypeContext) REAL_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserREAL_SYM, 0)
}

func (s *RuleRealTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleRealTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleRealTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleRealType(s)
	}
}

func (s *RuleRealTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleRealType(s)
	}
}

func (s *RuleRealTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleRealType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleRealType() (localctx IRuleRealTypeContext) {
	this := p
	_ = this

	localctx = NewRuleRealTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, asn1ParserRULE_ruleRealType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1296)
		p.Match(asn1ParserREAL_SYM)
	}

	return localctx
}

// IRuleRelativeIRITypeContext is an interface to support dynamic dispatch.
type IRuleRelativeIRITypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleRelativeIRITypeContext differentiates from other interfaces.
	IsRuleRelativeIRITypeContext()
}

type RuleRelativeIRITypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleRelativeIRITypeContext() *RuleRelativeIRITypeContext {
	var p = new(RuleRelativeIRITypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleRelativeIRIType
	return p
}

func (*RuleRelativeIRITypeContext) IsRuleRelativeIRITypeContext() {}

func NewRuleRelativeIRITypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleRelativeIRITypeContext {
	var p = new(RuleRelativeIRITypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleRelativeIRIType

	return p
}

func (s *RuleRelativeIRITypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleRelativeIRITypeContext) RELATIVE_OID_IRI_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserRELATIVE_OID_IRI_SYM, 0)
}

func (s *RuleRelativeIRITypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleRelativeIRITypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleRelativeIRITypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleRelativeIRIType(s)
	}
}

func (s *RuleRelativeIRITypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleRelativeIRIType(s)
	}
}

func (s *RuleRelativeIRITypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleRelativeIRIType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleRelativeIRIType() (localctx IRuleRelativeIRITypeContext) {
	this := p
	_ = this

	localctx = NewRuleRelativeIRITypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, asn1ParserRULE_ruleRelativeIRIType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1298)
		p.Match(asn1ParserRELATIVE_OID_IRI_SYM)
	}

	return localctx
}

// IRuleRelativeOIDTypeContext is an interface to support dynamic dispatch.
type IRuleRelativeOIDTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleRelativeOIDTypeContext differentiates from other interfaces.
	IsRuleRelativeOIDTypeContext()
}

type RuleRelativeOIDTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleRelativeOIDTypeContext() *RuleRelativeOIDTypeContext {
	var p = new(RuleRelativeOIDTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleRelativeOIDType
	return p
}

func (*RuleRelativeOIDTypeContext) IsRuleRelativeOIDTypeContext() {}

func NewRuleRelativeOIDTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleRelativeOIDTypeContext {
	var p = new(RuleRelativeOIDTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleRelativeOIDType

	return p
}

func (s *RuleRelativeOIDTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleRelativeOIDTypeContext) RELATIVE_OID_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserRELATIVE_OID_SYM, 0)
}

func (s *RuleRelativeOIDTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleRelativeOIDTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleRelativeOIDTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleRelativeOIDType(s)
	}
}

func (s *RuleRelativeOIDTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleRelativeOIDType(s)
	}
}

func (s *RuleRelativeOIDTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleRelativeOIDType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleRelativeOIDType() (localctx IRuleRelativeOIDTypeContext) {
	this := p
	_ = this

	localctx = NewRuleRelativeOIDTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, asn1ParserRULE_ruleRelativeOIDType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1300)
		p.Match(asn1ParserRELATIVE_OID_SYM)
	}

	return localctx
}

// IRuleSequenceTypeContext is an interface to support dynamic dispatch.
type IRuleSequenceTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleSequenceTypeContext differentiates from other interfaces.
	IsRuleSequenceTypeContext()
}

type RuleSequenceTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleSequenceTypeContext() *RuleSequenceTypeContext {
	var p = new(RuleSequenceTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleSequenceType
	return p
}

func (*RuleSequenceTypeContext) IsRuleSequenceTypeContext() {}

func NewRuleSequenceTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleSequenceTypeContext {
	var p = new(RuleSequenceTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleSequenceType

	return p
}

func (s *RuleSequenceTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleSequenceTypeContext) SEQUENCE_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserSEQUENCE_SYM, 0)
}

func (s *RuleSequenceTypeContext) CURLY_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_START, 0)
}

func (s *RuleSequenceTypeContext) CURLY_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_END, 0)
}

func (s *RuleSequenceTypeContext) RuleExtensionAndException() IRuleExtensionAndExceptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleExtensionAndExceptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleExtensionAndExceptionContext)
}

func (s *RuleSequenceTypeContext) RuleOptionalExtensionMarker() IRuleOptionalExtensionMarkerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleOptionalExtensionMarkerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleOptionalExtensionMarkerContext)
}

func (s *RuleSequenceTypeContext) RuleComponentTypeLists() IRuleComponentTypeListsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleComponentTypeListsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleComponentTypeListsContext)
}

func (s *RuleSequenceTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleSequenceTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleSequenceTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleSequenceType(s)
	}
}

func (s *RuleSequenceTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleSequenceType(s)
	}
}

func (s *RuleSequenceTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleSequenceType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleSequenceType() (localctx IRuleSequenceTypeContext) {
	this := p
	_ = this

	localctx = NewRuleSequenceTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, asn1ParserRULE_ruleSequenceType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1316)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1302)
			p.Match(asn1ParserSEQUENCE_SYM)
		}
		{
			p.SetState(1303)
			p.Match(asn1ParserCURLY_START)
		}
		{
			p.SetState(1304)
			p.Match(asn1ParserCURLY_END)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1305)
			p.Match(asn1ParserSEQUENCE_SYM)
		}
		{
			p.SetState(1306)
			p.Match(asn1ParserCURLY_START)
		}
		{
			p.SetState(1307)
			p.RuleExtensionAndException()
		}
		{
			p.SetState(1308)
			p.RuleOptionalExtensionMarker()
		}
		{
			p.SetState(1309)
			p.Match(asn1ParserCURLY_END)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1311)
			p.Match(asn1ParserSEQUENCE_SYM)
		}
		{
			p.SetState(1312)
			p.Match(asn1ParserCURLY_START)
		}
		{
			p.SetState(1313)
			p.RuleComponentTypeLists()
		}
		{
			p.SetState(1314)
			p.Match(asn1ParserCURLY_END)
		}

	}

	return localctx
}

// IRuleSequenceOfTypeContext is an interface to support dynamic dispatch.
type IRuleSequenceOfTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleSequenceOfTypeContext differentiates from other interfaces.
	IsRuleSequenceOfTypeContext()
}

type RuleSequenceOfTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleSequenceOfTypeContext() *RuleSequenceOfTypeContext {
	var p = new(RuleSequenceOfTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleSequenceOfType
	return p
}

func (*RuleSequenceOfTypeContext) IsRuleSequenceOfTypeContext() {}

func NewRuleSequenceOfTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleSequenceOfTypeContext {
	var p = new(RuleSequenceOfTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleSequenceOfType

	return p
}

func (s *RuleSequenceOfTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleSequenceOfTypeContext) SEQUENCE_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserSEQUENCE_SYM, 0)
}

func (s *RuleSequenceOfTypeContext) OF_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserOF_SYM, 0)
}

func (s *RuleSequenceOfTypeContext) RuleNamedType() IRuleNamedTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleNamedTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleNamedTypeContext)
}

func (s *RuleSequenceOfTypeContext) RuleType() IRuleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeContext)
}

func (s *RuleSequenceOfTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleSequenceOfTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleSequenceOfTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleSequenceOfType(s)
	}
}

func (s *RuleSequenceOfTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleSequenceOfType(s)
	}
}

func (s *RuleSequenceOfTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleSequenceOfType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleSequenceOfType() (localctx IRuleSequenceOfTypeContext) {
	this := p
	_ = this

	localctx = NewRuleSequenceOfTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, asn1ParserRULE_ruleSequenceOfType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1324)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1318)
			p.Match(asn1ParserSEQUENCE_SYM)
		}
		{
			p.SetState(1319)
			p.Match(asn1ParserOF_SYM)
		}
		{
			p.SetState(1320)
			p.RuleNamedType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1321)
			p.Match(asn1ParserSEQUENCE_SYM)
		}
		{
			p.SetState(1322)
			p.Match(asn1ParserOF_SYM)
		}
		{
			p.SetState(1323)
			p.RuleType()
		}

	}

	return localctx
}

// IRuleSetTypeContext is an interface to support dynamic dispatch.
type IRuleSetTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleSetTypeContext differentiates from other interfaces.
	IsRuleSetTypeContext()
}

type RuleSetTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleSetTypeContext() *RuleSetTypeContext {
	var p = new(RuleSetTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleSetType
	return p
}

func (*RuleSetTypeContext) IsRuleSetTypeContext() {}

func NewRuleSetTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleSetTypeContext {
	var p = new(RuleSetTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleSetType

	return p
}

func (s *RuleSetTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleSetTypeContext) SET_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserSET_SYM, 0)
}

func (s *RuleSetTypeContext) CURLY_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_START, 0)
}

func (s *RuleSetTypeContext) RuleComponentTypeLists() IRuleComponentTypeListsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleComponentTypeListsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleComponentTypeListsContext)
}

func (s *RuleSetTypeContext) CURLY_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_END, 0)
}

func (s *RuleSetTypeContext) RuleExtensionAndException() IRuleExtensionAndExceptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleExtensionAndExceptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleExtensionAndExceptionContext)
}

func (s *RuleSetTypeContext) RuleOptionalExtensionMarker() IRuleOptionalExtensionMarkerContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleOptionalExtensionMarkerContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleOptionalExtensionMarkerContext)
}

func (s *RuleSetTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleSetTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleSetTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleSetType(s)
	}
}

func (s *RuleSetTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleSetType(s)
	}
}

func (s *RuleSetTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleSetType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleSetType() (localctx IRuleSetTypeContext) {
	this := p
	_ = this

	localctx = NewRuleSetTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, asn1ParserRULE_ruleSetType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1340)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1326)
			p.Match(asn1ParserSET_SYM)
		}
		{
			p.SetState(1327)
			p.Match(asn1ParserCURLY_START)
		}
		{
			p.SetState(1328)
			p.RuleComponentTypeLists()
		}
		{
			p.SetState(1329)
			p.Match(asn1ParserCURLY_END)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1331)
			p.Match(asn1ParserSET_SYM)
		}
		{
			p.SetState(1332)
			p.Match(asn1ParserCURLY_START)
		}
		{
			p.SetState(1333)
			p.RuleExtensionAndException()
		}
		{
			p.SetState(1334)
			p.RuleOptionalExtensionMarker()
		}
		{
			p.SetState(1335)
			p.Match(asn1ParserCURLY_END)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1337)
			p.Match(asn1ParserSET_SYM)
		}
		{
			p.SetState(1338)
			p.Match(asn1ParserCURLY_START)
		}
		{
			p.SetState(1339)
			p.Match(asn1ParserCURLY_END)
		}

	}

	return localctx
}

// IRuleSetOfTypeContext is an interface to support dynamic dispatch.
type IRuleSetOfTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleSetOfTypeContext differentiates from other interfaces.
	IsRuleSetOfTypeContext()
}

type RuleSetOfTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleSetOfTypeContext() *RuleSetOfTypeContext {
	var p = new(RuleSetOfTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleSetOfType
	return p
}

func (*RuleSetOfTypeContext) IsRuleSetOfTypeContext() {}

func NewRuleSetOfTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleSetOfTypeContext {
	var p = new(RuleSetOfTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleSetOfType

	return p
}

func (s *RuleSetOfTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleSetOfTypeContext) SET_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserSET_SYM, 0)
}

func (s *RuleSetOfTypeContext) OF_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserOF_SYM, 0)
}

func (s *RuleSetOfTypeContext) RuleNamedType() IRuleNamedTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleNamedTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleNamedTypeContext)
}

func (s *RuleSetOfTypeContext) RuleType() IRuleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeContext)
}

func (s *RuleSetOfTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleSetOfTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleSetOfTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleSetOfType(s)
	}
}

func (s *RuleSetOfTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleSetOfType(s)
	}
}

func (s *RuleSetOfTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleSetOfType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleSetOfType() (localctx IRuleSetOfTypeContext) {
	this := p
	_ = this

	localctx = NewRuleSetOfTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, asn1ParserRULE_ruleSetOfType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1348)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 58, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1342)
			p.Match(asn1ParserSET_SYM)
		}
		{
			p.SetState(1343)
			p.Match(asn1ParserOF_SYM)
		}
		{
			p.SetState(1344)
			p.RuleNamedType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1345)
			p.Match(asn1ParserSET_SYM)
		}
		{
			p.SetState(1346)
			p.Match(asn1ParserOF_SYM)
		}
		{
			p.SetState(1347)
			p.RuleType()
		}

	}

	return localctx
}

// IRulePrefixedTypeContext is an interface to support dynamic dispatch.
type IRulePrefixedTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRulePrefixedTypeContext differentiates from other interfaces.
	IsRulePrefixedTypeContext()
}

type RulePrefixedTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRulePrefixedTypeContext() *RulePrefixedTypeContext {
	var p = new(RulePrefixedTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_rulePrefixedType
	return p
}

func (*RulePrefixedTypeContext) IsRulePrefixedTypeContext() {}

func NewRulePrefixedTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RulePrefixedTypeContext {
	var p = new(RulePrefixedTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_rulePrefixedType

	return p
}

func (s *RulePrefixedTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RulePrefixedTypeContext) RuleTaggedType() IRuleTaggedTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTaggedTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTaggedTypeContext)
}

func (s *RulePrefixedTypeContext) RuleEncodingPrefixedType() IRuleEncodingPrefixedTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleEncodingPrefixedTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleEncodingPrefixedTypeContext)
}

func (s *RulePrefixedTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RulePrefixedTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RulePrefixedTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRulePrefixedType(s)
	}
}

func (s *RulePrefixedTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRulePrefixedType(s)
	}
}

func (s *RulePrefixedTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRulePrefixedType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RulePrefixedType() (localctx IRulePrefixedTypeContext) {
	this := p
	_ = this

	localctx = NewRulePrefixedTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, asn1ParserRULE_rulePrefixedType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1352)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 59, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1350)
			p.RuleTaggedType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1351)
			p.RuleEncodingPrefixedType()
		}

	}

	return localctx
}

// IRuleTimeTypeContext is an interface to support dynamic dispatch.
type IRuleTimeTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleTimeTypeContext differentiates from other interfaces.
	IsRuleTimeTypeContext()
}

type RuleTimeTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleTimeTypeContext() *RuleTimeTypeContext {
	var p = new(RuleTimeTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleTimeType
	return p
}

func (*RuleTimeTypeContext) IsRuleTimeTypeContext() {}

func NewRuleTimeTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleTimeTypeContext {
	var p = new(RuleTimeTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleTimeType

	return p
}

func (s *RuleTimeTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleTimeTypeContext) TIME_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserTIME_SYM, 0)
}

func (s *RuleTimeTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleTimeTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleTimeTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleTimeType(s)
	}
}

func (s *RuleTimeTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleTimeType(s)
	}
}

func (s *RuleTimeTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleTimeType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleTimeType() (localctx IRuleTimeTypeContext) {
	this := p
	_ = this

	localctx = NewRuleTimeTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, asn1ParserRULE_ruleTimeType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1354)
		p.Match(asn1ParserTIME_SYM)
	}

	return localctx
}

// IRuleTimeOfDayTypeContext is an interface to support dynamic dispatch.
type IRuleTimeOfDayTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleTimeOfDayTypeContext differentiates from other interfaces.
	IsRuleTimeOfDayTypeContext()
}

type RuleTimeOfDayTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleTimeOfDayTypeContext() *RuleTimeOfDayTypeContext {
	var p = new(RuleTimeOfDayTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleTimeOfDayType
	return p
}

func (*RuleTimeOfDayTypeContext) IsRuleTimeOfDayTypeContext() {}

func NewRuleTimeOfDayTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleTimeOfDayTypeContext {
	var p = new(RuleTimeOfDayTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleTimeOfDayType

	return p
}

func (s *RuleTimeOfDayTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleTimeOfDayTypeContext) TIME_OF_DAY_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserTIME_OF_DAY_SYM, 0)
}

func (s *RuleTimeOfDayTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleTimeOfDayTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleTimeOfDayTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleTimeOfDayType(s)
	}
}

func (s *RuleTimeOfDayTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleTimeOfDayType(s)
	}
}

func (s *RuleTimeOfDayTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleTimeOfDayType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleTimeOfDayType() (localctx IRuleTimeOfDayTypeContext) {
	this := p
	_ = this

	localctx = NewRuleTimeOfDayTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, asn1ParserRULE_ruleTimeOfDayType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1356)
		p.Match(asn1ParserTIME_OF_DAY_SYM)
	}

	return localctx
}

// IRuleBuiltinTypeContext is an interface to support dynamic dispatch.
type IRuleBuiltinTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleBuiltinTypeContext differentiates from other interfaces.
	IsRuleBuiltinTypeContext()
}

type RuleBuiltinTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleBuiltinTypeContext() *RuleBuiltinTypeContext {
	var p = new(RuleBuiltinTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleBuiltinType
	return p
}

func (*RuleBuiltinTypeContext) IsRuleBuiltinTypeContext() {}

func NewRuleBuiltinTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleBuiltinTypeContext {
	var p = new(RuleBuiltinTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleBuiltinType

	return p
}

func (s *RuleBuiltinTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleBuiltinTypeContext) RuleBitStringType() IRuleBitStringTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleBitStringTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleBitStringTypeContext)
}

func (s *RuleBuiltinTypeContext) RuleBooleanType() IRuleBooleanTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleBooleanTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleBooleanTypeContext)
}

func (s *RuleBuiltinTypeContext) RuleCharacterStringType() IRuleCharacterStringTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleCharacterStringTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleCharacterStringTypeContext)
}

func (s *RuleBuiltinTypeContext) RuleChoiceType() IRuleChoiceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleChoiceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleChoiceTypeContext)
}

func (s *RuleBuiltinTypeContext) RuleDateType() IRuleDateTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDateTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDateTypeContext)
}

func (s *RuleBuiltinTypeContext) RuleDateTimeType() IRuleDateTimeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDateTimeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDateTimeTypeContext)
}

func (s *RuleBuiltinTypeContext) RuleDurationType() IRuleDurationTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDurationTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDurationTypeContext)
}

func (s *RuleBuiltinTypeContext) RuleEmbeddedPDVType() IRuleEmbeddedPDVTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleEmbeddedPDVTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleEmbeddedPDVTypeContext)
}

func (s *RuleBuiltinTypeContext) RuleEnumeratedType() IRuleEnumeratedTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleEnumeratedTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleEnumeratedTypeContext)
}

func (s *RuleBuiltinTypeContext) RuleExternalType() IRuleExternalTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleExternalTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleExternalTypeContext)
}

func (s *RuleBuiltinTypeContext) RuleInstanceOfType() IRuleInstanceOfTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleInstanceOfTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleInstanceOfTypeContext)
}

func (s *RuleBuiltinTypeContext) RuleIntegerType() IRuleIntegerTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleIntegerTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleIntegerTypeContext)
}

func (s *RuleBuiltinTypeContext) RuleIRIType() IRuleIRITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleIRITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleIRITypeContext)
}

func (s *RuleBuiltinTypeContext) RuleNullType() IRuleNullTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleNullTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleNullTypeContext)
}

func (s *RuleBuiltinTypeContext) RuleObjectClassFieldType() IRuleObjectClassFieldTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectClassFieldTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectClassFieldTypeContext)
}

func (s *RuleBuiltinTypeContext) RuleObjectIdentifierType() IRuleObjectIdentifierTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectIdentifierTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectIdentifierTypeContext)
}

func (s *RuleBuiltinTypeContext) RuleOctetStringType() IRuleOctetStringTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleOctetStringTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleOctetStringTypeContext)
}

func (s *RuleBuiltinTypeContext) RuleRealType() IRuleRealTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleRealTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleRealTypeContext)
}

func (s *RuleBuiltinTypeContext) RuleRelativeIRIType() IRuleRelativeIRITypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleRelativeIRITypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleRelativeIRITypeContext)
}

func (s *RuleBuiltinTypeContext) RuleRelativeOIDType() IRuleRelativeOIDTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleRelativeOIDTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleRelativeOIDTypeContext)
}

func (s *RuleBuiltinTypeContext) RuleSequenceType() IRuleSequenceTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSequenceTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSequenceTypeContext)
}

func (s *RuleBuiltinTypeContext) RuleSequenceOfType() IRuleSequenceOfTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSequenceOfTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSequenceOfTypeContext)
}

func (s *RuleBuiltinTypeContext) RuleSetType() IRuleSetTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSetTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSetTypeContext)
}

func (s *RuleBuiltinTypeContext) RuleSetOfType() IRuleSetOfTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSetOfTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSetOfTypeContext)
}

func (s *RuleBuiltinTypeContext) RuleTimeType() IRuleTimeTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTimeTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTimeTypeContext)
}

func (s *RuleBuiltinTypeContext) RuleTimeOfDayType() IRuleTimeOfDayTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTimeOfDayTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTimeOfDayTypeContext)
}

func (s *RuleBuiltinTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleBuiltinTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleBuiltinTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleBuiltinType(s)
	}
}

func (s *RuleBuiltinTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleBuiltinType(s)
	}
}

func (s *RuleBuiltinTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleBuiltinType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleBuiltinType() (localctx IRuleBuiltinTypeContext) {
	this := p
	_ = this

	localctx = NewRuleBuiltinTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, asn1ParserRULE_ruleBuiltinType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1384)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 60, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1358)
			p.RuleBitStringType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1359)
			p.RuleBooleanType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1360)
			p.RuleCharacterStringType()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1361)
			p.RuleChoiceType()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1362)
			p.RuleDateType()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1363)
			p.RuleDateTimeType()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1364)
			p.RuleDurationType()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1365)
			p.RuleEmbeddedPDVType()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1366)
			p.RuleEnumeratedType()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1367)
			p.RuleExternalType()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1368)
			p.RuleInstanceOfType()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1369)
			p.RuleIntegerType()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1370)
			p.RuleIRIType()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1371)
			p.RuleNullType()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1372)
			p.RuleObjectClassFieldType()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1373)
			p.RuleObjectIdentifierType()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1374)
			p.RuleOctetStringType()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1375)
			p.RuleRealType()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1376)
			p.RuleRelativeIRIType()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1377)
			p.RuleRelativeOIDType()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1378)
			p.RuleSequenceType()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1379)
			p.RuleSequenceOfType()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1380)
			p.RuleSetType()
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(1381)
			p.RuleSetOfType()
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(1382)
			p.RuleTimeType()
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(1383)
			p.RuleTimeOfDayType()
		}

	}

	return localctx
}

// IRuleSimpleDefinedTypeContext is an interface to support dynamic dispatch.
type IRuleSimpleDefinedTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleSimpleDefinedTypeContext differentiates from other interfaces.
	IsRuleSimpleDefinedTypeContext()
}

type RuleSimpleDefinedTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleSimpleDefinedTypeContext() *RuleSimpleDefinedTypeContext {
	var p = new(RuleSimpleDefinedTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleSimpleDefinedType
	return p
}

func (*RuleSimpleDefinedTypeContext) IsRuleSimpleDefinedTypeContext() {}

func NewRuleSimpleDefinedTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleSimpleDefinedTypeContext {
	var p = new(RuleSimpleDefinedTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleSimpleDefinedType

	return p
}

func (s *RuleSimpleDefinedTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleSimpleDefinedTypeContext) RuleExternalTypeReference() IRuleExternalTypeReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleExternalTypeReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleExternalTypeReferenceContext)
}

func (s *RuleSimpleDefinedTypeContext) RuleTypeReference() IRuleTypeReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeReferenceContext)
}

func (s *RuleSimpleDefinedTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleSimpleDefinedTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleSimpleDefinedTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleSimpleDefinedType(s)
	}
}

func (s *RuleSimpleDefinedTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleSimpleDefinedType(s)
	}
}

func (s *RuleSimpleDefinedTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleSimpleDefinedType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleSimpleDefinedType() (localctx IRuleSimpleDefinedTypeContext) {
	this := p
	_ = this

	localctx = NewRuleSimpleDefinedTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, asn1ParserRULE_ruleSimpleDefinedType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1388)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 61, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1386)
			p.RuleExternalTypeReference()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1387)
			p.RuleTypeReference()
		}

	}

	return localctx
}

// IRuleParameterizedTypeContext is an interface to support dynamic dispatch.
type IRuleParameterizedTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleParameterizedTypeContext differentiates from other interfaces.
	IsRuleParameterizedTypeContext()
}

type RuleParameterizedTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleParameterizedTypeContext() *RuleParameterizedTypeContext {
	var p = new(RuleParameterizedTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleParameterizedType
	return p
}

func (*RuleParameterizedTypeContext) IsRuleParameterizedTypeContext() {}

func NewRuleParameterizedTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleParameterizedTypeContext {
	var p = new(RuleParameterizedTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleParameterizedType

	return p
}

func (s *RuleParameterizedTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleParameterizedTypeContext) RuleSimpleDefinedType() IRuleSimpleDefinedTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSimpleDefinedTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSimpleDefinedTypeContext)
}

func (s *RuleParameterizedTypeContext) RuleActualParameterList() IRuleActualParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleActualParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleActualParameterListContext)
}

func (s *RuleParameterizedTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleParameterizedTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleParameterizedTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleParameterizedType(s)
	}
}

func (s *RuleParameterizedTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleParameterizedType(s)
	}
}

func (s *RuleParameterizedTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleParameterizedType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleParameterizedType() (localctx IRuleParameterizedTypeContext) {
	this := p
	_ = this

	localctx = NewRuleParameterizedTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, asn1ParserRULE_ruleParameterizedType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1390)
		p.RuleSimpleDefinedType()
	}
	{
		p.SetState(1391)
		p.RuleActualParameterList()
	}

	return localctx
}

// IRuleParameterizedValueSetTypeContext is an interface to support dynamic dispatch.
type IRuleParameterizedValueSetTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleParameterizedValueSetTypeContext differentiates from other interfaces.
	IsRuleParameterizedValueSetTypeContext()
}

type RuleParameterizedValueSetTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleParameterizedValueSetTypeContext() *RuleParameterizedValueSetTypeContext {
	var p = new(RuleParameterizedValueSetTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleParameterizedValueSetType
	return p
}

func (*RuleParameterizedValueSetTypeContext) IsRuleParameterizedValueSetTypeContext() {}

func NewRuleParameterizedValueSetTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleParameterizedValueSetTypeContext {
	var p = new(RuleParameterizedValueSetTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleParameterizedValueSetType

	return p
}

func (s *RuleParameterizedValueSetTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleParameterizedValueSetTypeContext) RuleSimpleDefinedType() IRuleSimpleDefinedTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSimpleDefinedTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSimpleDefinedTypeContext)
}

func (s *RuleParameterizedValueSetTypeContext) RuleActualParameterList() IRuleActualParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleActualParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleActualParameterListContext)
}

func (s *RuleParameterizedValueSetTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleParameterizedValueSetTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleParameterizedValueSetTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleParameterizedValueSetType(s)
	}
}

func (s *RuleParameterizedValueSetTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleParameterizedValueSetType(s)
	}
}

func (s *RuleParameterizedValueSetTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleParameterizedValueSetType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleParameterizedValueSetType() (localctx IRuleParameterizedValueSetTypeContext) {
	this := p
	_ = this

	localctx = NewRuleParameterizedValueSetTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, asn1ParserRULE_ruleParameterizedValueSetType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1393)
		p.RuleSimpleDefinedType()
	}
	{
		p.SetState(1394)
		p.RuleActualParameterList()
	}

	return localctx
}

// IRuleDefinedTypeContext is an interface to support dynamic dispatch.
type IRuleDefinedTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleDefinedTypeContext differentiates from other interfaces.
	IsRuleDefinedTypeContext()
}

type RuleDefinedTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleDefinedTypeContext() *RuleDefinedTypeContext {
	var p = new(RuleDefinedTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleDefinedType
	return p
}

func (*RuleDefinedTypeContext) IsRuleDefinedTypeContext() {}

func NewRuleDefinedTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleDefinedTypeContext {
	var p = new(RuleDefinedTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleDefinedType

	return p
}

func (s *RuleDefinedTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleDefinedTypeContext) RuleExternalTypeReference() IRuleExternalTypeReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleExternalTypeReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleExternalTypeReferenceContext)
}

func (s *RuleDefinedTypeContext) RuleTypeReference() IRuleTypeReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeReferenceContext)
}

func (s *RuleDefinedTypeContext) RuleParameterizedType() IRuleParameterizedTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleParameterizedTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleParameterizedTypeContext)
}

func (s *RuleDefinedTypeContext) RuleParameterizedValueSetType() IRuleParameterizedValueSetTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleParameterizedValueSetTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleParameterizedValueSetTypeContext)
}

func (s *RuleDefinedTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleDefinedTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleDefinedTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleDefinedType(s)
	}
}

func (s *RuleDefinedTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleDefinedType(s)
	}
}

func (s *RuleDefinedTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleDefinedType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleDefinedType() (localctx IRuleDefinedTypeContext) {
	this := p
	_ = this

	localctx = NewRuleDefinedTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, asn1ParserRULE_ruleDefinedType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1400)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1396)
			p.RuleExternalTypeReference()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1397)
			p.RuleTypeReference()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1398)
			p.RuleParameterizedType()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1399)
			p.RuleParameterizedValueSetType()
		}

	}

	return localctx
}

// IRuleUsefulTypeContext is an interface to support dynamic dispatch.
type IRuleUsefulTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleUsefulTypeContext differentiates from other interfaces.
	IsRuleUsefulTypeContext()
}

type RuleUsefulTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleUsefulTypeContext() *RuleUsefulTypeContext {
	var p = new(RuleUsefulTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleUsefulType
	return p
}

func (*RuleUsefulTypeContext) IsRuleUsefulTypeContext() {}

func NewRuleUsefulTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleUsefulTypeContext {
	var p = new(RuleUsefulTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleUsefulType

	return p
}

func (s *RuleUsefulTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleUsefulTypeContext) GENERALIZED_TIME_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserGENERALIZED_TIME_SYM, 0)
}

func (s *RuleUsefulTypeContext) UTC_TIME_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserUTC_TIME_SYM, 0)
}

func (s *RuleUsefulTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleUsefulTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleUsefulTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleUsefulType(s)
	}
}

func (s *RuleUsefulTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleUsefulType(s)
	}
}

func (s *RuleUsefulTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleUsefulType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleUsefulType() (localctx IRuleUsefulTypeContext) {
	this := p
	_ = this

	localctx = NewRuleUsefulTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, asn1ParserRULE_ruleUsefulType)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1402)
		_la = p.GetTokenStream().LA(1)

		if !(_la == asn1ParserGENERALIZED_TIME_SYM || _la == asn1ParserUTC_TIME_SYM) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IRuleSelectionTypeContext is an interface to support dynamic dispatch.
type IRuleSelectionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleSelectionTypeContext differentiates from other interfaces.
	IsRuleSelectionTypeContext()
}

type RuleSelectionTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleSelectionTypeContext() *RuleSelectionTypeContext {
	var p = new(RuleSelectionTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleSelectionType
	return p
}

func (*RuleSelectionTypeContext) IsRuleSelectionTypeContext() {}

func NewRuleSelectionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleSelectionTypeContext {
	var p = new(RuleSelectionTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleSelectionType

	return p
}

func (s *RuleSelectionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleSelectionTypeContext) RuleIdentifier() IRuleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleIdentifierContext)
}

func (s *RuleSelectionTypeContext) LESS() antlr.TerminalNode {
	return s.GetToken(asn1ParserLESS, 0)
}

func (s *RuleSelectionTypeContext) RuleType() IRuleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeContext)
}

func (s *RuleSelectionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleSelectionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleSelectionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleSelectionType(s)
	}
}

func (s *RuleSelectionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleSelectionType(s)
	}
}

func (s *RuleSelectionTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleSelectionType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleSelectionType() (localctx IRuleSelectionTypeContext) {
	this := p
	_ = this

	localctx = NewRuleSelectionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, asn1ParserRULE_ruleSelectionType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1404)
		p.RuleIdentifier()
	}
	{
		p.SetState(1405)
		p.Match(asn1ParserLESS)
	}
	{
		p.SetState(1406)
		p.RuleType()
	}

	return localctx
}

// IRuleTypeFromObjectContext is an interface to support dynamic dispatch.
type IRuleTypeFromObjectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleTypeFromObjectContext differentiates from other interfaces.
	IsRuleTypeFromObjectContext()
}

type RuleTypeFromObjectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleTypeFromObjectContext() *RuleTypeFromObjectContext {
	var p = new(RuleTypeFromObjectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleTypeFromObject
	return p
}

func (*RuleTypeFromObjectContext) IsRuleTypeFromObjectContext() {}

func NewRuleTypeFromObjectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleTypeFromObjectContext {
	var p = new(RuleTypeFromObjectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleTypeFromObject

	return p
}

func (s *RuleTypeFromObjectContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleTypeFromObjectContext) RuleReferencedObjects() IRuleReferencedObjectsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleReferencedObjectsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleReferencedObjectsContext)
}

func (s *RuleTypeFromObjectContext) DOT() antlr.TerminalNode {
	return s.GetToken(asn1ParserDOT, 0)
}

func (s *RuleTypeFromObjectContext) RuleFieldName() IRuleFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleFieldNameContext)
}

func (s *RuleTypeFromObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleTypeFromObjectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleTypeFromObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleTypeFromObject(s)
	}
}

func (s *RuleTypeFromObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleTypeFromObject(s)
	}
}

func (s *RuleTypeFromObjectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleTypeFromObject(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleTypeFromObject() (localctx IRuleTypeFromObjectContext) {
	this := p
	_ = this

	localctx = NewRuleTypeFromObjectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, asn1ParserRULE_ruleTypeFromObject)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1408)
		p.RuleReferencedObjects()
	}
	{
		p.SetState(1409)
		p.Match(asn1ParserDOT)
	}
	{
		p.SetState(1410)
		p.ruleFieldName(0)
	}

	return localctx
}

// IRuleValueSetFromObjectsContext is an interface to support dynamic dispatch.
type IRuleValueSetFromObjectsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleValueSetFromObjectsContext differentiates from other interfaces.
	IsRuleValueSetFromObjectsContext()
}

type RuleValueSetFromObjectsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleValueSetFromObjectsContext() *RuleValueSetFromObjectsContext {
	var p = new(RuleValueSetFromObjectsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleValueSetFromObjects
	return p
}

func (*RuleValueSetFromObjectsContext) IsRuleValueSetFromObjectsContext() {}

func NewRuleValueSetFromObjectsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleValueSetFromObjectsContext {
	var p = new(RuleValueSetFromObjectsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleValueSetFromObjects

	return p
}

func (s *RuleValueSetFromObjectsContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleValueSetFromObjectsContext) RuleReferencedObjects() IRuleReferencedObjectsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleReferencedObjectsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleReferencedObjectsContext)
}

func (s *RuleValueSetFromObjectsContext) DOT() antlr.TerminalNode {
	return s.GetToken(asn1ParserDOT, 0)
}

func (s *RuleValueSetFromObjectsContext) RuleFieldName() IRuleFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleFieldNameContext)
}

func (s *RuleValueSetFromObjectsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleValueSetFromObjectsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleValueSetFromObjectsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleValueSetFromObjects(s)
	}
}

func (s *RuleValueSetFromObjectsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleValueSetFromObjects(s)
	}
}

func (s *RuleValueSetFromObjectsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleValueSetFromObjects(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleValueSetFromObjects() (localctx IRuleValueSetFromObjectsContext) {
	this := p
	_ = this

	localctx = NewRuleValueSetFromObjectsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, asn1ParserRULE_ruleValueSetFromObjects)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1412)
		p.RuleReferencedObjects()
	}
	{
		p.SetState(1413)
		p.Match(asn1ParserDOT)
	}
	{
		p.SetState(1414)
		p.ruleFieldName(0)
	}

	return localctx
}

// IRuleReferencedTypeContext is an interface to support dynamic dispatch.
type IRuleReferencedTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleReferencedTypeContext differentiates from other interfaces.
	IsRuleReferencedTypeContext()
}

type RuleReferencedTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleReferencedTypeContext() *RuleReferencedTypeContext {
	var p = new(RuleReferencedTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleReferencedType
	return p
}

func (*RuleReferencedTypeContext) IsRuleReferencedTypeContext() {}

func NewRuleReferencedTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleReferencedTypeContext {
	var p = new(RuleReferencedTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleReferencedType

	return p
}

func (s *RuleReferencedTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleReferencedTypeContext) RuleDefinedType() IRuleDefinedTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinedTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinedTypeContext)
}

func (s *RuleReferencedTypeContext) RuleUsefulType() IRuleUsefulTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleUsefulTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleUsefulTypeContext)
}

func (s *RuleReferencedTypeContext) RuleSelectionType() IRuleSelectionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSelectionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSelectionTypeContext)
}

func (s *RuleReferencedTypeContext) RuleTypeFromObject() IRuleTypeFromObjectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeFromObjectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeFromObjectContext)
}

func (s *RuleReferencedTypeContext) RuleValueSetFromObjects() IRuleValueSetFromObjectsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueSetFromObjectsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueSetFromObjectsContext)
}

func (s *RuleReferencedTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleReferencedTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleReferencedTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleReferencedType(s)
	}
}

func (s *RuleReferencedTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleReferencedType(s)
	}
}

func (s *RuleReferencedTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleReferencedType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleReferencedType() (localctx IRuleReferencedTypeContext) {
	this := p
	_ = this

	localctx = NewRuleReferencedTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, asn1ParserRULE_ruleReferencedType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1421)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1416)
			p.RuleDefinedType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1417)
			p.RuleUsefulType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1418)
			p.RuleSelectionType()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1419)
			p.RuleTypeFromObject()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1420)
			p.RuleValueSetFromObjects()
		}

	}

	return localctx
}

// IRuleTypeForConstraintContext is an interface to support dynamic dispatch.
type IRuleTypeForConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleTypeForConstraintContext differentiates from other interfaces.
	IsRuleTypeForConstraintContext()
}

type RuleTypeForConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleTypeForConstraintContext() *RuleTypeForConstraintContext {
	var p = new(RuleTypeForConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleTypeForConstraint
	return p
}

func (*RuleTypeForConstraintContext) IsRuleTypeForConstraintContext() {}

func NewRuleTypeForConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleTypeForConstraintContext {
	var p = new(RuleTypeForConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleTypeForConstraint

	return p
}

func (s *RuleTypeForConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleTypeForConstraintContext) RuleBuiltinType() IRuleBuiltinTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleBuiltinTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleBuiltinTypeContext)
}

func (s *RuleTypeForConstraintContext) RuleReferencedType() IRuleReferencedTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleReferencedTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleReferencedTypeContext)
}

func (s *RuleTypeForConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleTypeForConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleTypeForConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleTypeForConstraint(s)
	}
}

func (s *RuleTypeForConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleTypeForConstraint(s)
	}
}

func (s *RuleTypeForConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleTypeForConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleTypeForConstraint() (localctx IRuleTypeForConstraintContext) {
	this := p
	_ = this

	localctx = NewRuleTypeForConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, asn1ParserRULE_ruleTypeForConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1425)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 64, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1423)
			p.RuleBuiltinType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1424)
			p.RuleReferencedType()
		}

	}

	return localctx
}

// IRuleNamedTypeContext is an interface to support dynamic dispatch.
type IRuleNamedTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleNamedTypeContext differentiates from other interfaces.
	IsRuleNamedTypeContext()
}

type RuleNamedTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleNamedTypeContext() *RuleNamedTypeContext {
	var p = new(RuleNamedTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleNamedType
	return p
}

func (*RuleNamedTypeContext) IsRuleNamedTypeContext() {}

func NewRuleNamedTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleNamedTypeContext {
	var p = new(RuleNamedTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleNamedType

	return p
}

func (s *RuleNamedTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleNamedTypeContext) RuleIdentifier() IRuleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleIdentifierContext)
}

func (s *RuleNamedTypeContext) RuleType() IRuleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeContext)
}

func (s *RuleNamedTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleNamedTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleNamedTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleNamedType(s)
	}
}

func (s *RuleNamedTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleNamedType(s)
	}
}

func (s *RuleNamedTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleNamedType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleNamedType() (localctx IRuleNamedTypeContext) {
	this := p
	_ = this

	localctx = NewRuleNamedTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, asn1ParserRULE_ruleNamedType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1427)
		p.RuleIdentifier()
	}
	{
		p.SetState(1428)
		p.RuleType()
	}

	return localctx
}

// IRuleTypeWithConstraintContext is an interface to support dynamic dispatch.
type IRuleTypeWithConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleTypeWithConstraintContext differentiates from other interfaces.
	IsRuleTypeWithConstraintContext()
}

type RuleTypeWithConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleTypeWithConstraintContext() *RuleTypeWithConstraintContext {
	var p = new(RuleTypeWithConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleTypeWithConstraint
	return p
}

func (*RuleTypeWithConstraintContext) IsRuleTypeWithConstraintContext() {}

func NewRuleTypeWithConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleTypeWithConstraintContext {
	var p = new(RuleTypeWithConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleTypeWithConstraint

	return p
}

func (s *RuleTypeWithConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleTypeWithConstraintContext) SET_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserSET_SYM, 0)
}

func (s *RuleTypeWithConstraintContext) RuleConstraint() IRuleConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleConstraintContext)
}

func (s *RuleTypeWithConstraintContext) OF_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserOF_SYM, 0)
}

func (s *RuleTypeWithConstraintContext) RuleType() IRuleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeContext)
}

func (s *RuleTypeWithConstraintContext) RuleSizeConstraint() IRuleSizeConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSizeConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSizeConstraintContext)
}

func (s *RuleTypeWithConstraintContext) SEQUENCE_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserSEQUENCE_SYM, 0)
}

func (s *RuleTypeWithConstraintContext) RuleNamedType() IRuleNamedTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleNamedTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleNamedTypeContext)
}

func (s *RuleTypeWithConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleTypeWithConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleTypeWithConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleTypeWithConstraint(s)
	}
}

func (s *RuleTypeWithConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleTypeWithConstraint(s)
	}
}

func (s *RuleTypeWithConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleTypeWithConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleTypeWithConstraint() (localctx IRuleTypeWithConstraintContext) {
	this := p
	_ = this

	localctx = NewRuleTypeWithConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, asn1ParserRULE_ruleTypeWithConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1470)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1430)
			p.Match(asn1ParserSET_SYM)
		}
		{
			p.SetState(1431)
			p.RuleConstraint()
		}
		{
			p.SetState(1432)
			p.Match(asn1ParserOF_SYM)
		}
		{
			p.SetState(1433)
			p.RuleType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1435)
			p.Match(asn1ParserSET_SYM)
		}
		{
			p.SetState(1436)
			p.RuleSizeConstraint()
		}
		{
			p.SetState(1437)
			p.Match(asn1ParserOF_SYM)
		}
		{
			p.SetState(1438)
			p.RuleType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1440)
			p.Match(asn1ParserSEQUENCE_SYM)
		}
		{
			p.SetState(1441)
			p.RuleConstraint()
		}
		{
			p.SetState(1442)
			p.Match(asn1ParserOF_SYM)
		}
		{
			p.SetState(1443)
			p.RuleType()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1445)
			p.Match(asn1ParserSEQUENCE_SYM)
		}
		{
			p.SetState(1446)
			p.RuleSizeConstraint()
		}
		{
			p.SetState(1447)
			p.Match(asn1ParserOF_SYM)
		}
		{
			p.SetState(1448)
			p.RuleType()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1450)
			p.Match(asn1ParserSET_SYM)
		}
		{
			p.SetState(1451)
			p.RuleConstraint()
		}
		{
			p.SetState(1452)
			p.Match(asn1ParserOF_SYM)
		}
		{
			p.SetState(1453)
			p.RuleNamedType()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1455)
			p.Match(asn1ParserSET_SYM)
		}
		{
			p.SetState(1456)
			p.RuleSizeConstraint()
		}
		{
			p.SetState(1457)
			p.Match(asn1ParserOF_SYM)
		}
		{
			p.SetState(1458)
			p.RuleNamedType()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1460)
			p.Match(asn1ParserSEQUENCE_SYM)
		}
		{
			p.SetState(1461)
			p.RuleConstraint()
		}
		{
			p.SetState(1462)
			p.Match(asn1ParserOF_SYM)
		}
		{
			p.SetState(1463)
			p.RuleNamedType()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1465)
			p.Match(asn1ParserSEQUENCE_SYM)
		}
		{
			p.SetState(1466)
			p.RuleSizeConstraint()
		}
		{
			p.SetState(1467)
			p.Match(asn1ParserOF_SYM)
		}
		{
			p.SetState(1468)
			p.RuleNamedType()
		}

	}

	return localctx
}

// IRuleConstrainedTypeContext is an interface to support dynamic dispatch.
type IRuleConstrainedTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleConstrainedTypeContext differentiates from other interfaces.
	IsRuleConstrainedTypeContext()
}

type RuleConstrainedTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleConstrainedTypeContext() *RuleConstrainedTypeContext {
	var p = new(RuleConstrainedTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleConstrainedType
	return p
}

func (*RuleConstrainedTypeContext) IsRuleConstrainedTypeContext() {}

func NewRuleConstrainedTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleConstrainedTypeContext {
	var p = new(RuleConstrainedTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleConstrainedType

	return p
}

func (s *RuleConstrainedTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleConstrainedTypeContext) RuleTypeForConstraint() IRuleTypeForConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeForConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeForConstraintContext)
}

func (s *RuleConstrainedTypeContext) RuleConstraint() IRuleConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleConstraintContext)
}

func (s *RuleConstrainedTypeContext) RuleTypeWithConstraint() IRuleTypeWithConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeWithConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeWithConstraintContext)
}

func (s *RuleConstrainedTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleConstrainedTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleConstrainedTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleConstrainedType(s)
	}
}

func (s *RuleConstrainedTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleConstrainedType(s)
	}
}

func (s *RuleConstrainedTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleConstrainedType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleConstrainedType() (localctx IRuleConstrainedTypeContext) {
	this := p
	_ = this

	localctx = NewRuleConstrainedTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, asn1ParserRULE_ruleConstrainedType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1476)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1472)
			p.RuleTypeForConstraint()
		}
		{
			p.SetState(1473)
			p.RuleConstraint()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1475)
			p.RuleTypeWithConstraint()
		}

	}

	return localctx
}

// IRuleTypeContext is an interface to support dynamic dispatch.
type IRuleTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleTypeContext differentiates from other interfaces.
	IsRuleTypeContext()
}

type RuleTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleTypeContext() *RuleTypeContext {
	var p = new(RuleTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleType
	return p
}

func (*RuleTypeContext) IsRuleTypeContext() {}

func NewRuleTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleTypeContext {
	var p = new(RuleTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleType

	return p
}

func (s *RuleTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleTypeContext) RuleBuiltinType() IRuleBuiltinTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleBuiltinTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleBuiltinTypeContext)
}

func (s *RuleTypeContext) RuleReferencedType() IRuleReferencedTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleReferencedTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleReferencedTypeContext)
}

func (s *RuleTypeContext) RuleConstrainedType() IRuleConstrainedTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleConstrainedTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleConstrainedTypeContext)
}

func (s *RuleTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleType(s)
	}
}

func (s *RuleTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleType(s)
	}
}

func (s *RuleTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleType() (localctx IRuleTypeContext) {
	this := p
	_ = this

	localctx = NewRuleTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, asn1ParserRULE_ruleType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1481)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1478)
			p.RuleBuiltinType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1479)
			p.RuleReferencedType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1480)
			p.RuleConstrainedType()
		}

	}

	return localctx
}

// IRuleIdentifierListContext is an interface to support dynamic dispatch.
type IRuleIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleIdentifierListContext differentiates from other interfaces.
	IsRuleIdentifierListContext()
}

type RuleIdentifierListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleIdentifierListContext() *RuleIdentifierListContext {
	var p = new(RuleIdentifierListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleIdentifierList
	return p
}

func (*RuleIdentifierListContext) IsRuleIdentifierListContext() {}

func NewRuleIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleIdentifierListContext {
	var p = new(RuleIdentifierListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleIdentifierList

	return p
}

func (s *RuleIdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleIdentifierListContext) RuleIdentifier() IRuleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleIdentifierContext)
}

func (s *RuleIdentifierListContext) RuleIdentifierList() IRuleIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleIdentifierListContext)
}

func (s *RuleIdentifierListContext) COMMA() antlr.TerminalNode {
	return s.GetToken(asn1ParserCOMMA, 0)
}

func (s *RuleIdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleIdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleIdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleIdentifierList(s)
	}
}

func (s *RuleIdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleIdentifierList(s)
	}
}

func (s *RuleIdentifierListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleIdentifierList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleIdentifierList() (localctx IRuleIdentifierListContext) {
	return p.ruleIdentifierList(0)
}

func (p *asn1Parser) ruleIdentifierList(_p int) (localctx IRuleIdentifierListContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRuleIdentifierListContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRuleIdentifierListContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 290
	p.EnterRecursionRule(localctx, 290, asn1ParserRULE_ruleIdentifierList, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1484)
		p.RuleIdentifier()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1491)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewRuleIdentifierListContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, asn1ParserRULE_ruleIdentifierList)
			p.SetState(1486)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(1487)
				p.Match(asn1ParserCOMMA)
			}
			{
				p.SetState(1488)
				p.RuleIdentifier()
			}

		}
		p.SetState(1493)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 68, p.GetParserRuleContext())
	}

	return localctx
}

// IRuleCharsDefnContext is an interface to support dynamic dispatch.
type IRuleCharsDefnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleCharsDefnContext differentiates from other interfaces.
	IsRuleCharsDefnContext()
}

type RuleCharsDefnContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleCharsDefnContext() *RuleCharsDefnContext {
	var p = new(RuleCharsDefnContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleCharsDefn
	return p
}

func (*RuleCharsDefnContext) IsRuleCharsDefnContext() {}

func NewRuleCharsDefnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleCharsDefnContext {
	var p = new(RuleCharsDefnContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleCharsDefn

	return p
}

func (s *RuleCharsDefnContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleCharsDefnContext) CHAR_STRING() antlr.TerminalNode {
	return s.GetToken(asn1ParserCHAR_STRING, 0)
}

func (s *RuleCharsDefnContext) RuleQuadruple() IRuleQuadrupleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleQuadrupleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleQuadrupleContext)
}

func (s *RuleCharsDefnContext) RuleTuple() IRuleTupleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTupleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTupleContext)
}

func (s *RuleCharsDefnContext) RuleDefinedValue() IRuleDefinedValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinedValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinedValueContext)
}

func (s *RuleCharsDefnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleCharsDefnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleCharsDefnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleCharsDefn(s)
	}
}

func (s *RuleCharsDefnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleCharsDefn(s)
	}
}

func (s *RuleCharsDefnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleCharsDefn(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleCharsDefn() (localctx IRuleCharsDefnContext) {
	this := p
	_ = this

	localctx = NewRuleCharsDefnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, asn1ParserRULE_ruleCharsDefn)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1498)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1494)
			p.Match(asn1ParserCHAR_STRING)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1495)
			p.RuleQuadruple()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1496)
			p.RuleTuple()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1497)
			p.RuleDefinedValue()
		}

	}

	return localctx
}

// IRuleCharSymsContext is an interface to support dynamic dispatch.
type IRuleCharSymsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleCharSymsContext differentiates from other interfaces.
	IsRuleCharSymsContext()
}

type RuleCharSymsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleCharSymsContext() *RuleCharSymsContext {
	var p = new(RuleCharSymsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleCharSyms
	return p
}

func (*RuleCharSymsContext) IsRuleCharSymsContext() {}

func NewRuleCharSymsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleCharSymsContext {
	var p = new(RuleCharSymsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleCharSyms

	return p
}

func (s *RuleCharSymsContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleCharSymsContext) RuleCharsDefn() IRuleCharsDefnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleCharsDefnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleCharsDefnContext)
}

func (s *RuleCharSymsContext) RuleCharSyms() IRuleCharSymsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleCharSymsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleCharSymsContext)
}

func (s *RuleCharSymsContext) COMMA() antlr.TerminalNode {
	return s.GetToken(asn1ParserCOMMA, 0)
}

func (s *RuleCharSymsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleCharSymsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleCharSymsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleCharSyms(s)
	}
}

func (s *RuleCharSymsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleCharSyms(s)
	}
}

func (s *RuleCharSymsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleCharSyms(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleCharSyms() (localctx IRuleCharSymsContext) {
	return p.ruleCharSyms(0)
}

func (p *asn1Parser) ruleCharSyms(_p int) (localctx IRuleCharSymsContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRuleCharSymsContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRuleCharSymsContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 294
	p.EnterRecursionRule(localctx, 294, asn1ParserRULE_ruleCharSyms, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1501)
		p.RuleCharsDefn()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1508)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewRuleCharSymsContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, asn1ParserRULE_ruleCharSyms)
			p.SetState(1503)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(1504)
				p.Match(asn1ParserCOMMA)
			}
			{
				p.SetState(1505)
				p.RuleCharsDefn()
			}

		}
		p.SetState(1510)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext())
	}

	return localctx
}

// IRuleGroupContext is an interface to support dynamic dispatch.
type IRuleGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleGroupContext differentiates from other interfaces.
	IsRuleGroupContext()
}

type RuleGroupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleGroupContext() *RuleGroupContext {
	var p = new(RuleGroupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleGroup
	return p
}

func (*RuleGroupContext) IsRuleGroupContext() {}

func NewRuleGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleGroupContext {
	var p = new(RuleGroupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleGroup

	return p
}

func (s *RuleGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleGroupContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(asn1ParserNUMBER, 0)
}

func (s *RuleGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleGroup(s)
	}
}

func (s *RuleGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleGroup(s)
	}
}

func (s *RuleGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleGroup() (localctx IRuleGroupContext) {
	this := p
	_ = this

	localctx = NewRuleGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, asn1ParserRULE_ruleGroup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1511)
		p.Match(asn1ParserNUMBER)
	}

	return localctx
}

// IRulePlaneContext is an interface to support dynamic dispatch.
type IRulePlaneContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRulePlaneContext differentiates from other interfaces.
	IsRulePlaneContext()
}

type RulePlaneContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRulePlaneContext() *RulePlaneContext {
	var p = new(RulePlaneContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_rulePlane
	return p
}

func (*RulePlaneContext) IsRulePlaneContext() {}

func NewRulePlaneContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RulePlaneContext {
	var p = new(RulePlaneContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_rulePlane

	return p
}

func (s *RulePlaneContext) GetParser() antlr.Parser { return s.parser }

func (s *RulePlaneContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(asn1ParserNUMBER, 0)
}

func (s *RulePlaneContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RulePlaneContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RulePlaneContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRulePlane(s)
	}
}

func (s *RulePlaneContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRulePlane(s)
	}
}

func (s *RulePlaneContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRulePlane(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RulePlane() (localctx IRulePlaneContext) {
	this := p
	_ = this

	localctx = NewRulePlaneContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, asn1ParserRULE_rulePlane)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1513)
		p.Match(asn1ParserNUMBER)
	}

	return localctx
}

// IRuleRowContext is an interface to support dynamic dispatch.
type IRuleRowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleRowContext differentiates from other interfaces.
	IsRuleRowContext()
}

type RuleRowContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleRowContext() *RuleRowContext {
	var p = new(RuleRowContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleRow
	return p
}

func (*RuleRowContext) IsRuleRowContext() {}

func NewRuleRowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleRowContext {
	var p = new(RuleRowContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleRow

	return p
}

func (s *RuleRowContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleRowContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(asn1ParserNUMBER, 0)
}

func (s *RuleRowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleRowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleRowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleRow(s)
	}
}

func (s *RuleRowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleRow(s)
	}
}

func (s *RuleRowContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleRow(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleRow() (localctx IRuleRowContext) {
	this := p
	_ = this

	localctx = NewRuleRowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, asn1ParserRULE_ruleRow)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1515)
		p.Match(asn1ParserNUMBER)
	}

	return localctx
}

// IRuleCellContext is an interface to support dynamic dispatch.
type IRuleCellContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleCellContext differentiates from other interfaces.
	IsRuleCellContext()
}

type RuleCellContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleCellContext() *RuleCellContext {
	var p = new(RuleCellContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleCell
	return p
}

func (*RuleCellContext) IsRuleCellContext() {}

func NewRuleCellContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleCellContext {
	var p = new(RuleCellContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleCell

	return p
}

func (s *RuleCellContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleCellContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(asn1ParserNUMBER, 0)
}

func (s *RuleCellContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleCellContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleCellContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleCell(s)
	}
}

func (s *RuleCellContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleCell(s)
	}
}

func (s *RuleCellContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleCell(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleCell() (localctx IRuleCellContext) {
	this := p
	_ = this

	localctx = NewRuleCellContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, asn1ParserRULE_ruleCell)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1517)
		p.Match(asn1ParserNUMBER)
	}

	return localctx
}

// IRuleTableColumnContext is an interface to support dynamic dispatch.
type IRuleTableColumnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleTableColumnContext differentiates from other interfaces.
	IsRuleTableColumnContext()
}

type RuleTableColumnContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleTableColumnContext() *RuleTableColumnContext {
	var p = new(RuleTableColumnContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleTableColumn
	return p
}

func (*RuleTableColumnContext) IsRuleTableColumnContext() {}

func NewRuleTableColumnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleTableColumnContext {
	var p = new(RuleTableColumnContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleTableColumn

	return p
}

func (s *RuleTableColumnContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleTableColumnContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(asn1ParserNUMBER, 0)
}

func (s *RuleTableColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleTableColumnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleTableColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleTableColumn(s)
	}
}

func (s *RuleTableColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleTableColumn(s)
	}
}

func (s *RuleTableColumnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleTableColumn(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleTableColumn() (localctx IRuleTableColumnContext) {
	this := p
	_ = this

	localctx = NewRuleTableColumnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, asn1ParserRULE_ruleTableColumn)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1519)
		p.Match(asn1ParserNUMBER)
	}

	return localctx
}

// IRuleTableRowContext is an interface to support dynamic dispatch.
type IRuleTableRowContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleTableRowContext differentiates from other interfaces.
	IsRuleTableRowContext()
}

type RuleTableRowContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleTableRowContext() *RuleTableRowContext {
	var p = new(RuleTableRowContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleTableRow
	return p
}

func (*RuleTableRowContext) IsRuleTableRowContext() {}

func NewRuleTableRowContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleTableRowContext {
	var p = new(RuleTableRowContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleTableRow

	return p
}

func (s *RuleTableRowContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleTableRowContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(asn1ParserNUMBER, 0)
}

func (s *RuleTableRowContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleTableRowContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleTableRowContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleTableRow(s)
	}
}

func (s *RuleTableRowContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleTableRow(s)
	}
}

func (s *RuleTableRowContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleTableRow(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleTableRow() (localctx IRuleTableRowContext) {
	this := p
	_ = this

	localctx = NewRuleTableRowContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, asn1ParserRULE_ruleTableRow)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1521)
		p.Match(asn1ParserNUMBER)
	}

	return localctx
}

// IRuleCharacterStringListContext is an interface to support dynamic dispatch.
type IRuleCharacterStringListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleCharacterStringListContext differentiates from other interfaces.
	IsRuleCharacterStringListContext()
}

type RuleCharacterStringListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleCharacterStringListContext() *RuleCharacterStringListContext {
	var p = new(RuleCharacterStringListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleCharacterStringList
	return p
}

func (*RuleCharacterStringListContext) IsRuleCharacterStringListContext() {}

func NewRuleCharacterStringListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleCharacterStringListContext {
	var p = new(RuleCharacterStringListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleCharacterStringList

	return p
}

func (s *RuleCharacterStringListContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleCharacterStringListContext) CURLY_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_START, 0)
}

func (s *RuleCharacterStringListContext) RuleCharSyms() IRuleCharSymsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleCharSymsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleCharSymsContext)
}

func (s *RuleCharacterStringListContext) CURLY_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_END, 0)
}

func (s *RuleCharacterStringListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleCharacterStringListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleCharacterStringListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleCharacterStringList(s)
	}
}

func (s *RuleCharacterStringListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleCharacterStringList(s)
	}
}

func (s *RuleCharacterStringListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleCharacterStringList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleCharacterStringList() (localctx IRuleCharacterStringListContext) {
	this := p
	_ = this

	localctx = NewRuleCharacterStringListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, asn1ParserRULE_ruleCharacterStringList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1523)
		p.Match(asn1ParserCURLY_START)
	}
	{
		p.SetState(1524)
		p.ruleCharSyms(0)
	}
	{
		p.SetState(1525)
		p.Match(asn1ParserCURLY_END)
	}

	return localctx
}

// IRuleQuadrupleContext is an interface to support dynamic dispatch.
type IRuleQuadrupleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleQuadrupleContext differentiates from other interfaces.
	IsRuleQuadrupleContext()
}

type RuleQuadrupleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleQuadrupleContext() *RuleQuadrupleContext {
	var p = new(RuleQuadrupleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleQuadruple
	return p
}

func (*RuleQuadrupleContext) IsRuleQuadrupleContext() {}

func NewRuleQuadrupleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleQuadrupleContext {
	var p = new(RuleQuadrupleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleQuadruple

	return p
}

func (s *RuleQuadrupleContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleQuadrupleContext) CURLY_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_START, 0)
}

func (s *RuleQuadrupleContext) RuleGroup() IRuleGroupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleGroupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleGroupContext)
}

func (s *RuleQuadrupleContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(asn1ParserCOMMA)
}

func (s *RuleQuadrupleContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(asn1ParserCOMMA, i)
}

func (s *RuleQuadrupleContext) RulePlane() IRulePlaneContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRulePlaneContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRulePlaneContext)
}

func (s *RuleQuadrupleContext) RuleRow() IRuleRowContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleRowContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleRowContext)
}

func (s *RuleQuadrupleContext) RuleCell() IRuleCellContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleCellContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleCellContext)
}

func (s *RuleQuadrupleContext) CURLY_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_END, 0)
}

func (s *RuleQuadrupleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleQuadrupleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleQuadrupleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleQuadruple(s)
	}
}

func (s *RuleQuadrupleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleQuadruple(s)
	}
}

func (s *RuleQuadrupleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleQuadruple(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleQuadruple() (localctx IRuleQuadrupleContext) {
	this := p
	_ = this

	localctx = NewRuleQuadrupleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, asn1ParserRULE_ruleQuadruple)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1527)
		p.Match(asn1ParserCURLY_START)
	}
	{
		p.SetState(1528)
		p.RuleGroup()
	}
	{
		p.SetState(1529)
		p.Match(asn1ParserCOMMA)
	}
	{
		p.SetState(1530)
		p.RulePlane()
	}
	{
		p.SetState(1531)
		p.Match(asn1ParserCOMMA)
	}
	{
		p.SetState(1532)
		p.RuleRow()
	}
	{
		p.SetState(1533)
		p.Match(asn1ParserCOMMA)
	}
	{
		p.SetState(1534)
		p.RuleCell()
	}
	{
		p.SetState(1535)
		p.Match(asn1ParserCURLY_END)
	}

	return localctx
}

// IRuleTupleContext is an interface to support dynamic dispatch.
type IRuleTupleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleTupleContext differentiates from other interfaces.
	IsRuleTupleContext()
}

type RuleTupleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleTupleContext() *RuleTupleContext {
	var p = new(RuleTupleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleTuple
	return p
}

func (*RuleTupleContext) IsRuleTupleContext() {}

func NewRuleTupleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleTupleContext {
	var p = new(RuleTupleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleTuple

	return p
}

func (s *RuleTupleContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleTupleContext) CURLY_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_START, 0)
}

func (s *RuleTupleContext) RuleTableColumn() IRuleTableColumnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTableColumnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTableColumnContext)
}

func (s *RuleTupleContext) COMMA() antlr.TerminalNode {
	return s.GetToken(asn1ParserCOMMA, 0)
}

func (s *RuleTupleContext) RuleTableRow() IRuleTableRowContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTableRowContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTableRowContext)
}

func (s *RuleTupleContext) CURLY_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_END, 0)
}

func (s *RuleTupleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleTupleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleTupleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleTuple(s)
	}
}

func (s *RuleTupleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleTuple(s)
	}
}

func (s *RuleTupleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleTuple(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleTuple() (localctx IRuleTupleContext) {
	this := p
	_ = this

	localctx = NewRuleTupleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, asn1ParserRULE_ruleTuple)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1537)
		p.Match(asn1ParserCURLY_START)
	}
	{
		p.SetState(1538)
		p.RuleTableColumn()
	}
	{
		p.SetState(1539)
		p.Match(asn1ParserCOMMA)
	}
	{
		p.SetState(1540)
		p.RuleTableRow()
	}
	{
		p.SetState(1541)
		p.Match(asn1ParserCURLY_END)
	}

	return localctx
}

// IRuleRestrictedCharacterStringValueContext is an interface to support dynamic dispatch.
type IRuleRestrictedCharacterStringValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleRestrictedCharacterStringValueContext differentiates from other interfaces.
	IsRuleRestrictedCharacterStringValueContext()
}

type RuleRestrictedCharacterStringValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleRestrictedCharacterStringValueContext() *RuleRestrictedCharacterStringValueContext {
	var p = new(RuleRestrictedCharacterStringValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleRestrictedCharacterStringValue
	return p
}

func (*RuleRestrictedCharacterStringValueContext) IsRuleRestrictedCharacterStringValueContext() {}

func NewRuleRestrictedCharacterStringValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleRestrictedCharacterStringValueContext {
	var p = new(RuleRestrictedCharacterStringValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleRestrictedCharacterStringValue

	return p
}

func (s *RuleRestrictedCharacterStringValueContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleRestrictedCharacterStringValueContext) CHAR_STRING() antlr.TerminalNode {
	return s.GetToken(asn1ParserCHAR_STRING, 0)
}

func (s *RuleRestrictedCharacterStringValueContext) RuleCharacterStringList() IRuleCharacterStringListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleCharacterStringListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleCharacterStringListContext)
}

func (s *RuleRestrictedCharacterStringValueContext) RuleQuadruple() IRuleQuadrupleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleQuadrupleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleQuadrupleContext)
}

func (s *RuleRestrictedCharacterStringValueContext) RuleTuple() IRuleTupleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTupleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTupleContext)
}

func (s *RuleRestrictedCharacterStringValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleRestrictedCharacterStringValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleRestrictedCharacterStringValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleRestrictedCharacterStringValue(s)
	}
}

func (s *RuleRestrictedCharacterStringValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleRestrictedCharacterStringValue(s)
	}
}

func (s *RuleRestrictedCharacterStringValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleRestrictedCharacterStringValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleRestrictedCharacterStringValue() (localctx IRuleRestrictedCharacterStringValueContext) {
	this := p
	_ = this

	localctx = NewRuleRestrictedCharacterStringValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, asn1ParserRULE_ruleRestrictedCharacterStringValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1547)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1543)
			p.Match(asn1ParserCHAR_STRING)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1544)
			p.RuleCharacterStringList()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1545)
			p.RuleQuadruple()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1546)
			p.RuleTuple()
		}

	}

	return localctx
}

// IRuleUnrestrictedCharacterStringValueContext is an interface to support dynamic dispatch.
type IRuleUnrestrictedCharacterStringValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleUnrestrictedCharacterStringValueContext differentiates from other interfaces.
	IsRuleUnrestrictedCharacterStringValueContext()
}

type RuleUnrestrictedCharacterStringValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleUnrestrictedCharacterStringValueContext() *RuleUnrestrictedCharacterStringValueContext {
	var p = new(RuleUnrestrictedCharacterStringValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleUnrestrictedCharacterStringValue
	return p
}

func (*RuleUnrestrictedCharacterStringValueContext) IsRuleUnrestrictedCharacterStringValueContext() {}

func NewRuleUnrestrictedCharacterStringValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleUnrestrictedCharacterStringValueContext {
	var p = new(RuleUnrestrictedCharacterStringValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleUnrestrictedCharacterStringValue

	return p
}

func (s *RuleUnrestrictedCharacterStringValueContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleUnrestrictedCharacterStringValueContext) RuleSequenceValue() IRuleSequenceValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSequenceValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSequenceValueContext)
}

func (s *RuleUnrestrictedCharacterStringValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleUnrestrictedCharacterStringValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleUnrestrictedCharacterStringValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleUnrestrictedCharacterStringValue(s)
	}
}

func (s *RuleUnrestrictedCharacterStringValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleUnrestrictedCharacterStringValue(s)
	}
}

func (s *RuleUnrestrictedCharacterStringValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleUnrestrictedCharacterStringValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleUnrestrictedCharacterStringValue() (localctx IRuleUnrestrictedCharacterStringValueContext) {
	this := p
	_ = this

	localctx = NewRuleUnrestrictedCharacterStringValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, asn1ParserRULE_ruleUnrestrictedCharacterStringValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1549)
		p.RuleSequenceValue()
	}

	return localctx
}

// IRuleNumericRealValueContext is an interface to support dynamic dispatch.
type IRuleNumericRealValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleNumericRealValueContext differentiates from other interfaces.
	IsRuleNumericRealValueContext()
}

type RuleNumericRealValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleNumericRealValueContext() *RuleNumericRealValueContext {
	var p = new(RuleNumericRealValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleNumericRealValue
	return p
}

func (*RuleNumericRealValueContext) IsRuleNumericRealValueContext() {}

func NewRuleNumericRealValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleNumericRealValueContext {
	var p = new(RuleNumericRealValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleNumericRealValue

	return p
}

func (s *RuleNumericRealValueContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleNumericRealValueContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(asn1ParserFLOAT, 0)
}

func (s *RuleNumericRealValueContext) MINUS() antlr.TerminalNode {
	return s.GetToken(asn1ParserMINUS, 0)
}

func (s *RuleNumericRealValueContext) RuleSequenceValue() IRuleSequenceValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSequenceValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSequenceValueContext)
}

func (s *RuleNumericRealValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleNumericRealValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleNumericRealValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleNumericRealValue(s)
	}
}

func (s *RuleNumericRealValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleNumericRealValue(s)
	}
}

func (s *RuleNumericRealValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleNumericRealValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleNumericRealValue() (localctx IRuleNumericRealValueContext) {
	this := p
	_ = this

	localctx = NewRuleNumericRealValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, asn1ParserRULE_ruleNumericRealValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1555)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case asn1ParserFLOAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1551)
			p.Match(asn1ParserFLOAT)
		}

	case asn1ParserMINUS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1552)
			p.Match(asn1ParserMINUS)
		}
		{
			p.SetState(1553)
			p.Match(asn1ParserFLOAT)
		}

	case asn1ParserCURLY_START:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1554)
			p.RuleSequenceValue()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRuleSpecialRealValueContext is an interface to support dynamic dispatch.
type IRuleSpecialRealValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleSpecialRealValueContext differentiates from other interfaces.
	IsRuleSpecialRealValueContext()
}

type RuleSpecialRealValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleSpecialRealValueContext() *RuleSpecialRealValueContext {
	var p = new(RuleSpecialRealValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleSpecialRealValue
	return p
}

func (*RuleSpecialRealValueContext) IsRuleSpecialRealValueContext() {}

func NewRuleSpecialRealValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleSpecialRealValueContext {
	var p = new(RuleSpecialRealValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleSpecialRealValue

	return p
}

func (s *RuleSpecialRealValueContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleSpecialRealValueContext) PLUS_INFINITY_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserPLUS_INFINITY_SYM, 0)
}

func (s *RuleSpecialRealValueContext) MINUS_INFINITY_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserMINUS_INFINITY_SYM, 0)
}

func (s *RuleSpecialRealValueContext) NOT_A_NUMBER_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserNOT_A_NUMBER_SYM, 0)
}

func (s *RuleSpecialRealValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleSpecialRealValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleSpecialRealValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleSpecialRealValue(s)
	}
}

func (s *RuleSpecialRealValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleSpecialRealValue(s)
	}
}

func (s *RuleSpecialRealValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleSpecialRealValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleSpecialRealValue() (localctx IRuleSpecialRealValueContext) {
	this := p
	_ = this

	localctx = NewRuleSpecialRealValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, asn1ParserRULE_ruleSpecialRealValue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1557)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-51)&-(0x1f+1)) == 0 && ((1<<uint((_la-51)))&((1<<(asn1ParserMINUS_INFINITY_SYM-51))|(1<<(asn1ParserNOT_A_NUMBER_SYM-51))|(1<<(asn1ParserPLUS_INFINITY_SYM-51)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IRuleRelativeOIDComponentsContext is an interface to support dynamic dispatch.
type IRuleRelativeOIDComponentsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleRelativeOIDComponentsContext differentiates from other interfaces.
	IsRuleRelativeOIDComponentsContext()
}

type RuleRelativeOIDComponentsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleRelativeOIDComponentsContext() *RuleRelativeOIDComponentsContext {
	var p = new(RuleRelativeOIDComponentsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleRelativeOIDComponents
	return p
}

func (*RuleRelativeOIDComponentsContext) IsRuleRelativeOIDComponentsContext() {}

func NewRuleRelativeOIDComponentsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleRelativeOIDComponentsContext {
	var p = new(RuleRelativeOIDComponentsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleRelativeOIDComponents

	return p
}

func (s *RuleRelativeOIDComponentsContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleRelativeOIDComponentsContext) RuleNumberForm() IRuleNumberFormContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleNumberFormContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleNumberFormContext)
}

func (s *RuleRelativeOIDComponentsContext) RuleNameAndNumberForm() IRuleNameAndNumberFormContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleNameAndNumberFormContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleNameAndNumberFormContext)
}

func (s *RuleRelativeOIDComponentsContext) RuleDefinedValue() IRuleDefinedValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinedValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinedValueContext)
}

func (s *RuleRelativeOIDComponentsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleRelativeOIDComponentsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleRelativeOIDComponentsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleRelativeOIDComponents(s)
	}
}

func (s *RuleRelativeOIDComponentsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleRelativeOIDComponents(s)
	}
}

func (s *RuleRelativeOIDComponentsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleRelativeOIDComponents(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleRelativeOIDComponents() (localctx IRuleRelativeOIDComponentsContext) {
	this := p
	_ = this

	localctx = NewRuleRelativeOIDComponentsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, asn1ParserRULE_ruleRelativeOIDComponents)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1562)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1559)
			p.RuleNumberForm()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1560)
			p.RuleNameAndNumberForm()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1561)
			p.RuleDefinedValue()
		}

	}

	return localctx
}

// IRuleRelativeOIDComponentsListContext is an interface to support dynamic dispatch.
type IRuleRelativeOIDComponentsListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleRelativeOIDComponentsListContext differentiates from other interfaces.
	IsRuleRelativeOIDComponentsListContext()
}

type RuleRelativeOIDComponentsListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleRelativeOIDComponentsListContext() *RuleRelativeOIDComponentsListContext {
	var p = new(RuleRelativeOIDComponentsListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleRelativeOIDComponentsList
	return p
}

func (*RuleRelativeOIDComponentsListContext) IsRuleRelativeOIDComponentsListContext() {}

func NewRuleRelativeOIDComponentsListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleRelativeOIDComponentsListContext {
	var p = new(RuleRelativeOIDComponentsListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleRelativeOIDComponentsList

	return p
}

func (s *RuleRelativeOIDComponentsListContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleRelativeOIDComponentsListContext) RuleRelativeOIDComponents() IRuleRelativeOIDComponentsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleRelativeOIDComponentsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleRelativeOIDComponentsContext)
}

func (s *RuleRelativeOIDComponentsListContext) RuleRelativeOIDComponentsList() IRuleRelativeOIDComponentsListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleRelativeOIDComponentsListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleRelativeOIDComponentsListContext)
}

func (s *RuleRelativeOIDComponentsListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleRelativeOIDComponentsListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleRelativeOIDComponentsListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleRelativeOIDComponentsList(s)
	}
}

func (s *RuleRelativeOIDComponentsListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleRelativeOIDComponentsList(s)
	}
}

func (s *RuleRelativeOIDComponentsListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleRelativeOIDComponentsList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleRelativeOIDComponentsList() (localctx IRuleRelativeOIDComponentsListContext) {
	return p.ruleRelativeOIDComponentsList(0)
}

func (p *asn1Parser) ruleRelativeOIDComponentsList(_p int) (localctx IRuleRelativeOIDComponentsListContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRuleRelativeOIDComponentsListContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRuleRelativeOIDComponentsListContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 324
	p.EnterRecursionRule(localctx, 324, asn1ParserRULE_ruleRelativeOIDComponentsList, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1565)
		p.RuleRelativeOIDComponents()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1571)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewRuleRelativeOIDComponentsListContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, asn1ParserRULE_ruleRelativeOIDComponentsList)
			p.SetState(1567)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(1568)
				p.RuleRelativeOIDComponents()
			}

		}
		p.SetState(1573)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext())
	}

	return localctx
}

// IRuleComponentValueListContext is an interface to support dynamic dispatch.
type IRuleComponentValueListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleComponentValueListContext differentiates from other interfaces.
	IsRuleComponentValueListContext()
}

type RuleComponentValueListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleComponentValueListContext() *RuleComponentValueListContext {
	var p = new(RuleComponentValueListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleComponentValueList
	return p
}

func (*RuleComponentValueListContext) IsRuleComponentValueListContext() {}

func NewRuleComponentValueListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleComponentValueListContext {
	var p = new(RuleComponentValueListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleComponentValueList

	return p
}

func (s *RuleComponentValueListContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleComponentValueListContext) RuleNamedValue() IRuleNamedValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleNamedValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleNamedValueContext)
}

func (s *RuleComponentValueListContext) RuleComponentValueList() IRuleComponentValueListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleComponentValueListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleComponentValueListContext)
}

func (s *RuleComponentValueListContext) COMMA() antlr.TerminalNode {
	return s.GetToken(asn1ParserCOMMA, 0)
}

func (s *RuleComponentValueListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleComponentValueListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleComponentValueListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleComponentValueList(s)
	}
}

func (s *RuleComponentValueListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleComponentValueList(s)
	}
}

func (s *RuleComponentValueListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleComponentValueList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleComponentValueList() (localctx IRuleComponentValueListContext) {
	return p.ruleComponentValueList(0)
}

func (p *asn1Parser) ruleComponentValueList(_p int) (localctx IRuleComponentValueListContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRuleComponentValueListContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRuleComponentValueListContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 326
	p.EnterRecursionRule(localctx, 326, asn1ParserRULE_ruleComponentValueList, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1575)
		p.RuleNamedValue()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1582)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewRuleComponentValueListContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, asn1ParserRULE_ruleComponentValueList)
			p.SetState(1577)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(1578)
				p.Match(asn1ParserCOMMA)
			}
			{
				p.SetState(1579)
				p.RuleNamedValue()
			}

		}
		p.SetState(1584)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext())
	}

	return localctx
}

// IRuleValueListContext is an interface to support dynamic dispatch.
type IRuleValueListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleValueListContext differentiates from other interfaces.
	IsRuleValueListContext()
}

type RuleValueListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleValueListContext() *RuleValueListContext {
	var p = new(RuleValueListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleValueList
	return p
}

func (*RuleValueListContext) IsRuleValueListContext() {}

func NewRuleValueListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleValueListContext {
	var p = new(RuleValueListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleValueList

	return p
}

func (s *RuleValueListContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleValueListContext) RuleValue() IRuleValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueContext)
}

func (s *RuleValueListContext) RuleValueList() IRuleValueListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueListContext)
}

func (s *RuleValueListContext) COMMA() antlr.TerminalNode {
	return s.GetToken(asn1ParserCOMMA, 0)
}

func (s *RuleValueListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleValueListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleValueListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleValueList(s)
	}
}

func (s *RuleValueListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleValueList(s)
	}
}

func (s *RuleValueListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleValueList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleValueList() (localctx IRuleValueListContext) {
	return p.ruleValueList(0)
}

func (p *asn1Parser) ruleValueList(_p int) (localctx IRuleValueListContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRuleValueListContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRuleValueListContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 328
	p.EnterRecursionRule(localctx, 328, asn1ParserRULE_ruleValueList, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1586)
		p.RuleValue()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1593)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewRuleValueListContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, asn1ParserRULE_ruleValueList)
			p.SetState(1588)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(1589)
				p.Match(asn1ParserCOMMA)
			}
			{
				p.SetState(1590)
				p.RuleValue()
			}

		}
		p.SetState(1595)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext())
	}

	return localctx
}

// IRuleNamedValueContext is an interface to support dynamic dispatch.
type IRuleNamedValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleNamedValueContext differentiates from other interfaces.
	IsRuleNamedValueContext()
}

type RuleNamedValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleNamedValueContext() *RuleNamedValueContext {
	var p = new(RuleNamedValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleNamedValue
	return p
}

func (*RuleNamedValueContext) IsRuleNamedValueContext() {}

func NewRuleNamedValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleNamedValueContext {
	var p = new(RuleNamedValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleNamedValue

	return p
}

func (s *RuleNamedValueContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleNamedValueContext) RuleIdentifier() IRuleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleIdentifierContext)
}

func (s *RuleNamedValueContext) RuleValue() IRuleValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueContext)
}

func (s *RuleNamedValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleNamedValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleNamedValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleNamedValue(s)
	}
}

func (s *RuleNamedValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleNamedValue(s)
	}
}

func (s *RuleNamedValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleNamedValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleNamedValue() (localctx IRuleNamedValueContext) {
	this := p
	_ = this

	localctx = NewRuleNamedValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, asn1ParserRULE_ruleNamedValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1596)
		p.RuleIdentifier()
	}
	{
		p.SetState(1597)
		p.RuleValue()
	}

	return localctx
}

// IRuleNamedValueListContext is an interface to support dynamic dispatch.
type IRuleNamedValueListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleNamedValueListContext differentiates from other interfaces.
	IsRuleNamedValueListContext()
}

type RuleNamedValueListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleNamedValueListContext() *RuleNamedValueListContext {
	var p = new(RuleNamedValueListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleNamedValueList
	return p
}

func (*RuleNamedValueListContext) IsRuleNamedValueListContext() {}

func NewRuleNamedValueListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleNamedValueListContext {
	var p = new(RuleNamedValueListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleNamedValueList

	return p
}

func (s *RuleNamedValueListContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleNamedValueListContext) RuleNamedValue() IRuleNamedValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleNamedValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleNamedValueContext)
}

func (s *RuleNamedValueListContext) RuleNamedValueList() IRuleNamedValueListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleNamedValueListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleNamedValueListContext)
}

func (s *RuleNamedValueListContext) COMMA() antlr.TerminalNode {
	return s.GetToken(asn1ParserCOMMA, 0)
}

func (s *RuleNamedValueListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleNamedValueListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleNamedValueListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleNamedValueList(s)
	}
}

func (s *RuleNamedValueListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleNamedValueList(s)
	}
}

func (s *RuleNamedValueListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleNamedValueList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleNamedValueList() (localctx IRuleNamedValueListContext) {
	return p.ruleNamedValueList(0)
}

func (p *asn1Parser) ruleNamedValueList(_p int) (localctx IRuleNamedValueListContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRuleNamedValueListContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRuleNamedValueListContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 332
	p.EnterRecursionRule(localctx, 332, asn1ParserRULE_ruleNamedValueList, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1600)
		p.RuleNamedValue()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1607)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 77, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewRuleNamedValueListContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, asn1ParserRULE_ruleNamedValueList)
			p.SetState(1602)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(1603)
				p.Match(asn1ParserCOMMA)
			}
			{
				p.SetState(1604)
				p.RuleNamedValue()
			}

		}
		p.SetState(1609)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 77, p.GetParserRuleContext())
	}

	return localctx
}

// IRuleBitStringValueContext is an interface to support dynamic dispatch.
type IRuleBitStringValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleBitStringValueContext differentiates from other interfaces.
	IsRuleBitStringValueContext()
}

type RuleBitStringValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleBitStringValueContext() *RuleBitStringValueContext {
	var p = new(RuleBitStringValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleBitStringValue
	return p
}

func (*RuleBitStringValueContext) IsRuleBitStringValueContext() {}

func NewRuleBitStringValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleBitStringValueContext {
	var p = new(RuleBitStringValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleBitStringValue

	return p
}

func (s *RuleBitStringValueContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleBitStringValueContext) BIN_STRING() antlr.TerminalNode {
	return s.GetToken(asn1ParserBIN_STRING, 0)
}

func (s *RuleBitStringValueContext) HEX_STRING() antlr.TerminalNode {
	return s.GetToken(asn1ParserHEX_STRING, 0)
}

func (s *RuleBitStringValueContext) CURLY_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_START, 0)
}

func (s *RuleBitStringValueContext) RuleIdentifierList() IRuleIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleIdentifierListContext)
}

func (s *RuleBitStringValueContext) CURLY_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_END, 0)
}

func (s *RuleBitStringValueContext) CONTAINING_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserCONTAINING_SYM, 0)
}

func (s *RuleBitStringValueContext) RuleValue() IRuleValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueContext)
}

func (s *RuleBitStringValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleBitStringValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleBitStringValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleBitStringValue(s)
	}
}

func (s *RuleBitStringValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleBitStringValue(s)
	}
}

func (s *RuleBitStringValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleBitStringValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleBitStringValue() (localctx IRuleBitStringValueContext) {
	this := p
	_ = this

	localctx = NewRuleBitStringValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, asn1ParserRULE_ruleBitStringValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1620)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1610)
			p.Match(asn1ParserBIN_STRING)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1611)
			p.Match(asn1ParserHEX_STRING)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1612)
			p.Match(asn1ParserCURLY_START)
		}
		{
			p.SetState(1613)
			p.ruleIdentifierList(0)
		}
		{
			p.SetState(1614)
			p.Match(asn1ParserCURLY_END)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1616)
			p.Match(asn1ParserCURLY_START)
		}
		{
			p.SetState(1617)
			p.Match(asn1ParserCURLY_END)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1618)
			p.Match(asn1ParserCONTAINING_SYM)
		}
		{
			p.SetState(1619)
			p.RuleValue()
		}

	}

	return localctx
}

// IRuleBooleanValueContext is an interface to support dynamic dispatch.
type IRuleBooleanValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleBooleanValueContext differentiates from other interfaces.
	IsRuleBooleanValueContext()
}

type RuleBooleanValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleBooleanValueContext() *RuleBooleanValueContext {
	var p = new(RuleBooleanValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleBooleanValue
	return p
}

func (*RuleBooleanValueContext) IsRuleBooleanValueContext() {}

func NewRuleBooleanValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleBooleanValueContext {
	var p = new(RuleBooleanValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleBooleanValue

	return p
}

func (s *RuleBooleanValueContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleBooleanValueContext) TRUE_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserTRUE_SYM, 0)
}

func (s *RuleBooleanValueContext) FALSE_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserFALSE_SYM, 0)
}

func (s *RuleBooleanValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleBooleanValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleBooleanValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleBooleanValue(s)
	}
}

func (s *RuleBooleanValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleBooleanValue(s)
	}
}

func (s *RuleBooleanValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleBooleanValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleBooleanValue() (localctx IRuleBooleanValueContext) {
	this := p
	_ = this

	localctx = NewRuleBooleanValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, asn1ParserRULE_ruleBooleanValue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1622)
		_la = p.GetTokenStream().LA(1)

		if !(_la == asn1ParserFALSE_SYM || _la == asn1ParserTRUE_SYM) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IRuleCharacterStringValueContext is an interface to support dynamic dispatch.
type IRuleCharacterStringValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleCharacterStringValueContext differentiates from other interfaces.
	IsRuleCharacterStringValueContext()
}

type RuleCharacterStringValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleCharacterStringValueContext() *RuleCharacterStringValueContext {
	var p = new(RuleCharacterStringValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleCharacterStringValue
	return p
}

func (*RuleCharacterStringValueContext) IsRuleCharacterStringValueContext() {}

func NewRuleCharacterStringValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleCharacterStringValueContext {
	var p = new(RuleCharacterStringValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleCharacterStringValue

	return p
}

func (s *RuleCharacterStringValueContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleCharacterStringValueContext) RuleRestrictedCharacterStringValue() IRuleRestrictedCharacterStringValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleRestrictedCharacterStringValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleRestrictedCharacterStringValueContext)
}

func (s *RuleCharacterStringValueContext) RuleUnrestrictedCharacterStringValue() IRuleUnrestrictedCharacterStringValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleUnrestrictedCharacterStringValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleUnrestrictedCharacterStringValueContext)
}

func (s *RuleCharacterStringValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleCharacterStringValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleCharacterStringValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleCharacterStringValue(s)
	}
}

func (s *RuleCharacterStringValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleCharacterStringValue(s)
	}
}

func (s *RuleCharacterStringValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleCharacterStringValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleCharacterStringValue() (localctx IRuleCharacterStringValueContext) {
	this := p
	_ = this

	localctx = NewRuleCharacterStringValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, asn1ParserRULE_ruleCharacterStringValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1626)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1624)
			p.RuleRestrictedCharacterStringValue()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1625)
			p.RuleUnrestrictedCharacterStringValue()
		}

	}

	return localctx
}

// IRuleChoiceValueContext is an interface to support dynamic dispatch.
type IRuleChoiceValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleChoiceValueContext differentiates from other interfaces.
	IsRuleChoiceValueContext()
}

type RuleChoiceValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleChoiceValueContext() *RuleChoiceValueContext {
	var p = new(RuleChoiceValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleChoiceValue
	return p
}

func (*RuleChoiceValueContext) IsRuleChoiceValueContext() {}

func NewRuleChoiceValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleChoiceValueContext {
	var p = new(RuleChoiceValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleChoiceValue

	return p
}

func (s *RuleChoiceValueContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleChoiceValueContext) RuleIdentifier() IRuleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleIdentifierContext)
}

func (s *RuleChoiceValueContext) COLON() antlr.TerminalNode {
	return s.GetToken(asn1ParserCOLON, 0)
}

func (s *RuleChoiceValueContext) RuleValue() IRuleValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueContext)
}

func (s *RuleChoiceValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleChoiceValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleChoiceValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleChoiceValue(s)
	}
}

func (s *RuleChoiceValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleChoiceValue(s)
	}
}

func (s *RuleChoiceValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleChoiceValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleChoiceValue() (localctx IRuleChoiceValueContext) {
	this := p
	_ = this

	localctx = NewRuleChoiceValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, asn1ParserRULE_ruleChoiceValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1628)
		p.RuleIdentifier()
	}
	{
		p.SetState(1629)
		p.Match(asn1ParserCOLON)
	}
	{
		p.SetState(1630)
		p.RuleValue()
	}

	return localctx
}

// IRuleEmbeddedPDVValueContext is an interface to support dynamic dispatch.
type IRuleEmbeddedPDVValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleEmbeddedPDVValueContext differentiates from other interfaces.
	IsRuleEmbeddedPDVValueContext()
}

type RuleEmbeddedPDVValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleEmbeddedPDVValueContext() *RuleEmbeddedPDVValueContext {
	var p = new(RuleEmbeddedPDVValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleEmbeddedPDVValue
	return p
}

func (*RuleEmbeddedPDVValueContext) IsRuleEmbeddedPDVValueContext() {}

func NewRuleEmbeddedPDVValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleEmbeddedPDVValueContext {
	var p = new(RuleEmbeddedPDVValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleEmbeddedPDVValue

	return p
}

func (s *RuleEmbeddedPDVValueContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleEmbeddedPDVValueContext) RuleSequenceValue() IRuleSequenceValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSequenceValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSequenceValueContext)
}

func (s *RuleEmbeddedPDVValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleEmbeddedPDVValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleEmbeddedPDVValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleEmbeddedPDVValue(s)
	}
}

func (s *RuleEmbeddedPDVValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleEmbeddedPDVValue(s)
	}
}

func (s *RuleEmbeddedPDVValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleEmbeddedPDVValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleEmbeddedPDVValue() (localctx IRuleEmbeddedPDVValueContext) {
	this := p
	_ = this

	localctx = NewRuleEmbeddedPDVValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, asn1ParserRULE_ruleEmbeddedPDVValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1632)
		p.RuleSequenceValue()
	}

	return localctx
}

// IRuleEnumeratedValueContext is an interface to support dynamic dispatch.
type IRuleEnumeratedValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleEnumeratedValueContext differentiates from other interfaces.
	IsRuleEnumeratedValueContext()
}

type RuleEnumeratedValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleEnumeratedValueContext() *RuleEnumeratedValueContext {
	var p = new(RuleEnumeratedValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleEnumeratedValue
	return p
}

func (*RuleEnumeratedValueContext) IsRuleEnumeratedValueContext() {}

func NewRuleEnumeratedValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleEnumeratedValueContext {
	var p = new(RuleEnumeratedValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleEnumeratedValue

	return p
}

func (s *RuleEnumeratedValueContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleEnumeratedValueContext) RuleIdentifier() IRuleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleIdentifierContext)
}

func (s *RuleEnumeratedValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleEnumeratedValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleEnumeratedValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleEnumeratedValue(s)
	}
}

func (s *RuleEnumeratedValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleEnumeratedValue(s)
	}
}

func (s *RuleEnumeratedValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleEnumeratedValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleEnumeratedValue() (localctx IRuleEnumeratedValueContext) {
	this := p
	_ = this

	localctx = NewRuleEnumeratedValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, asn1ParserRULE_ruleEnumeratedValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1634)
		p.RuleIdentifier()
	}

	return localctx
}

// IRuleExternalValueContext is an interface to support dynamic dispatch.
type IRuleExternalValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleExternalValueContext differentiates from other interfaces.
	IsRuleExternalValueContext()
}

type RuleExternalValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleExternalValueContext() *RuleExternalValueContext {
	var p = new(RuleExternalValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleExternalValue
	return p
}

func (*RuleExternalValueContext) IsRuleExternalValueContext() {}

func NewRuleExternalValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleExternalValueContext {
	var p = new(RuleExternalValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleExternalValue

	return p
}

func (s *RuleExternalValueContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleExternalValueContext) RuleSequenceValue() IRuleSequenceValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSequenceValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSequenceValueContext)
}

func (s *RuleExternalValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleExternalValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleExternalValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleExternalValue(s)
	}
}

func (s *RuleExternalValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleExternalValue(s)
	}
}

func (s *RuleExternalValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleExternalValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleExternalValue() (localctx IRuleExternalValueContext) {
	this := p
	_ = this

	localctx = NewRuleExternalValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, asn1ParserRULE_ruleExternalValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1636)
		p.RuleSequenceValue()
	}

	return localctx
}

// IRuleInstanceOfValueContext is an interface to support dynamic dispatch.
type IRuleInstanceOfValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleInstanceOfValueContext differentiates from other interfaces.
	IsRuleInstanceOfValueContext()
}

type RuleInstanceOfValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleInstanceOfValueContext() *RuleInstanceOfValueContext {
	var p = new(RuleInstanceOfValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleInstanceOfValue
	return p
}

func (*RuleInstanceOfValueContext) IsRuleInstanceOfValueContext() {}

func NewRuleInstanceOfValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleInstanceOfValueContext {
	var p = new(RuleInstanceOfValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleInstanceOfValue

	return p
}

func (s *RuleInstanceOfValueContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleInstanceOfValueContext) RuleValue() IRuleValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueContext)
}

func (s *RuleInstanceOfValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleInstanceOfValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleInstanceOfValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleInstanceOfValue(s)
	}
}

func (s *RuleInstanceOfValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleInstanceOfValue(s)
	}
}

func (s *RuleInstanceOfValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleInstanceOfValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleInstanceOfValue() (localctx IRuleInstanceOfValueContext) {
	this := p
	_ = this

	localctx = NewRuleInstanceOfValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, asn1ParserRULE_ruleInstanceOfValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1638)
		p.RuleValue()
	}

	return localctx
}

// IRuleIntegerValueContext is an interface to support dynamic dispatch.
type IRuleIntegerValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleIntegerValueContext differentiates from other interfaces.
	IsRuleIntegerValueContext()
}

type RuleIntegerValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleIntegerValueContext() *RuleIntegerValueContext {
	var p = new(RuleIntegerValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleIntegerValue
	return p
}

func (*RuleIntegerValueContext) IsRuleIntegerValueContext() {}

func NewRuleIntegerValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleIntegerValueContext {
	var p = new(RuleIntegerValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleIntegerValue

	return p
}

func (s *RuleIntegerValueContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleIntegerValueContext) RuleSignedNumber() IRuleSignedNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSignedNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSignedNumberContext)
}

func (s *RuleIntegerValueContext) RuleIdentifier() IRuleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleIdentifierContext)
}

func (s *RuleIntegerValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleIntegerValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleIntegerValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleIntegerValue(s)
	}
}

func (s *RuleIntegerValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleIntegerValue(s)
	}
}

func (s *RuleIntegerValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleIntegerValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleIntegerValue() (localctx IRuleIntegerValueContext) {
	this := p
	_ = this

	localctx = NewRuleIntegerValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, asn1ParserRULE_ruleIntegerValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1642)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case asn1ParserMINUS, asn1ParserNUMBER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1640)
			p.RuleSignedNumber()
		}

	case asn1ParserLCASE_ID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1641)
			p.RuleIdentifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRuleNullValueContext is an interface to support dynamic dispatch.
type IRuleNullValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleNullValueContext differentiates from other interfaces.
	IsRuleNullValueContext()
}

type RuleNullValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleNullValueContext() *RuleNullValueContext {
	var p = new(RuleNullValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleNullValue
	return p
}

func (*RuleNullValueContext) IsRuleNullValueContext() {}

func NewRuleNullValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleNullValueContext {
	var p = new(RuleNullValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleNullValue

	return p
}

func (s *RuleNullValueContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleNullValueContext) NULL_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserNULL_SYM, 0)
}

func (s *RuleNullValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleNullValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleNullValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleNullValue(s)
	}
}

func (s *RuleNullValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleNullValue(s)
	}
}

func (s *RuleNullValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleNullValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleNullValue() (localctx IRuleNullValueContext) {
	this := p
	_ = this

	localctx = NewRuleNullValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, asn1ParserRULE_ruleNullValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1644)
		p.Match(asn1ParserNULL_SYM)
	}

	return localctx
}

// IRuleOctetStringValueContext is an interface to support dynamic dispatch.
type IRuleOctetStringValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleOctetStringValueContext differentiates from other interfaces.
	IsRuleOctetStringValueContext()
}

type RuleOctetStringValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleOctetStringValueContext() *RuleOctetStringValueContext {
	var p = new(RuleOctetStringValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleOctetStringValue
	return p
}

func (*RuleOctetStringValueContext) IsRuleOctetStringValueContext() {}

func NewRuleOctetStringValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleOctetStringValueContext {
	var p = new(RuleOctetStringValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleOctetStringValue

	return p
}

func (s *RuleOctetStringValueContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleOctetStringValueContext) BIN_STRING() antlr.TerminalNode {
	return s.GetToken(asn1ParserBIN_STRING, 0)
}

func (s *RuleOctetStringValueContext) HEX_STRING() antlr.TerminalNode {
	return s.GetToken(asn1ParserHEX_STRING, 0)
}

func (s *RuleOctetStringValueContext) CONTAINING_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserCONTAINING_SYM, 0)
}

func (s *RuleOctetStringValueContext) RuleValue() IRuleValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueContext)
}

func (s *RuleOctetStringValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleOctetStringValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleOctetStringValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleOctetStringValue(s)
	}
}

func (s *RuleOctetStringValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleOctetStringValue(s)
	}
}

func (s *RuleOctetStringValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleOctetStringValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleOctetStringValue() (localctx IRuleOctetStringValueContext) {
	this := p
	_ = this

	localctx = NewRuleOctetStringValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, asn1ParserRULE_ruleOctetStringValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1650)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case asn1ParserBIN_STRING:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1646)
			p.Match(asn1ParserBIN_STRING)
		}

	case asn1ParserHEX_STRING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1647)
			p.Match(asn1ParserHEX_STRING)
		}

	case asn1ParserCONTAINING_SYM:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1648)
			p.Match(asn1ParserCONTAINING_SYM)
		}
		{
			p.SetState(1649)
			p.RuleValue()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRuleRealValueContext is an interface to support dynamic dispatch.
type IRuleRealValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleRealValueContext differentiates from other interfaces.
	IsRuleRealValueContext()
}

type RuleRealValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleRealValueContext() *RuleRealValueContext {
	var p = new(RuleRealValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleRealValue
	return p
}

func (*RuleRealValueContext) IsRuleRealValueContext() {}

func NewRuleRealValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleRealValueContext {
	var p = new(RuleRealValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleRealValue

	return p
}

func (s *RuleRealValueContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleRealValueContext) RuleNumericRealValue() IRuleNumericRealValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleNumericRealValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleNumericRealValueContext)
}

func (s *RuleRealValueContext) RuleSpecialRealValue() IRuleSpecialRealValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSpecialRealValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSpecialRealValueContext)
}

func (s *RuleRealValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleRealValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleRealValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleRealValue(s)
	}
}

func (s *RuleRealValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleRealValue(s)
	}
}

func (s *RuleRealValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleRealValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleRealValue() (localctx IRuleRealValueContext) {
	this := p
	_ = this

	localctx = NewRuleRealValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, asn1ParserRULE_ruleRealValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1654)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case asn1ParserCURLY_START, asn1ParserMINUS, asn1ParserFLOAT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1652)
			p.RuleNumericRealValue()
		}

	case asn1ParserMINUS_INFINITY_SYM, asn1ParserNOT_A_NUMBER_SYM, asn1ParserPLUS_INFINITY_SYM:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1653)
			p.RuleSpecialRealValue()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRuleRelativeIRIValueContext is an interface to support dynamic dispatch.
type IRuleRelativeIRIValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleRelativeIRIValueContext differentiates from other interfaces.
	IsRuleRelativeIRIValueContext()
}

type RuleRelativeIRIValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleRelativeIRIValueContext() *RuleRelativeIRIValueContext {
	var p = new(RuleRelativeIRIValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleRelativeIRIValue
	return p
}

func (*RuleRelativeIRIValueContext) IsRuleRelativeIRIValueContext() {}

func NewRuleRelativeIRIValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleRelativeIRIValueContext {
	var p = new(RuleRelativeIRIValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleRelativeIRIValue

	return p
}

func (s *RuleRelativeIRIValueContext) GetParser() antlr.Parser { return s.parser }
func (s *RuleRelativeIRIValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleRelativeIRIValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleRelativeIRIValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleRelativeIRIValue(s)
	}
}

func (s *RuleRelativeIRIValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleRelativeIRIValue(s)
	}
}

func (s *RuleRelativeIRIValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleRelativeIRIValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleRelativeIRIValue() (localctx IRuleRelativeIRIValueContext) {
	this := p
	_ = this

	localctx = NewRuleRelativeIRIValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, asn1ParserRULE_ruleRelativeIRIValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)

	return localctx
}

// IRuleRelativeOIDValueContext is an interface to support dynamic dispatch.
type IRuleRelativeOIDValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleRelativeOIDValueContext differentiates from other interfaces.
	IsRuleRelativeOIDValueContext()
}

type RuleRelativeOIDValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleRelativeOIDValueContext() *RuleRelativeOIDValueContext {
	var p = new(RuleRelativeOIDValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleRelativeOIDValue
	return p
}

func (*RuleRelativeOIDValueContext) IsRuleRelativeOIDValueContext() {}

func NewRuleRelativeOIDValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleRelativeOIDValueContext {
	var p = new(RuleRelativeOIDValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleRelativeOIDValue

	return p
}

func (s *RuleRelativeOIDValueContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleRelativeOIDValueContext) CURLY_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_START, 0)
}

func (s *RuleRelativeOIDValueContext) RuleRelativeOIDComponentsList() IRuleRelativeOIDComponentsListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleRelativeOIDComponentsListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleRelativeOIDComponentsListContext)
}

func (s *RuleRelativeOIDValueContext) CURLY_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_END, 0)
}

func (s *RuleRelativeOIDValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleRelativeOIDValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleRelativeOIDValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleRelativeOIDValue(s)
	}
}

func (s *RuleRelativeOIDValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleRelativeOIDValue(s)
	}
}

func (s *RuleRelativeOIDValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleRelativeOIDValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleRelativeOIDValue() (localctx IRuleRelativeOIDValueContext) {
	this := p
	_ = this

	localctx = NewRuleRelativeOIDValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, asn1ParserRULE_ruleRelativeOIDValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1658)
		p.Match(asn1ParserCURLY_START)
	}
	{
		p.SetState(1659)
		p.ruleRelativeOIDComponentsList(0)
	}
	{
		p.SetState(1660)
		p.Match(asn1ParserCURLY_END)
	}

	return localctx
}

// IRuleSequenceValueContext is an interface to support dynamic dispatch.
type IRuleSequenceValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleSequenceValueContext differentiates from other interfaces.
	IsRuleSequenceValueContext()
}

type RuleSequenceValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleSequenceValueContext() *RuleSequenceValueContext {
	var p = new(RuleSequenceValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleSequenceValue
	return p
}

func (*RuleSequenceValueContext) IsRuleSequenceValueContext() {}

func NewRuleSequenceValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleSequenceValueContext {
	var p = new(RuleSequenceValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleSequenceValue

	return p
}

func (s *RuleSequenceValueContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleSequenceValueContext) CURLY_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_START, 0)
}

func (s *RuleSequenceValueContext) RuleComponentValueList() IRuleComponentValueListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleComponentValueListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleComponentValueListContext)
}

func (s *RuleSequenceValueContext) CURLY_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_END, 0)
}

func (s *RuleSequenceValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleSequenceValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleSequenceValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleSequenceValue(s)
	}
}

func (s *RuleSequenceValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleSequenceValue(s)
	}
}

func (s *RuleSequenceValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleSequenceValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleSequenceValue() (localctx IRuleSequenceValueContext) {
	this := p
	_ = this

	localctx = NewRuleSequenceValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, asn1ParserRULE_ruleSequenceValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1662)
		p.Match(asn1ParserCURLY_START)
	}
	{
		p.SetState(1663)
		p.ruleComponentValueList(0)
	}
	{
		p.SetState(1664)
		p.Match(asn1ParserCURLY_END)
	}

	return localctx
}

// IRuleSequenceOfValueContext is an interface to support dynamic dispatch.
type IRuleSequenceOfValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleSequenceOfValueContext differentiates from other interfaces.
	IsRuleSequenceOfValueContext()
}

type RuleSequenceOfValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleSequenceOfValueContext() *RuleSequenceOfValueContext {
	var p = new(RuleSequenceOfValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleSequenceOfValue
	return p
}

func (*RuleSequenceOfValueContext) IsRuleSequenceOfValueContext() {}

func NewRuleSequenceOfValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleSequenceOfValueContext {
	var p = new(RuleSequenceOfValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleSequenceOfValue

	return p
}

func (s *RuleSequenceOfValueContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleSequenceOfValueContext) CURLY_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_START, 0)
}

func (s *RuleSequenceOfValueContext) RuleValueList() IRuleValueListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueListContext)
}

func (s *RuleSequenceOfValueContext) CURLY_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_END, 0)
}

func (s *RuleSequenceOfValueContext) RuleNamedValueList() IRuleNamedValueListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleNamedValueListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleNamedValueListContext)
}

func (s *RuleSequenceOfValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleSequenceOfValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleSequenceOfValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleSequenceOfValue(s)
	}
}

func (s *RuleSequenceOfValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleSequenceOfValue(s)
	}
}

func (s *RuleSequenceOfValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleSequenceOfValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleSequenceOfValue() (localctx IRuleSequenceOfValueContext) {
	this := p
	_ = this

	localctx = NewRuleSequenceOfValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, asn1ParserRULE_ruleSequenceOfValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1676)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 83, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1666)
			p.Match(asn1ParserCURLY_START)
		}
		{
			p.SetState(1667)
			p.ruleValueList(0)
		}
		{
			p.SetState(1668)
			p.Match(asn1ParserCURLY_END)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1670)
			p.Match(asn1ParserCURLY_START)
		}
		{
			p.SetState(1671)
			p.ruleNamedValueList(0)
		}
		{
			p.SetState(1672)
			p.Match(asn1ParserCURLY_END)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1674)
			p.Match(asn1ParserCURLY_START)
		}
		{
			p.SetState(1675)
			p.Match(asn1ParserCURLY_END)
		}

	}

	return localctx
}

// IRuleSetValueContext is an interface to support dynamic dispatch.
type IRuleSetValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleSetValueContext differentiates from other interfaces.
	IsRuleSetValueContext()
}

type RuleSetValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleSetValueContext() *RuleSetValueContext {
	var p = new(RuleSetValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleSetValue
	return p
}

func (*RuleSetValueContext) IsRuleSetValueContext() {}

func NewRuleSetValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleSetValueContext {
	var p = new(RuleSetValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleSetValue

	return p
}

func (s *RuleSetValueContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleSetValueContext) CURLY_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_START, 0)
}

func (s *RuleSetValueContext) RuleComponentValueList() IRuleComponentValueListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleComponentValueListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleComponentValueListContext)
}

func (s *RuleSetValueContext) CURLY_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_END, 0)
}

func (s *RuleSetValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleSetValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleSetValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleSetValue(s)
	}
}

func (s *RuleSetValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleSetValue(s)
	}
}

func (s *RuleSetValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleSetValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleSetValue() (localctx IRuleSetValueContext) {
	this := p
	_ = this

	localctx = NewRuleSetValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, asn1ParserRULE_ruleSetValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1684)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 84, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1678)
			p.Match(asn1ParserCURLY_START)
		}
		{
			p.SetState(1679)
			p.ruleComponentValueList(0)
		}
		{
			p.SetState(1680)
			p.Match(asn1ParserCURLY_END)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1682)
			p.Match(asn1ParserCURLY_START)
		}
		{
			p.SetState(1683)
			p.Match(asn1ParserCURLY_END)
		}

	}

	return localctx
}

// IRuleSetOfValueContext is an interface to support dynamic dispatch.
type IRuleSetOfValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleSetOfValueContext differentiates from other interfaces.
	IsRuleSetOfValueContext()
}

type RuleSetOfValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleSetOfValueContext() *RuleSetOfValueContext {
	var p = new(RuleSetOfValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleSetOfValue
	return p
}

func (*RuleSetOfValueContext) IsRuleSetOfValueContext() {}

func NewRuleSetOfValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleSetOfValueContext {
	var p = new(RuleSetOfValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleSetOfValue

	return p
}

func (s *RuleSetOfValueContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleSetOfValueContext) CURLY_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_START, 0)
}

func (s *RuleSetOfValueContext) RuleValueList() IRuleValueListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueListContext)
}

func (s *RuleSetOfValueContext) CURLY_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_END, 0)
}

func (s *RuleSetOfValueContext) RuleNamedValueList() IRuleNamedValueListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleNamedValueListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleNamedValueListContext)
}

func (s *RuleSetOfValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleSetOfValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleSetOfValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleSetOfValue(s)
	}
}

func (s *RuleSetOfValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleSetOfValue(s)
	}
}

func (s *RuleSetOfValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleSetOfValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleSetOfValue() (localctx IRuleSetOfValueContext) {
	this := p
	_ = this

	localctx = NewRuleSetOfValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, asn1ParserRULE_ruleSetOfValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1696)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 85, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1686)
			p.Match(asn1ParserCURLY_START)
		}
		{
			p.SetState(1687)
			p.ruleValueList(0)
		}
		{
			p.SetState(1688)
			p.Match(asn1ParserCURLY_END)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1690)
			p.Match(asn1ParserCURLY_START)
		}
		{
			p.SetState(1691)
			p.ruleNamedValueList(0)
		}
		{
			p.SetState(1692)
			p.Match(asn1ParserCURLY_END)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1694)
			p.Match(asn1ParserCURLY_START)
		}
		{
			p.SetState(1695)
			p.Match(asn1ParserCURLY_END)
		}

	}

	return localctx
}

// IRulePrefixedValueContext is an interface to support dynamic dispatch.
type IRulePrefixedValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRulePrefixedValueContext differentiates from other interfaces.
	IsRulePrefixedValueContext()
}

type RulePrefixedValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRulePrefixedValueContext() *RulePrefixedValueContext {
	var p = new(RulePrefixedValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_rulePrefixedValue
	return p
}

func (*RulePrefixedValueContext) IsRulePrefixedValueContext() {}

func NewRulePrefixedValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RulePrefixedValueContext {
	var p = new(RulePrefixedValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_rulePrefixedValue

	return p
}

func (s *RulePrefixedValueContext) GetParser() antlr.Parser { return s.parser }

func (s *RulePrefixedValueContext) RuleValue() IRuleValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueContext)
}

func (s *RulePrefixedValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RulePrefixedValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RulePrefixedValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRulePrefixedValue(s)
	}
}

func (s *RulePrefixedValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRulePrefixedValue(s)
	}
}

func (s *RulePrefixedValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRulePrefixedValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RulePrefixedValue() (localctx IRulePrefixedValueContext) {
	this := p
	_ = this

	localctx = NewRulePrefixedValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, asn1ParserRULE_rulePrefixedValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1698)
		p.RuleValue()
	}

	return localctx
}

// IRuleTimeValueContext is an interface to support dynamic dispatch.
type IRuleTimeValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleTimeValueContext differentiates from other interfaces.
	IsRuleTimeValueContext()
}

type RuleTimeValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleTimeValueContext() *RuleTimeValueContext {
	var p = new(RuleTimeValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleTimeValue
	return p
}

func (*RuleTimeValueContext) IsRuleTimeValueContext() {}

func NewRuleTimeValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleTimeValueContext {
	var p = new(RuleTimeValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleTimeValue

	return p
}

func (s *RuleTimeValueContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleTimeValueContext) CHAR_STRING() antlr.TerminalNode {
	return s.GetToken(asn1ParserCHAR_STRING, 0)
}

func (s *RuleTimeValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleTimeValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleTimeValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleTimeValue(s)
	}
}

func (s *RuleTimeValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleTimeValue(s)
	}
}

func (s *RuleTimeValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleTimeValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleTimeValue() (localctx IRuleTimeValueContext) {
	this := p
	_ = this

	localctx = NewRuleTimeValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, asn1ParserRULE_ruleTimeValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1700)
		p.Match(asn1ParserCHAR_STRING)
	}

	return localctx
}

// IRuleBuiltinValueContext is an interface to support dynamic dispatch.
type IRuleBuiltinValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleBuiltinValueContext differentiates from other interfaces.
	IsRuleBuiltinValueContext()
}

type RuleBuiltinValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleBuiltinValueContext() *RuleBuiltinValueContext {
	var p = new(RuleBuiltinValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleBuiltinValue
	return p
}

func (*RuleBuiltinValueContext) IsRuleBuiltinValueContext() {}

func NewRuleBuiltinValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleBuiltinValueContext {
	var p = new(RuleBuiltinValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleBuiltinValue

	return p
}

func (s *RuleBuiltinValueContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleBuiltinValueContext) RuleBitStringValue() IRuleBitStringValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleBitStringValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleBitStringValueContext)
}

func (s *RuleBuiltinValueContext) RuleBooleanValue() IRuleBooleanValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleBooleanValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleBooleanValueContext)
}

func (s *RuleBuiltinValueContext) RuleCharacterStringValue() IRuleCharacterStringValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleCharacterStringValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleCharacterStringValueContext)
}

func (s *RuleBuiltinValueContext) RuleChoiceValue() IRuleChoiceValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleChoiceValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleChoiceValueContext)
}

func (s *RuleBuiltinValueContext) RuleEnumeratedValue() IRuleEnumeratedValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleEnumeratedValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleEnumeratedValueContext)
}

func (s *RuleBuiltinValueContext) RuleIntegerValue() IRuleIntegerValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleIntegerValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleIntegerValueContext)
}

func (s *RuleBuiltinValueContext) RuleIRIValue() IRuleIRIValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleIRIValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleIRIValueContext)
}

func (s *RuleBuiltinValueContext) RuleNullValue() IRuleNullValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleNullValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleNullValueContext)
}

func (s *RuleBuiltinValueContext) RuleObjectIdentifierValue() IRuleObjectIdentifierValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectIdentifierValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectIdentifierValueContext)
}

func (s *RuleBuiltinValueContext) RuleOctetStringValue() IRuleOctetStringValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleOctetStringValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleOctetStringValueContext)
}

func (s *RuleBuiltinValueContext) RuleRealValue() IRuleRealValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleRealValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleRealValueContext)
}

func (s *RuleBuiltinValueContext) RuleRelativeOIDValue() IRuleRelativeOIDValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleRelativeOIDValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleRelativeOIDValueContext)
}

func (s *RuleBuiltinValueContext) RuleSequenceValue() IRuleSequenceValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSequenceValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSequenceValueContext)
}

func (s *RuleBuiltinValueContext) RuleSequenceOfValue() IRuleSequenceOfValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSequenceOfValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSequenceOfValueContext)
}

func (s *RuleBuiltinValueContext) RuleSetValue() IRuleSetValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSetValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSetValueContext)
}

func (s *RuleBuiltinValueContext) RuleSetOfValue() IRuleSetOfValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSetOfValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSetOfValueContext)
}

func (s *RuleBuiltinValueContext) RuleTimeValue() IRuleTimeValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTimeValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTimeValueContext)
}

func (s *RuleBuiltinValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleBuiltinValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleBuiltinValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleBuiltinValue(s)
	}
}

func (s *RuleBuiltinValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleBuiltinValue(s)
	}
}

func (s *RuleBuiltinValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleBuiltinValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleBuiltinValue() (localctx IRuleBuiltinValueContext) {
	this := p
	_ = this

	localctx = NewRuleBuiltinValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, asn1ParserRULE_ruleBuiltinValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1719)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 86, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1702)
			p.RuleBitStringValue()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1703)
			p.RuleBooleanValue()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1704)
			p.RuleCharacterStringValue()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1705)
			p.RuleChoiceValue()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1706)
			p.RuleEnumeratedValue()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1707)
			p.RuleIntegerValue()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1708)
			p.RuleIRIValue()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1709)
			p.RuleNullValue()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1710)
			p.RuleObjectIdentifierValue()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1711)
			p.RuleOctetStringValue()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1712)
			p.RuleRealValue()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1713)
			p.RuleRelativeOIDValue()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1714)
			p.RuleSequenceValue()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1715)
			p.RuleSequenceOfValue()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1716)
			p.RuleSetValue()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1717)
			p.RuleSetOfValue()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1718)
			p.RuleTimeValue()
		}

	}

	return localctx
}

// IRuleValueFromObjectContext is an interface to support dynamic dispatch.
type IRuleValueFromObjectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleValueFromObjectContext differentiates from other interfaces.
	IsRuleValueFromObjectContext()
}

type RuleValueFromObjectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleValueFromObjectContext() *RuleValueFromObjectContext {
	var p = new(RuleValueFromObjectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleValueFromObject
	return p
}

func (*RuleValueFromObjectContext) IsRuleValueFromObjectContext() {}

func NewRuleValueFromObjectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleValueFromObjectContext {
	var p = new(RuleValueFromObjectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleValueFromObject

	return p
}

func (s *RuleValueFromObjectContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleValueFromObjectContext) RuleReferencedObjects() IRuleReferencedObjectsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleReferencedObjectsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleReferencedObjectsContext)
}

func (s *RuleValueFromObjectContext) DOT() antlr.TerminalNode {
	return s.GetToken(asn1ParserDOT, 0)
}

func (s *RuleValueFromObjectContext) RuleFieldName() IRuleFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleFieldNameContext)
}

func (s *RuleValueFromObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleValueFromObjectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleValueFromObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleValueFromObject(s)
	}
}

func (s *RuleValueFromObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleValueFromObject(s)
	}
}

func (s *RuleValueFromObjectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleValueFromObject(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleValueFromObject() (localctx IRuleValueFromObjectContext) {
	this := p
	_ = this

	localctx = NewRuleValueFromObjectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, asn1ParserRULE_ruleValueFromObject)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1721)
		p.RuleReferencedObjects()
	}
	{
		p.SetState(1722)
		p.Match(asn1ParserDOT)
	}
	{
		p.SetState(1723)
		p.ruleFieldName(0)
	}

	return localctx
}

// IRuleReferencedValueContext is an interface to support dynamic dispatch.
type IRuleReferencedValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleReferencedValueContext differentiates from other interfaces.
	IsRuleReferencedValueContext()
}

type RuleReferencedValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleReferencedValueContext() *RuleReferencedValueContext {
	var p = new(RuleReferencedValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleReferencedValue
	return p
}

func (*RuleReferencedValueContext) IsRuleReferencedValueContext() {}

func NewRuleReferencedValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleReferencedValueContext {
	var p = new(RuleReferencedValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleReferencedValue

	return p
}

func (s *RuleReferencedValueContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleReferencedValueContext) RuleDefinedValue() IRuleDefinedValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinedValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinedValueContext)
}

func (s *RuleReferencedValueContext) RuleValueFromObject() IRuleValueFromObjectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueFromObjectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueFromObjectContext)
}

func (s *RuleReferencedValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleReferencedValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleReferencedValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleReferencedValue(s)
	}
}

func (s *RuleReferencedValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleReferencedValue(s)
	}
}

func (s *RuleReferencedValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleReferencedValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleReferencedValue() (localctx IRuleReferencedValueContext) {
	this := p
	_ = this

	localctx = NewRuleReferencedValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, asn1ParserRULE_ruleReferencedValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1727)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 87, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1725)
			p.RuleDefinedValue()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1726)
			p.RuleValueFromObject()
		}

	}

	return localctx
}

// IRuleOpenTypeFieldValContext is an interface to support dynamic dispatch.
type IRuleOpenTypeFieldValContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleOpenTypeFieldValContext differentiates from other interfaces.
	IsRuleOpenTypeFieldValContext()
}

type RuleOpenTypeFieldValContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleOpenTypeFieldValContext() *RuleOpenTypeFieldValContext {
	var p = new(RuleOpenTypeFieldValContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleOpenTypeFieldVal
	return p
}

func (*RuleOpenTypeFieldValContext) IsRuleOpenTypeFieldValContext() {}

func NewRuleOpenTypeFieldValContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleOpenTypeFieldValContext {
	var p = new(RuleOpenTypeFieldValContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleOpenTypeFieldVal

	return p
}

func (s *RuleOpenTypeFieldValContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleOpenTypeFieldValContext) RuleType() IRuleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeContext)
}

func (s *RuleOpenTypeFieldValContext) COLON() antlr.TerminalNode {
	return s.GetToken(asn1ParserCOLON, 0)
}

func (s *RuleOpenTypeFieldValContext) RuleValue() IRuleValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueContext)
}

func (s *RuleOpenTypeFieldValContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleOpenTypeFieldValContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleOpenTypeFieldValContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleOpenTypeFieldVal(s)
	}
}

func (s *RuleOpenTypeFieldValContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleOpenTypeFieldVal(s)
	}
}

func (s *RuleOpenTypeFieldValContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleOpenTypeFieldVal(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleOpenTypeFieldVal() (localctx IRuleOpenTypeFieldValContext) {
	this := p
	_ = this

	localctx = NewRuleOpenTypeFieldValContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, asn1ParserRULE_ruleOpenTypeFieldVal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1729)
		p.RuleType()
	}
	{
		p.SetState(1730)
		p.Match(asn1ParserCOLON)
	}
	{
		p.SetState(1731)
		p.RuleValue()
	}

	return localctx
}

// IRuleFixedTypeFieldValContext is an interface to support dynamic dispatch.
type IRuleFixedTypeFieldValContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleFixedTypeFieldValContext differentiates from other interfaces.
	IsRuleFixedTypeFieldValContext()
}

type RuleFixedTypeFieldValContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleFixedTypeFieldValContext() *RuleFixedTypeFieldValContext {
	var p = new(RuleFixedTypeFieldValContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleFixedTypeFieldVal
	return p
}

func (*RuleFixedTypeFieldValContext) IsRuleFixedTypeFieldValContext() {}

func NewRuleFixedTypeFieldValContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleFixedTypeFieldValContext {
	var p = new(RuleFixedTypeFieldValContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleFixedTypeFieldVal

	return p
}

func (s *RuleFixedTypeFieldValContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleFixedTypeFieldValContext) RuleBuiltinValue() IRuleBuiltinValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleBuiltinValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleBuiltinValueContext)
}

func (s *RuleFixedTypeFieldValContext) RuleReferencedValue() IRuleReferencedValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleReferencedValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleReferencedValueContext)
}

func (s *RuleFixedTypeFieldValContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleFixedTypeFieldValContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleFixedTypeFieldValContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleFixedTypeFieldVal(s)
	}
}

func (s *RuleFixedTypeFieldValContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleFixedTypeFieldVal(s)
	}
}

func (s *RuleFixedTypeFieldValContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleFixedTypeFieldVal(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleFixedTypeFieldVal() (localctx IRuleFixedTypeFieldValContext) {
	this := p
	_ = this

	localctx = NewRuleFixedTypeFieldValContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, asn1ParserRULE_ruleFixedTypeFieldVal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1735)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1733)
			p.RuleBuiltinValue()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1734)
			p.RuleReferencedValue()
		}

	}

	return localctx
}

// IRuleObjectClassFieldValueContext is an interface to support dynamic dispatch.
type IRuleObjectClassFieldValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleObjectClassFieldValueContext differentiates from other interfaces.
	IsRuleObjectClassFieldValueContext()
}

type RuleObjectClassFieldValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleObjectClassFieldValueContext() *RuleObjectClassFieldValueContext {
	var p = new(RuleObjectClassFieldValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleObjectClassFieldValue
	return p
}

func (*RuleObjectClassFieldValueContext) IsRuleObjectClassFieldValueContext() {}

func NewRuleObjectClassFieldValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleObjectClassFieldValueContext {
	var p = new(RuleObjectClassFieldValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleObjectClassFieldValue

	return p
}

func (s *RuleObjectClassFieldValueContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleObjectClassFieldValueContext) RuleOpenTypeFieldVal() IRuleOpenTypeFieldValContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleOpenTypeFieldValContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleOpenTypeFieldValContext)
}

func (s *RuleObjectClassFieldValueContext) RuleFixedTypeFieldVal() IRuleFixedTypeFieldValContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleFixedTypeFieldValContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleFixedTypeFieldValContext)
}

func (s *RuleObjectClassFieldValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleObjectClassFieldValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleObjectClassFieldValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleObjectClassFieldValue(s)
	}
}

func (s *RuleObjectClassFieldValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleObjectClassFieldValue(s)
	}
}

func (s *RuleObjectClassFieldValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleObjectClassFieldValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleObjectClassFieldValue() (localctx IRuleObjectClassFieldValueContext) {
	this := p
	_ = this

	localctx = NewRuleObjectClassFieldValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, asn1ParserRULE_ruleObjectClassFieldValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1739)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 89, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1737)
			p.RuleOpenTypeFieldVal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1738)
			p.RuleFixedTypeFieldVal()
		}

	}

	return localctx
}

// IRuleValueContext is an interface to support dynamic dispatch.
type IRuleValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleValueContext differentiates from other interfaces.
	IsRuleValueContext()
}

type RuleValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleValueContext() *RuleValueContext {
	var p = new(RuleValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleValue
	return p
}

func (*RuleValueContext) IsRuleValueContext() {}

func NewRuleValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleValueContext {
	var p = new(RuleValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleValue

	return p
}

func (s *RuleValueContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleValueContext) RuleBuiltinValue() IRuleBuiltinValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleBuiltinValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleBuiltinValueContext)
}

func (s *RuleValueContext) RuleReferencedValue() IRuleReferencedValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleReferencedValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleReferencedValueContext)
}

func (s *RuleValueContext) RuleObjectClassFieldValue() IRuleObjectClassFieldValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectClassFieldValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectClassFieldValueContext)
}

func (s *RuleValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleValue(s)
	}
}

func (s *RuleValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleValue(s)
	}
}

func (s *RuleValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleValue() (localctx IRuleValueContext) {
	this := p
	_ = this

	localctx = NewRuleValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, asn1ParserRULE_ruleValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1744)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 90, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1741)
			p.RuleBuiltinValue()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1742)
			p.RuleReferencedValue()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1743)
			p.RuleObjectClassFieldValue()
		}

	}

	return localctx
}

// IRuleValueSetContext is an interface to support dynamic dispatch.
type IRuleValueSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleValueSetContext differentiates from other interfaces.
	IsRuleValueSetContext()
}

type RuleValueSetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleValueSetContext() *RuleValueSetContext {
	var p = new(RuleValueSetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleValueSet
	return p
}

func (*RuleValueSetContext) IsRuleValueSetContext() {}

func NewRuleValueSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleValueSetContext {
	var p = new(RuleValueSetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleValueSet

	return p
}

func (s *RuleValueSetContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleValueSetContext) CURLY_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_START, 0)
}

func (s *RuleValueSetContext) RuleElementSetSpecs() IRuleElementSetSpecsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleElementSetSpecsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleElementSetSpecsContext)
}

func (s *RuleValueSetContext) CURLY_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_END, 0)
}

func (s *RuleValueSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleValueSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleValueSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleValueSet(s)
	}
}

func (s *RuleValueSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleValueSet(s)
	}
}

func (s *RuleValueSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleValueSet(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleValueSet() (localctx IRuleValueSetContext) {
	this := p
	_ = this

	localctx = NewRuleValueSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, asn1ParserRULE_ruleValueSet)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1746)
		p.Match(asn1ParserCURLY_START)
	}
	{
		p.SetState(1747)
		p.RuleElementSetSpecs()
	}
	{
		p.SetState(1748)
		p.Match(asn1ParserCURLY_END)
	}

	return localctx
}

// IRuleDefinedObjectClassContext is an interface to support dynamic dispatch.
type IRuleDefinedObjectClassContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleDefinedObjectClassContext differentiates from other interfaces.
	IsRuleDefinedObjectClassContext()
}

type RuleDefinedObjectClassContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleDefinedObjectClassContext() *RuleDefinedObjectClassContext {
	var p = new(RuleDefinedObjectClassContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleDefinedObjectClass
	return p
}

func (*RuleDefinedObjectClassContext) IsRuleDefinedObjectClassContext() {}

func NewRuleDefinedObjectClassContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleDefinedObjectClassContext {
	var p = new(RuleDefinedObjectClassContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleDefinedObjectClass

	return p
}

func (s *RuleDefinedObjectClassContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleDefinedObjectClassContext) RuleExternalObjectClassReference() IRuleExternalObjectClassReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleExternalObjectClassReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleExternalObjectClassReferenceContext)
}

func (s *RuleDefinedObjectClassContext) RuleObjectClassReference() IRuleObjectClassReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectClassReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectClassReferenceContext)
}

func (s *RuleDefinedObjectClassContext) RuleUsefulObjectClassReference() IRuleUsefulObjectClassReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleUsefulObjectClassReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleUsefulObjectClassReferenceContext)
}

func (s *RuleDefinedObjectClassContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleDefinedObjectClassContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleDefinedObjectClassContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleDefinedObjectClass(s)
	}
}

func (s *RuleDefinedObjectClassContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleDefinedObjectClass(s)
	}
}

func (s *RuleDefinedObjectClassContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleDefinedObjectClass(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleDefinedObjectClass() (localctx IRuleDefinedObjectClassContext) {
	this := p
	_ = this

	localctx = NewRuleDefinedObjectClassContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, asn1ParserRULE_ruleDefinedObjectClass)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1753)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 91, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1750)
			p.RuleExternalObjectClassReference()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1751)
			p.RuleObjectClassReference()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1752)
			p.RuleUsefulObjectClassReference()
		}

	}

	return localctx
}

// IRuleObjectContext is an interface to support dynamic dispatch.
type IRuleObjectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleObjectContext differentiates from other interfaces.
	IsRuleObjectContext()
}

type RuleObjectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleObjectContext() *RuleObjectContext {
	var p = new(RuleObjectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleObject
	return p
}

func (*RuleObjectContext) IsRuleObjectContext() {}

func NewRuleObjectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleObjectContext {
	var p = new(RuleObjectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleObject

	return p
}

func (s *RuleObjectContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleObjectContext) RuleDefinedObject() IRuleDefinedObjectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinedObjectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinedObjectContext)
}

func (s *RuleObjectContext) RuleObjectDefn() IRuleObjectDefnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectDefnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectDefnContext)
}

func (s *RuleObjectContext) RuleObjectFromObject() IRuleObjectFromObjectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectFromObjectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectFromObjectContext)
}

func (s *RuleObjectContext) RuleParameterizedObject() IRuleParameterizedObjectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleParameterizedObjectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleParameterizedObjectContext)
}

func (s *RuleObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleObjectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleObject(s)
	}
}

func (s *RuleObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleObject(s)
	}
}

func (s *RuleObjectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleObject(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleObject() (localctx IRuleObjectContext) {
	this := p
	_ = this

	localctx = NewRuleObjectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, asn1ParserRULE_ruleObject)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1759)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 92, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1755)
			p.RuleDefinedObject()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1756)
			p.RuleObjectDefn()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1757)
			p.RuleObjectFromObject()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1758)
			p.RuleParameterizedObject()
		}

	}

	return localctx
}

// IRuleDefinedObjectContext is an interface to support dynamic dispatch.
type IRuleDefinedObjectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleDefinedObjectContext differentiates from other interfaces.
	IsRuleDefinedObjectContext()
}

type RuleDefinedObjectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleDefinedObjectContext() *RuleDefinedObjectContext {
	var p = new(RuleDefinedObjectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleDefinedObject
	return p
}

func (*RuleDefinedObjectContext) IsRuleDefinedObjectContext() {}

func NewRuleDefinedObjectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleDefinedObjectContext {
	var p = new(RuleDefinedObjectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleDefinedObject

	return p
}

func (s *RuleDefinedObjectContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleDefinedObjectContext) RuleExternalObjectReference() IRuleExternalObjectReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleExternalObjectReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleExternalObjectReferenceContext)
}

func (s *RuleDefinedObjectContext) RuleObjectReference() IRuleObjectReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectReferenceContext)
}

func (s *RuleDefinedObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleDefinedObjectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleDefinedObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleDefinedObject(s)
	}
}

func (s *RuleDefinedObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleDefinedObject(s)
	}
}

func (s *RuleDefinedObjectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleDefinedObject(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleDefinedObject() (localctx IRuleDefinedObjectContext) {
	this := p
	_ = this

	localctx = NewRuleDefinedObjectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, asn1ParserRULE_ruleDefinedObject)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1763)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 93, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1761)
			p.RuleExternalObjectReference()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1762)
			p.RuleObjectReference()
		}

	}

	return localctx
}

// IRuleDefinedObjectSetContext is an interface to support dynamic dispatch.
type IRuleDefinedObjectSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleDefinedObjectSetContext differentiates from other interfaces.
	IsRuleDefinedObjectSetContext()
}

type RuleDefinedObjectSetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleDefinedObjectSetContext() *RuleDefinedObjectSetContext {
	var p = new(RuleDefinedObjectSetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleDefinedObjectSet
	return p
}

func (*RuleDefinedObjectSetContext) IsRuleDefinedObjectSetContext() {}

func NewRuleDefinedObjectSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleDefinedObjectSetContext {
	var p = new(RuleDefinedObjectSetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleDefinedObjectSet

	return p
}

func (s *RuleDefinedObjectSetContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleDefinedObjectSetContext) RuleExternalObjectSetReference() IRuleExternalObjectSetReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleExternalObjectSetReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleExternalObjectSetReferenceContext)
}

func (s *RuleDefinedObjectSetContext) RuleObjectSetReference() IRuleObjectSetReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectSetReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectSetReferenceContext)
}

func (s *RuleDefinedObjectSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleDefinedObjectSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleDefinedObjectSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleDefinedObjectSet(s)
	}
}

func (s *RuleDefinedObjectSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleDefinedObjectSet(s)
	}
}

func (s *RuleDefinedObjectSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleDefinedObjectSet(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleDefinedObjectSet() (localctx IRuleDefinedObjectSetContext) {
	this := p
	_ = this

	localctx = NewRuleDefinedObjectSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, asn1ParserRULE_ruleDefinedObjectSet)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1767)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 94, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1765)
			p.RuleExternalObjectSetReference()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1766)
			p.RuleObjectSetReference()
		}

	}

	return localctx
}

// IRuleObjectDefnContext is an interface to support dynamic dispatch.
type IRuleObjectDefnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleObjectDefnContext differentiates from other interfaces.
	IsRuleObjectDefnContext()
}

type RuleObjectDefnContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleObjectDefnContext() *RuleObjectDefnContext {
	var p = new(RuleObjectDefnContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleObjectDefn
	return p
}

func (*RuleObjectDefnContext) IsRuleObjectDefnContext() {}

func NewRuleObjectDefnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleObjectDefnContext {
	var p = new(RuleObjectDefnContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleObjectDefn

	return p
}

func (s *RuleObjectDefnContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleObjectDefnContext) RuleDefaultSyntax() IRuleDefaultSyntaxContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefaultSyntaxContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefaultSyntaxContext)
}

func (s *RuleObjectDefnContext) RuleDefinedSyntax() IRuleDefinedSyntaxContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinedSyntaxContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinedSyntaxContext)
}

func (s *RuleObjectDefnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleObjectDefnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleObjectDefnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleObjectDefn(s)
	}
}

func (s *RuleObjectDefnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleObjectDefn(s)
	}
}

func (s *RuleObjectDefnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleObjectDefn(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleObjectDefn() (localctx IRuleObjectDefnContext) {
	this := p
	_ = this

	localctx = NewRuleObjectDefnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, asn1ParserRULE_ruleObjectDefn)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1771)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 95, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1769)
			p.RuleDefaultSyntax()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1770)
			p.RuleDefinedSyntax()
		}

	}

	return localctx
}

// IRuleDefaultSyntaxContext is an interface to support dynamic dispatch.
type IRuleDefaultSyntaxContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleDefaultSyntaxContext differentiates from other interfaces.
	IsRuleDefaultSyntaxContext()
}

type RuleDefaultSyntaxContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleDefaultSyntaxContext() *RuleDefaultSyntaxContext {
	var p = new(RuleDefaultSyntaxContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleDefaultSyntax
	return p
}

func (*RuleDefaultSyntaxContext) IsRuleDefaultSyntaxContext() {}

func NewRuleDefaultSyntaxContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleDefaultSyntaxContext {
	var p = new(RuleDefaultSyntaxContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleDefaultSyntax

	return p
}

func (s *RuleDefaultSyntaxContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleDefaultSyntaxContext) CURLY_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_START, 0)
}

func (s *RuleDefaultSyntaxContext) RuleFieldSettingList() IRuleFieldSettingListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleFieldSettingListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleFieldSettingListContext)
}

func (s *RuleDefaultSyntaxContext) CURLY_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_END, 0)
}

func (s *RuleDefaultSyntaxContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleDefaultSyntaxContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleDefaultSyntaxContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleDefaultSyntax(s)
	}
}

func (s *RuleDefaultSyntaxContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleDefaultSyntax(s)
	}
}

func (s *RuleDefaultSyntaxContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleDefaultSyntax(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleDefaultSyntax() (localctx IRuleDefaultSyntaxContext) {
	this := p
	_ = this

	localctx = NewRuleDefaultSyntaxContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, asn1ParserRULE_ruleDefaultSyntax)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1773)
		p.Match(asn1ParserCURLY_START)
	}
	{
		p.SetState(1774)
		p.ruleFieldSettingList(0)
	}
	{
		p.SetState(1775)
		p.Match(asn1ParserCURLY_END)
	}

	return localctx
}

// IRuleDefinedSyntaxContext is an interface to support dynamic dispatch.
type IRuleDefinedSyntaxContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleDefinedSyntaxContext differentiates from other interfaces.
	IsRuleDefinedSyntaxContext()
}

type RuleDefinedSyntaxContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleDefinedSyntaxContext() *RuleDefinedSyntaxContext {
	var p = new(RuleDefinedSyntaxContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleDefinedSyntax
	return p
}

func (*RuleDefinedSyntaxContext) IsRuleDefinedSyntaxContext() {}

func NewRuleDefinedSyntaxContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleDefinedSyntaxContext {
	var p = new(RuleDefinedSyntaxContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleDefinedSyntax

	return p
}

func (s *RuleDefinedSyntaxContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleDefinedSyntaxContext) CURLY_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_START, 0)
}

func (s *RuleDefinedSyntaxContext) RuleDefinedSyntaxTokenList() IRuleDefinedSyntaxTokenListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinedSyntaxTokenListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinedSyntaxTokenListContext)
}

func (s *RuleDefinedSyntaxContext) CURLY_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_END, 0)
}

func (s *RuleDefinedSyntaxContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleDefinedSyntaxContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleDefinedSyntaxContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleDefinedSyntax(s)
	}
}

func (s *RuleDefinedSyntaxContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleDefinedSyntax(s)
	}
}

func (s *RuleDefinedSyntaxContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleDefinedSyntax(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleDefinedSyntax() (localctx IRuleDefinedSyntaxContext) {
	this := p
	_ = this

	localctx = NewRuleDefinedSyntaxContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, asn1ParserRULE_ruleDefinedSyntax)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1777)
		p.Match(asn1ParserCURLY_START)
	}
	{
		p.SetState(1778)
		p.ruleDefinedSyntaxTokenList(0)
	}
	{
		p.SetState(1779)
		p.Match(asn1ParserCURLY_END)
	}

	return localctx
}

// IRuleDefinedSyntaxTokenListContext is an interface to support dynamic dispatch.
type IRuleDefinedSyntaxTokenListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleDefinedSyntaxTokenListContext differentiates from other interfaces.
	IsRuleDefinedSyntaxTokenListContext()
}

type RuleDefinedSyntaxTokenListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleDefinedSyntaxTokenListContext() *RuleDefinedSyntaxTokenListContext {
	var p = new(RuleDefinedSyntaxTokenListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleDefinedSyntaxTokenList
	return p
}

func (*RuleDefinedSyntaxTokenListContext) IsRuleDefinedSyntaxTokenListContext() {}

func NewRuleDefinedSyntaxTokenListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleDefinedSyntaxTokenListContext {
	var p = new(RuleDefinedSyntaxTokenListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleDefinedSyntaxTokenList

	return p
}

func (s *RuleDefinedSyntaxTokenListContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleDefinedSyntaxTokenListContext) RuleDefinedSyntaxToken() IRuleDefinedSyntaxTokenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinedSyntaxTokenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinedSyntaxTokenContext)
}

func (s *RuleDefinedSyntaxTokenListContext) RuleDefinedSyntaxTokenList() IRuleDefinedSyntaxTokenListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinedSyntaxTokenListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinedSyntaxTokenListContext)
}

func (s *RuleDefinedSyntaxTokenListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleDefinedSyntaxTokenListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleDefinedSyntaxTokenListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleDefinedSyntaxTokenList(s)
	}
}

func (s *RuleDefinedSyntaxTokenListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleDefinedSyntaxTokenList(s)
	}
}

func (s *RuleDefinedSyntaxTokenListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleDefinedSyntaxTokenList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleDefinedSyntaxTokenList() (localctx IRuleDefinedSyntaxTokenListContext) {
	return p.ruleDefinedSyntaxTokenList(0)
}

func (p *asn1Parser) ruleDefinedSyntaxTokenList(_p int) (localctx IRuleDefinedSyntaxTokenListContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRuleDefinedSyntaxTokenListContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRuleDefinedSyntaxTokenListContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 404
	p.EnterRecursionRule(localctx, 404, asn1ParserRULE_ruleDefinedSyntaxTokenList, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1784)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1782)
			p.RuleDefinedSyntaxToken()
		}

	case 2:

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1790)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewRuleDefinedSyntaxTokenListContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, asn1ParserRULE_ruleDefinedSyntaxTokenList)
			p.SetState(1786)

			if !(p.Precpred(p.GetParserRuleContext(), 3)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
			}
			{
				p.SetState(1787)
				p.RuleDefinedSyntaxToken()
			}

		}
		p.SetState(1792)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 97, p.GetParserRuleContext())
	}

	return localctx
}

// IRuleDefinedSyntaxTokenContext is an interface to support dynamic dispatch.
type IRuleDefinedSyntaxTokenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleDefinedSyntaxTokenContext differentiates from other interfaces.
	IsRuleDefinedSyntaxTokenContext()
}

type RuleDefinedSyntaxTokenContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleDefinedSyntaxTokenContext() *RuleDefinedSyntaxTokenContext {
	var p = new(RuleDefinedSyntaxTokenContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleDefinedSyntaxToken
	return p
}

func (*RuleDefinedSyntaxTokenContext) IsRuleDefinedSyntaxTokenContext() {}

func NewRuleDefinedSyntaxTokenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleDefinedSyntaxTokenContext {
	var p = new(RuleDefinedSyntaxTokenContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleDefinedSyntaxToken

	return p
}

func (s *RuleDefinedSyntaxTokenContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleDefinedSyntaxTokenContext) RuleLiteral() IRuleLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleLiteralContext)
}

func (s *RuleDefinedSyntaxTokenContext) RuleSetting() IRuleSettingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSettingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSettingContext)
}

func (s *RuleDefinedSyntaxTokenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleDefinedSyntaxTokenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleDefinedSyntaxTokenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleDefinedSyntaxToken(s)
	}
}

func (s *RuleDefinedSyntaxTokenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleDefinedSyntaxToken(s)
	}
}

func (s *RuleDefinedSyntaxTokenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleDefinedSyntaxToken(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleDefinedSyntaxToken() (localctx IRuleDefinedSyntaxTokenContext) {
	this := p
	_ = this

	localctx = NewRuleDefinedSyntaxTokenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, asn1ParserRULE_ruleDefinedSyntaxToken)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1795)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 98, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1793)
			p.RuleLiteral()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1794)
			p.RuleSetting()
		}

	}

	return localctx
}

// IRuleLiteralContext is an interface to support dynamic dispatch.
type IRuleLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleLiteralContext differentiates from other interfaces.
	IsRuleLiteralContext()
}

type RuleLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleLiteralContext() *RuleLiteralContext {
	var p = new(RuleLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleLiteral
	return p
}

func (*RuleLiteralContext) IsRuleLiteralContext() {}

func NewRuleLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleLiteralContext {
	var p = new(RuleLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleLiteral

	return p
}

func (s *RuleLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleLiteralContext) RuleWord() IRuleWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleWordContext)
}

func (s *RuleLiteralContext) COMMA() antlr.TerminalNode {
	return s.GetToken(asn1ParserCOMMA, 0)
}

func (s *RuleLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleLiteral(s)
	}
}

func (s *RuleLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleLiteral(s)
	}
}

func (s *RuleLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleLiteral() (localctx IRuleLiteralContext) {
	this := p
	_ = this

	localctx = NewRuleLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, asn1ParserRULE_ruleLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1799)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case asn1ParserUCASE_ID, asn1ParserLCASE_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1797)
			p.RuleWord()
		}

	case asn1ParserCOMMA:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1798)
			p.Match(asn1ParserCOMMA)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRuleWordContext is an interface to support dynamic dispatch.
type IRuleWordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleWordContext differentiates from other interfaces.
	IsRuleWordContext()
}

type RuleWordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleWordContext() *RuleWordContext {
	var p = new(RuleWordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleWord
	return p
}

func (*RuleWordContext) IsRuleWordContext() {}

func NewRuleWordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleWordContext {
	var p = new(RuleWordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleWord

	return p
}

func (s *RuleWordContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleWordContext) LCASE_ID() antlr.TerminalNode {
	return s.GetToken(asn1ParserLCASE_ID, 0)
}

func (s *RuleWordContext) UCASE_ID() antlr.TerminalNode {
	return s.GetToken(asn1ParserUCASE_ID, 0)
}

func (s *RuleWordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleWordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleWordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleWord(s)
	}
}

func (s *RuleWordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleWord(s)
	}
}

func (s *RuleWordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleWord(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleWord() (localctx IRuleWordContext) {
	this := p
	_ = this

	localctx = NewRuleWordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, asn1ParserRULE_ruleWord)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1801)
		_la = p.GetTokenStream().LA(1)

		if !(_la == asn1ParserUCASE_ID || _la == asn1ParserLCASE_ID) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IRuleFieldSettingListContext is an interface to support dynamic dispatch.
type IRuleFieldSettingListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleFieldSettingListContext differentiates from other interfaces.
	IsRuleFieldSettingListContext()
}

type RuleFieldSettingListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleFieldSettingListContext() *RuleFieldSettingListContext {
	var p = new(RuleFieldSettingListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleFieldSettingList
	return p
}

func (*RuleFieldSettingListContext) IsRuleFieldSettingListContext() {}

func NewRuleFieldSettingListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleFieldSettingListContext {
	var p = new(RuleFieldSettingListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleFieldSettingList

	return p
}

func (s *RuleFieldSettingListContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleFieldSettingListContext) RuleFieldSetting() IRuleFieldSettingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleFieldSettingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleFieldSettingContext)
}

func (s *RuleFieldSettingListContext) RuleFieldSettingList() IRuleFieldSettingListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleFieldSettingListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleFieldSettingListContext)
}

func (s *RuleFieldSettingListContext) COMMA() antlr.TerminalNode {
	return s.GetToken(asn1ParserCOMMA, 0)
}

func (s *RuleFieldSettingListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleFieldSettingListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleFieldSettingListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleFieldSettingList(s)
	}
}

func (s *RuleFieldSettingListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleFieldSettingList(s)
	}
}

func (s *RuleFieldSettingListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleFieldSettingList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleFieldSettingList() (localctx IRuleFieldSettingListContext) {
	return p.ruleFieldSettingList(0)
}

func (p *asn1Parser) ruleFieldSettingList(_p int) (localctx IRuleFieldSettingListContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRuleFieldSettingListContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRuleFieldSettingListContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 412
	p.EnterRecursionRule(localctx, 412, asn1ParserRULE_ruleFieldSettingList, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1806)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 100, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1804)
			p.RuleFieldSetting()
		}

	case 2:

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1813)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 101, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewRuleFieldSettingListContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, asn1ParserRULE_ruleFieldSettingList)
			p.SetState(1808)

			if !(p.Precpred(p.GetParserRuleContext(), 3)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
			}
			{
				p.SetState(1809)
				p.Match(asn1ParserCOMMA)
			}
			{
				p.SetState(1810)
				p.RuleFieldSetting()
			}

		}
		p.SetState(1815)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 101, p.GetParserRuleContext())
	}

	return localctx
}

// IRuleFieldSettingContext is an interface to support dynamic dispatch.
type IRuleFieldSettingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleFieldSettingContext differentiates from other interfaces.
	IsRuleFieldSettingContext()
}

type RuleFieldSettingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleFieldSettingContext() *RuleFieldSettingContext {
	var p = new(RuleFieldSettingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleFieldSetting
	return p
}

func (*RuleFieldSettingContext) IsRuleFieldSettingContext() {}

func NewRuleFieldSettingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleFieldSettingContext {
	var p = new(RuleFieldSettingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleFieldSetting

	return p
}

func (s *RuleFieldSettingContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleFieldSettingContext) RulePrimitiveFieldName() IRulePrimitiveFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRulePrimitiveFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRulePrimitiveFieldNameContext)
}

func (s *RuleFieldSettingContext) RuleSetting() IRuleSettingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSettingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSettingContext)
}

func (s *RuleFieldSettingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleFieldSettingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleFieldSettingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleFieldSetting(s)
	}
}

func (s *RuleFieldSettingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleFieldSetting(s)
	}
}

func (s *RuleFieldSettingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleFieldSetting(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleFieldSetting() (localctx IRuleFieldSettingContext) {
	this := p
	_ = this

	localctx = NewRuleFieldSettingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, asn1ParserRULE_ruleFieldSetting)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1816)
		p.RulePrimitiveFieldName()
	}
	{
		p.SetState(1817)
		p.RuleSetting()
	}

	return localctx
}

// IRulePrimitiveFieldNameContext is an interface to support dynamic dispatch.
type IRulePrimitiveFieldNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRulePrimitiveFieldNameContext differentiates from other interfaces.
	IsRulePrimitiveFieldNameContext()
}

type RulePrimitiveFieldNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRulePrimitiveFieldNameContext() *RulePrimitiveFieldNameContext {
	var p = new(RulePrimitiveFieldNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_rulePrimitiveFieldName
	return p
}

func (*RulePrimitiveFieldNameContext) IsRulePrimitiveFieldNameContext() {}

func NewRulePrimitiveFieldNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RulePrimitiveFieldNameContext {
	var p = new(RulePrimitiveFieldNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_rulePrimitiveFieldName

	return p
}

func (s *RulePrimitiveFieldNameContext) GetParser() antlr.Parser { return s.parser }

func (s *RulePrimitiveFieldNameContext) RuleTypeFieldReference() IRuleTypeFieldReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeFieldReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeFieldReferenceContext)
}

func (s *RulePrimitiveFieldNameContext) RuleValueFieldReference() IRuleValueFieldReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueFieldReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueFieldReferenceContext)
}

func (s *RulePrimitiveFieldNameContext) RuleValueSetFieldReference() IRuleValueSetFieldReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueSetFieldReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueSetFieldReferenceContext)
}

func (s *RulePrimitiveFieldNameContext) RuleObjectFieldReference() IRuleObjectFieldReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectFieldReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectFieldReferenceContext)
}

func (s *RulePrimitiveFieldNameContext) RuleObjectSetFieldReference() IRuleObjectSetFieldReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectSetFieldReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectSetFieldReferenceContext)
}

func (s *RulePrimitiveFieldNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RulePrimitiveFieldNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RulePrimitiveFieldNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRulePrimitiveFieldName(s)
	}
}

func (s *RulePrimitiveFieldNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRulePrimitiveFieldName(s)
	}
}

func (s *RulePrimitiveFieldNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRulePrimitiveFieldName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RulePrimitiveFieldName() (localctx IRulePrimitiveFieldNameContext) {
	this := p
	_ = this

	localctx = NewRulePrimitiveFieldNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, asn1ParserRULE_rulePrimitiveFieldName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1824)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1819)
			p.RuleTypeFieldReference()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1820)
			p.RuleValueFieldReference()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1821)
			p.RuleValueSetFieldReference()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1822)
			p.RuleObjectFieldReference()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1823)
			p.RuleObjectSetFieldReference()
		}

	}

	return localctx
}

// IRuleSettingContext is an interface to support dynamic dispatch.
type IRuleSettingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleSettingContext differentiates from other interfaces.
	IsRuleSettingContext()
}

type RuleSettingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleSettingContext() *RuleSettingContext {
	var p = new(RuleSettingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleSetting
	return p
}

func (*RuleSettingContext) IsRuleSettingContext() {}

func NewRuleSettingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleSettingContext {
	var p = new(RuleSettingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleSetting

	return p
}

func (s *RuleSettingContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleSettingContext) RuleType() IRuleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeContext)
}

func (s *RuleSettingContext) RuleValue() IRuleValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueContext)
}

func (s *RuleSettingContext) RuleValueSet() IRuleValueSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueSetContext)
}

func (s *RuleSettingContext) RuleObject() IRuleObjectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectContext)
}

func (s *RuleSettingContext) RuleObjectSet() IRuleObjectSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectSetContext)
}

func (s *RuleSettingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleSettingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleSettingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleSetting(s)
	}
}

func (s *RuleSettingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleSetting(s)
	}
}

func (s *RuleSettingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleSetting(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleSetting() (localctx IRuleSettingContext) {
	this := p
	_ = this

	localctx = NewRuleSettingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, asn1ParserRULE_ruleSetting)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1831)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 103, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1826)
			p.RuleType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1827)
			p.RuleValue()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1828)
			p.RuleValueSet()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1829)
			p.RuleObject()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1830)
			p.RuleObjectSet()
		}

	}

	return localctx
}

// IRuleObjectFromObjectContext is an interface to support dynamic dispatch.
type IRuleObjectFromObjectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleObjectFromObjectContext differentiates from other interfaces.
	IsRuleObjectFromObjectContext()
}

type RuleObjectFromObjectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleObjectFromObjectContext() *RuleObjectFromObjectContext {
	var p = new(RuleObjectFromObjectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleObjectFromObject
	return p
}

func (*RuleObjectFromObjectContext) IsRuleObjectFromObjectContext() {}

func NewRuleObjectFromObjectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleObjectFromObjectContext {
	var p = new(RuleObjectFromObjectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleObjectFromObject

	return p
}

func (s *RuleObjectFromObjectContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleObjectFromObjectContext) RuleReferencedObjects() IRuleReferencedObjectsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleReferencedObjectsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleReferencedObjectsContext)
}

func (s *RuleObjectFromObjectContext) DOT() antlr.TerminalNode {
	return s.GetToken(asn1ParserDOT, 0)
}

func (s *RuleObjectFromObjectContext) RuleFieldName() IRuleFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleFieldNameContext)
}

func (s *RuleObjectFromObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleObjectFromObjectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleObjectFromObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleObjectFromObject(s)
	}
}

func (s *RuleObjectFromObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleObjectFromObject(s)
	}
}

func (s *RuleObjectFromObjectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleObjectFromObject(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleObjectFromObject() (localctx IRuleObjectFromObjectContext) {
	this := p
	_ = this

	localctx = NewRuleObjectFromObjectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, asn1ParserRULE_ruleObjectFromObject)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1833)
		p.RuleReferencedObjects()
	}
	{
		p.SetState(1834)
		p.Match(asn1ParserDOT)
	}
	{
		p.SetState(1835)
		p.ruleFieldName(0)
	}

	return localctx
}

// IRuleObjectSetFromObjectsContext is an interface to support dynamic dispatch.
type IRuleObjectSetFromObjectsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleObjectSetFromObjectsContext differentiates from other interfaces.
	IsRuleObjectSetFromObjectsContext()
}

type RuleObjectSetFromObjectsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleObjectSetFromObjectsContext() *RuleObjectSetFromObjectsContext {
	var p = new(RuleObjectSetFromObjectsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleObjectSetFromObjects
	return p
}

func (*RuleObjectSetFromObjectsContext) IsRuleObjectSetFromObjectsContext() {}

func NewRuleObjectSetFromObjectsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleObjectSetFromObjectsContext {
	var p = new(RuleObjectSetFromObjectsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleObjectSetFromObjects

	return p
}

func (s *RuleObjectSetFromObjectsContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleObjectSetFromObjectsContext) RuleReferencedObjects() IRuleReferencedObjectsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleReferencedObjectsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleReferencedObjectsContext)
}

func (s *RuleObjectSetFromObjectsContext) DOT() antlr.TerminalNode {
	return s.GetToken(asn1ParserDOT, 0)
}

func (s *RuleObjectSetFromObjectsContext) RuleFieldName() IRuleFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleFieldNameContext)
}

func (s *RuleObjectSetFromObjectsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleObjectSetFromObjectsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleObjectSetFromObjectsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleObjectSetFromObjects(s)
	}
}

func (s *RuleObjectSetFromObjectsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleObjectSetFromObjects(s)
	}
}

func (s *RuleObjectSetFromObjectsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleObjectSetFromObjects(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleObjectSetFromObjects() (localctx IRuleObjectSetFromObjectsContext) {
	this := p
	_ = this

	localctx = NewRuleObjectSetFromObjectsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, asn1ParserRULE_ruleObjectSetFromObjects)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1837)
		p.RuleReferencedObjects()
	}
	{
		p.SetState(1838)
		p.Match(asn1ParserDOT)
	}
	{
		p.SetState(1839)
		p.ruleFieldName(0)
	}

	return localctx
}

// IRuleReferencedObjectsContext is an interface to support dynamic dispatch.
type IRuleReferencedObjectsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleReferencedObjectsContext differentiates from other interfaces.
	IsRuleReferencedObjectsContext()
}

type RuleReferencedObjectsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleReferencedObjectsContext() *RuleReferencedObjectsContext {
	var p = new(RuleReferencedObjectsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleReferencedObjects
	return p
}

func (*RuleReferencedObjectsContext) IsRuleReferencedObjectsContext() {}

func NewRuleReferencedObjectsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleReferencedObjectsContext {
	var p = new(RuleReferencedObjectsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleReferencedObjects

	return p
}

func (s *RuleReferencedObjectsContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleReferencedObjectsContext) RuleDefinedObject() IRuleDefinedObjectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinedObjectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinedObjectContext)
}

func (s *RuleReferencedObjectsContext) RuleParameterizedObject() IRuleParameterizedObjectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleParameterizedObjectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleParameterizedObjectContext)
}

func (s *RuleReferencedObjectsContext) RuleDefinedObjectSet() IRuleDefinedObjectSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinedObjectSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinedObjectSetContext)
}

func (s *RuleReferencedObjectsContext) RuleParameterizedObjectSet() IRuleParameterizedObjectSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleParameterizedObjectSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleParameterizedObjectSetContext)
}

func (s *RuleReferencedObjectsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleReferencedObjectsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleReferencedObjectsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleReferencedObjects(s)
	}
}

func (s *RuleReferencedObjectsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleReferencedObjects(s)
	}
}

func (s *RuleReferencedObjectsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleReferencedObjects(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleReferencedObjects() (localctx IRuleReferencedObjectsContext) {
	this := p
	_ = this

	localctx = NewRuleReferencedObjectsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, asn1ParserRULE_ruleReferencedObjects)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1845)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 104, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1841)
			p.RuleDefinedObject()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1842)
			p.RuleParameterizedObject()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1843)
			p.RuleDefinedObjectSet()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1844)
			p.RuleParameterizedObjectSet()
		}

	}

	return localctx
}

// IRuleFieldNameContext is an interface to support dynamic dispatch.
type IRuleFieldNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleFieldNameContext differentiates from other interfaces.
	IsRuleFieldNameContext()
}

type RuleFieldNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleFieldNameContext() *RuleFieldNameContext {
	var p = new(RuleFieldNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleFieldName
	return p
}

func (*RuleFieldNameContext) IsRuleFieldNameContext() {}

func NewRuleFieldNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleFieldNameContext {
	var p = new(RuleFieldNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleFieldName

	return p
}

func (s *RuleFieldNameContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleFieldNameContext) RulePrimitiveFieldName() IRulePrimitiveFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRulePrimitiveFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRulePrimitiveFieldNameContext)
}

func (s *RuleFieldNameContext) RuleFieldName() IRuleFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleFieldNameContext)
}

func (s *RuleFieldNameContext) DOT() antlr.TerminalNode {
	return s.GetToken(asn1ParserDOT, 0)
}

func (s *RuleFieldNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleFieldNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleFieldNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleFieldName(s)
	}
}

func (s *RuleFieldNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleFieldName(s)
	}
}

func (s *RuleFieldNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleFieldName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleFieldName() (localctx IRuleFieldNameContext) {
	return p.ruleFieldName(0)
}

func (p *asn1Parser) ruleFieldName(_p int) (localctx IRuleFieldNameContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRuleFieldNameContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRuleFieldNameContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 426
	p.EnterRecursionRule(localctx, 426, asn1ParserRULE_ruleFieldName, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1848)
		p.RulePrimitiveFieldName()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1855)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 105, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewRuleFieldNameContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, asn1ParserRULE_ruleFieldName)
			p.SetState(1850)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(1851)
				p.Match(asn1ParserDOT)
			}
			{
				p.SetState(1852)
				p.RulePrimitiveFieldName()
			}

		}
		p.SetState(1857)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 105, p.GetParserRuleContext())
	}

	return localctx
}

// IRuleParameterizedObjectContext is an interface to support dynamic dispatch.
type IRuleParameterizedObjectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleParameterizedObjectContext differentiates from other interfaces.
	IsRuleParameterizedObjectContext()
}

type RuleParameterizedObjectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleParameterizedObjectContext() *RuleParameterizedObjectContext {
	var p = new(RuleParameterizedObjectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleParameterizedObject
	return p
}

func (*RuleParameterizedObjectContext) IsRuleParameterizedObjectContext() {}

func NewRuleParameterizedObjectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleParameterizedObjectContext {
	var p = new(RuleParameterizedObjectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleParameterizedObject

	return p
}

func (s *RuleParameterizedObjectContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleParameterizedObjectContext) RuleDefinedObject() IRuleDefinedObjectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinedObjectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinedObjectContext)
}

func (s *RuleParameterizedObjectContext) RuleActualParameterList() IRuleActualParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleActualParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleActualParameterListContext)
}

func (s *RuleParameterizedObjectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleParameterizedObjectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleParameterizedObjectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleParameterizedObject(s)
	}
}

func (s *RuleParameterizedObjectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleParameterizedObject(s)
	}
}

func (s *RuleParameterizedObjectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleParameterizedObject(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleParameterizedObject() (localctx IRuleParameterizedObjectContext) {
	this := p
	_ = this

	localctx = NewRuleParameterizedObjectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, asn1ParserRULE_ruleParameterizedObject)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1858)
		p.RuleDefinedObject()
	}
	{
		p.SetState(1859)
		p.RuleActualParameterList()
	}

	return localctx
}

// IRuleObjectClassContext is an interface to support dynamic dispatch.
type IRuleObjectClassContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleObjectClassContext differentiates from other interfaces.
	IsRuleObjectClassContext()
}

type RuleObjectClassContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleObjectClassContext() *RuleObjectClassContext {
	var p = new(RuleObjectClassContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleObjectClass
	return p
}

func (*RuleObjectClassContext) IsRuleObjectClassContext() {}

func NewRuleObjectClassContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleObjectClassContext {
	var p = new(RuleObjectClassContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleObjectClass

	return p
}

func (s *RuleObjectClassContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleObjectClassContext) RuleDefinedObjectClass() IRuleDefinedObjectClassContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinedObjectClassContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinedObjectClassContext)
}

func (s *RuleObjectClassContext) RuleObjectClassDefn() IRuleObjectClassDefnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectClassDefnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectClassDefnContext)
}

func (s *RuleObjectClassContext) RuleParameterizedObjectClass() IRuleParameterizedObjectClassContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleParameterizedObjectClassContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleParameterizedObjectClassContext)
}

func (s *RuleObjectClassContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleObjectClassContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleObjectClassContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleObjectClass(s)
	}
}

func (s *RuleObjectClassContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleObjectClass(s)
	}
}

func (s *RuleObjectClassContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleObjectClass(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleObjectClass() (localctx IRuleObjectClassContext) {
	this := p
	_ = this

	localctx = NewRuleObjectClassContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, asn1ParserRULE_ruleObjectClass)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1864)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 106, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1861)
			p.RuleDefinedObjectClass()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1862)
			p.RuleObjectClassDefn()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1863)
			p.RuleParameterizedObjectClass()
		}

	}

	return localctx
}

// IRuleObjectClassDefnContext is an interface to support dynamic dispatch.
type IRuleObjectClassDefnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleObjectClassDefnContext differentiates from other interfaces.
	IsRuleObjectClassDefnContext()
}

type RuleObjectClassDefnContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleObjectClassDefnContext() *RuleObjectClassDefnContext {
	var p = new(RuleObjectClassDefnContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleObjectClassDefn
	return p
}

func (*RuleObjectClassDefnContext) IsRuleObjectClassDefnContext() {}

func NewRuleObjectClassDefnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleObjectClassDefnContext {
	var p = new(RuleObjectClassDefnContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleObjectClassDefn

	return p
}

func (s *RuleObjectClassDefnContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleObjectClassDefnContext) CLASS_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserCLASS_SYM, 0)
}

func (s *RuleObjectClassDefnContext) CURLY_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_START, 0)
}

func (s *RuleObjectClassDefnContext) RuleFieldSpecList() IRuleFieldSpecListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleFieldSpecListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleFieldSpecListContext)
}

func (s *RuleObjectClassDefnContext) CURLY_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_END, 0)
}

func (s *RuleObjectClassDefnContext) RuleWithSyntaxSpec() IRuleWithSyntaxSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleWithSyntaxSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleWithSyntaxSpecContext)
}

func (s *RuleObjectClassDefnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleObjectClassDefnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleObjectClassDefnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleObjectClassDefn(s)
	}
}

func (s *RuleObjectClassDefnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleObjectClassDefn(s)
	}
}

func (s *RuleObjectClassDefnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleObjectClassDefn(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleObjectClassDefn() (localctx IRuleObjectClassDefnContext) {
	this := p
	_ = this

	localctx = NewRuleObjectClassDefnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, asn1ParserRULE_ruleObjectClassDefn)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1866)
		p.Match(asn1ParserCLASS_SYM)
	}
	{
		p.SetState(1867)
		p.Match(asn1ParserCURLY_START)
	}
	{
		p.SetState(1868)
		p.ruleFieldSpecList(0)
	}
	{
		p.SetState(1869)
		p.Match(asn1ParserCURLY_END)
	}
	{
		p.SetState(1870)
		p.RuleWithSyntaxSpec()
	}

	return localctx
}

// IRuleFieldSpecListContext is an interface to support dynamic dispatch.
type IRuleFieldSpecListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleFieldSpecListContext differentiates from other interfaces.
	IsRuleFieldSpecListContext()
}

type RuleFieldSpecListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleFieldSpecListContext() *RuleFieldSpecListContext {
	var p = new(RuleFieldSpecListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleFieldSpecList
	return p
}

func (*RuleFieldSpecListContext) IsRuleFieldSpecListContext() {}

func NewRuleFieldSpecListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleFieldSpecListContext {
	var p = new(RuleFieldSpecListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleFieldSpecList

	return p
}

func (s *RuleFieldSpecListContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleFieldSpecListContext) RuleFieldSpec() IRuleFieldSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleFieldSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleFieldSpecContext)
}

func (s *RuleFieldSpecListContext) RuleFieldSpecList() IRuleFieldSpecListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleFieldSpecListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleFieldSpecListContext)
}

func (s *RuleFieldSpecListContext) COMMA() antlr.TerminalNode {
	return s.GetToken(asn1ParserCOMMA, 0)
}

func (s *RuleFieldSpecListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleFieldSpecListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleFieldSpecListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleFieldSpecList(s)
	}
}

func (s *RuleFieldSpecListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleFieldSpecList(s)
	}
}

func (s *RuleFieldSpecListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleFieldSpecList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleFieldSpecList() (localctx IRuleFieldSpecListContext) {
	return p.ruleFieldSpecList(0)
}

func (p *asn1Parser) ruleFieldSpecList(_p int) (localctx IRuleFieldSpecListContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRuleFieldSpecListContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRuleFieldSpecListContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 434
	p.EnterRecursionRule(localctx, 434, asn1ParserRULE_ruleFieldSpecList, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1873)
		p.RuleFieldSpec()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1880)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 107, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewRuleFieldSpecListContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, asn1ParserRULE_ruleFieldSpecList)
			p.SetState(1875)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(1876)
				p.Match(asn1ParserCOMMA)
			}
			{
				p.SetState(1877)
				p.RuleFieldSpec()
			}

		}
		p.SetState(1882)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 107, p.GetParserRuleContext())
	}

	return localctx
}

// IRuleFieldSpecContext is an interface to support dynamic dispatch.
type IRuleFieldSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleFieldSpecContext differentiates from other interfaces.
	IsRuleFieldSpecContext()
}

type RuleFieldSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleFieldSpecContext() *RuleFieldSpecContext {
	var p = new(RuleFieldSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleFieldSpec
	return p
}

func (*RuleFieldSpecContext) IsRuleFieldSpecContext() {}

func NewRuleFieldSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleFieldSpecContext {
	var p = new(RuleFieldSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleFieldSpec

	return p
}

func (s *RuleFieldSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleFieldSpecContext) RuleTypeFieldSpec() IRuleTypeFieldSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeFieldSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeFieldSpecContext)
}

func (s *RuleFieldSpecContext) RuleFixedTypeValueFieldSpec() IRuleFixedTypeValueFieldSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleFixedTypeValueFieldSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleFixedTypeValueFieldSpecContext)
}

func (s *RuleFieldSpecContext) RuleVariableTypeValueFieldSpec() IRuleVariableTypeValueFieldSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleVariableTypeValueFieldSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleVariableTypeValueFieldSpecContext)
}

func (s *RuleFieldSpecContext) RuleFixedTypeValueSetFieldSpec() IRuleFixedTypeValueSetFieldSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleFixedTypeValueSetFieldSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleFixedTypeValueSetFieldSpecContext)
}

func (s *RuleFieldSpecContext) RuleVariableTypeValueSetFieldSpec() IRuleVariableTypeValueSetFieldSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleVariableTypeValueSetFieldSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleVariableTypeValueSetFieldSpecContext)
}

func (s *RuleFieldSpecContext) RuleObjectFieldSpec() IRuleObjectFieldSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectFieldSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectFieldSpecContext)
}

func (s *RuleFieldSpecContext) RuleObjectSetFieldSpec() IRuleObjectSetFieldSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectSetFieldSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectSetFieldSpecContext)
}

func (s *RuleFieldSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleFieldSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleFieldSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleFieldSpec(s)
	}
}

func (s *RuleFieldSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleFieldSpec(s)
	}
}

func (s *RuleFieldSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleFieldSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleFieldSpec() (localctx IRuleFieldSpecContext) {
	this := p
	_ = this

	localctx = NewRuleFieldSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, asn1ParserRULE_ruleFieldSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1890)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 108, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1883)
			p.RuleTypeFieldSpec()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1884)
			p.RuleFixedTypeValueFieldSpec()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1885)
			p.RuleVariableTypeValueFieldSpec()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1886)
			p.RuleFixedTypeValueSetFieldSpec()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1887)
			p.RuleVariableTypeValueSetFieldSpec()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1888)
			p.RuleObjectFieldSpec()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1889)
			p.RuleObjectSetFieldSpec()
		}

	}

	return localctx
}

// IRuleTypeFieldSpecContext is an interface to support dynamic dispatch.
type IRuleTypeFieldSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleTypeFieldSpecContext differentiates from other interfaces.
	IsRuleTypeFieldSpecContext()
}

type RuleTypeFieldSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleTypeFieldSpecContext() *RuleTypeFieldSpecContext {
	var p = new(RuleTypeFieldSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleTypeFieldSpec
	return p
}

func (*RuleTypeFieldSpecContext) IsRuleTypeFieldSpecContext() {}

func NewRuleTypeFieldSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleTypeFieldSpecContext {
	var p = new(RuleTypeFieldSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleTypeFieldSpec

	return p
}

func (s *RuleTypeFieldSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleTypeFieldSpecContext) RuleTypeFieldReference() IRuleTypeFieldReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeFieldReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeFieldReferenceContext)
}

func (s *RuleTypeFieldSpecContext) RuleTypeOptionalitySpec() IRuleTypeOptionalitySpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeOptionalitySpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeOptionalitySpecContext)
}

func (s *RuleTypeFieldSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleTypeFieldSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleTypeFieldSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleTypeFieldSpec(s)
	}
}

func (s *RuleTypeFieldSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleTypeFieldSpec(s)
	}
}

func (s *RuleTypeFieldSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleTypeFieldSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleTypeFieldSpec() (localctx IRuleTypeFieldSpecContext) {
	this := p
	_ = this

	localctx = NewRuleTypeFieldSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, asn1ParserRULE_ruleTypeFieldSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1892)
		p.RuleTypeFieldReference()
	}
	{
		p.SetState(1893)
		p.RuleTypeOptionalitySpec()
	}

	return localctx
}

// IRuleFixedTypeValueFieldSpecContext is an interface to support dynamic dispatch.
type IRuleFixedTypeValueFieldSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleFixedTypeValueFieldSpecContext differentiates from other interfaces.
	IsRuleFixedTypeValueFieldSpecContext()
}

type RuleFixedTypeValueFieldSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleFixedTypeValueFieldSpecContext() *RuleFixedTypeValueFieldSpecContext {
	var p = new(RuleFixedTypeValueFieldSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleFixedTypeValueFieldSpec
	return p
}

func (*RuleFixedTypeValueFieldSpecContext) IsRuleFixedTypeValueFieldSpecContext() {}

func NewRuleFixedTypeValueFieldSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleFixedTypeValueFieldSpecContext {
	var p = new(RuleFixedTypeValueFieldSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleFixedTypeValueFieldSpec

	return p
}

func (s *RuleFixedTypeValueFieldSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleFixedTypeValueFieldSpecContext) RuleValueFieldReference() IRuleValueFieldReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueFieldReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueFieldReferenceContext)
}

func (s *RuleFixedTypeValueFieldSpecContext) RuleType() IRuleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeContext)
}

func (s *RuleFixedTypeValueFieldSpecContext) RuleUnique() IRuleUniqueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleUniqueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleUniqueContext)
}

func (s *RuleFixedTypeValueFieldSpecContext) RuleValueOptionalitySpec() IRuleValueOptionalitySpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueOptionalitySpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueOptionalitySpecContext)
}

func (s *RuleFixedTypeValueFieldSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleFixedTypeValueFieldSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleFixedTypeValueFieldSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleFixedTypeValueFieldSpec(s)
	}
}

func (s *RuleFixedTypeValueFieldSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleFixedTypeValueFieldSpec(s)
	}
}

func (s *RuleFixedTypeValueFieldSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleFixedTypeValueFieldSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleFixedTypeValueFieldSpec() (localctx IRuleFixedTypeValueFieldSpecContext) {
	this := p
	_ = this

	localctx = NewRuleFixedTypeValueFieldSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, asn1ParserRULE_ruleFixedTypeValueFieldSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1895)
		p.RuleValueFieldReference()
	}
	{
		p.SetState(1896)
		p.RuleType()
	}
	{
		p.SetState(1897)
		p.RuleUnique()
	}
	{
		p.SetState(1898)
		p.RuleValueOptionalitySpec()
	}

	return localctx
}

// IRuleUniqueContext is an interface to support dynamic dispatch.
type IRuleUniqueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleUniqueContext differentiates from other interfaces.
	IsRuleUniqueContext()
}

type RuleUniqueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleUniqueContext() *RuleUniqueContext {
	var p = new(RuleUniqueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleUnique
	return p
}

func (*RuleUniqueContext) IsRuleUniqueContext() {}

func NewRuleUniqueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleUniqueContext {
	var p = new(RuleUniqueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleUnique

	return p
}

func (s *RuleUniqueContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleUniqueContext) UNIQUE_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserUNIQUE_SYM, 0)
}

func (s *RuleUniqueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleUniqueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleUniqueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleUnique(s)
	}
}

func (s *RuleUniqueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleUnique(s)
	}
}

func (s *RuleUniqueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleUnique(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleUnique() (localctx IRuleUniqueContext) {
	this := p
	_ = this

	localctx = NewRuleUniqueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, asn1ParserRULE_ruleUnique)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1902)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 109, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1900)
			p.Match(asn1ParserUNIQUE_SYM)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)

	}

	return localctx
}

// IRuleVariableTypeValueFieldSpecContext is an interface to support dynamic dispatch.
type IRuleVariableTypeValueFieldSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleVariableTypeValueFieldSpecContext differentiates from other interfaces.
	IsRuleVariableTypeValueFieldSpecContext()
}

type RuleVariableTypeValueFieldSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleVariableTypeValueFieldSpecContext() *RuleVariableTypeValueFieldSpecContext {
	var p = new(RuleVariableTypeValueFieldSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleVariableTypeValueFieldSpec
	return p
}

func (*RuleVariableTypeValueFieldSpecContext) IsRuleVariableTypeValueFieldSpecContext() {}

func NewRuleVariableTypeValueFieldSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleVariableTypeValueFieldSpecContext {
	var p = new(RuleVariableTypeValueFieldSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleVariableTypeValueFieldSpec

	return p
}

func (s *RuleVariableTypeValueFieldSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleVariableTypeValueFieldSpecContext) RuleValueFieldReference() IRuleValueFieldReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueFieldReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueFieldReferenceContext)
}

func (s *RuleVariableTypeValueFieldSpecContext) RuleFieldName() IRuleFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleFieldNameContext)
}

func (s *RuleVariableTypeValueFieldSpecContext) RuleValueOptionalitySpec() IRuleValueOptionalitySpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueOptionalitySpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueOptionalitySpecContext)
}

func (s *RuleVariableTypeValueFieldSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleVariableTypeValueFieldSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleVariableTypeValueFieldSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleVariableTypeValueFieldSpec(s)
	}
}

func (s *RuleVariableTypeValueFieldSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleVariableTypeValueFieldSpec(s)
	}
}

func (s *RuleVariableTypeValueFieldSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleVariableTypeValueFieldSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleVariableTypeValueFieldSpec() (localctx IRuleVariableTypeValueFieldSpecContext) {
	this := p
	_ = this

	localctx = NewRuleVariableTypeValueFieldSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, asn1ParserRULE_ruleVariableTypeValueFieldSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1904)
		p.RuleValueFieldReference()
	}
	{
		p.SetState(1905)
		p.ruleFieldName(0)
	}
	{
		p.SetState(1906)
		p.RuleValueOptionalitySpec()
	}

	return localctx
}

// IRuleFixedTypeValueSetFieldSpecContext is an interface to support dynamic dispatch.
type IRuleFixedTypeValueSetFieldSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleFixedTypeValueSetFieldSpecContext differentiates from other interfaces.
	IsRuleFixedTypeValueSetFieldSpecContext()
}

type RuleFixedTypeValueSetFieldSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleFixedTypeValueSetFieldSpecContext() *RuleFixedTypeValueSetFieldSpecContext {
	var p = new(RuleFixedTypeValueSetFieldSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleFixedTypeValueSetFieldSpec
	return p
}

func (*RuleFixedTypeValueSetFieldSpecContext) IsRuleFixedTypeValueSetFieldSpecContext() {}

func NewRuleFixedTypeValueSetFieldSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleFixedTypeValueSetFieldSpecContext {
	var p = new(RuleFixedTypeValueSetFieldSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleFixedTypeValueSetFieldSpec

	return p
}

func (s *RuleFixedTypeValueSetFieldSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleFixedTypeValueSetFieldSpecContext) RuleValueSetFieldReference() IRuleValueSetFieldReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueSetFieldReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueSetFieldReferenceContext)
}

func (s *RuleFixedTypeValueSetFieldSpecContext) RuleType() IRuleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeContext)
}

func (s *RuleFixedTypeValueSetFieldSpecContext) RuleValueSetOptionalitySpec() IRuleValueSetOptionalitySpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueSetOptionalitySpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueSetOptionalitySpecContext)
}

func (s *RuleFixedTypeValueSetFieldSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleFixedTypeValueSetFieldSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleFixedTypeValueSetFieldSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleFixedTypeValueSetFieldSpec(s)
	}
}

func (s *RuleFixedTypeValueSetFieldSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleFixedTypeValueSetFieldSpec(s)
	}
}

func (s *RuleFixedTypeValueSetFieldSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleFixedTypeValueSetFieldSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleFixedTypeValueSetFieldSpec() (localctx IRuleFixedTypeValueSetFieldSpecContext) {
	this := p
	_ = this

	localctx = NewRuleFixedTypeValueSetFieldSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, asn1ParserRULE_ruleFixedTypeValueSetFieldSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1908)
		p.RuleValueSetFieldReference()
	}
	{
		p.SetState(1909)
		p.RuleType()
	}
	{
		p.SetState(1910)
		p.RuleValueSetOptionalitySpec()
	}

	return localctx
}

// IRuleVariableTypeValueSetFieldSpecContext is an interface to support dynamic dispatch.
type IRuleVariableTypeValueSetFieldSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleVariableTypeValueSetFieldSpecContext differentiates from other interfaces.
	IsRuleVariableTypeValueSetFieldSpecContext()
}

type RuleVariableTypeValueSetFieldSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleVariableTypeValueSetFieldSpecContext() *RuleVariableTypeValueSetFieldSpecContext {
	var p = new(RuleVariableTypeValueSetFieldSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleVariableTypeValueSetFieldSpec
	return p
}

func (*RuleVariableTypeValueSetFieldSpecContext) IsRuleVariableTypeValueSetFieldSpecContext() {}

func NewRuleVariableTypeValueSetFieldSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleVariableTypeValueSetFieldSpecContext {
	var p = new(RuleVariableTypeValueSetFieldSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleVariableTypeValueSetFieldSpec

	return p
}

func (s *RuleVariableTypeValueSetFieldSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleVariableTypeValueSetFieldSpecContext) RuleValueSetFieldReference() IRuleValueSetFieldReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueSetFieldReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueSetFieldReferenceContext)
}

func (s *RuleVariableTypeValueSetFieldSpecContext) RuleFieldName() IRuleFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleFieldNameContext)
}

func (s *RuleVariableTypeValueSetFieldSpecContext) RuleValueSetOptionalitySpec() IRuleValueSetOptionalitySpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueSetOptionalitySpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueSetOptionalitySpecContext)
}

func (s *RuleVariableTypeValueSetFieldSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleVariableTypeValueSetFieldSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleVariableTypeValueSetFieldSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleVariableTypeValueSetFieldSpec(s)
	}
}

func (s *RuleVariableTypeValueSetFieldSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleVariableTypeValueSetFieldSpec(s)
	}
}

func (s *RuleVariableTypeValueSetFieldSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleVariableTypeValueSetFieldSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleVariableTypeValueSetFieldSpec() (localctx IRuleVariableTypeValueSetFieldSpecContext) {
	this := p
	_ = this

	localctx = NewRuleVariableTypeValueSetFieldSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 448, asn1ParserRULE_ruleVariableTypeValueSetFieldSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1912)
		p.RuleValueSetFieldReference()
	}
	{
		p.SetState(1913)
		p.ruleFieldName(0)
	}
	{
		p.SetState(1914)
		p.RuleValueSetOptionalitySpec()
	}

	return localctx
}

// IRuleObjectFieldSpecContext is an interface to support dynamic dispatch.
type IRuleObjectFieldSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleObjectFieldSpecContext differentiates from other interfaces.
	IsRuleObjectFieldSpecContext()
}

type RuleObjectFieldSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleObjectFieldSpecContext() *RuleObjectFieldSpecContext {
	var p = new(RuleObjectFieldSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleObjectFieldSpec
	return p
}

func (*RuleObjectFieldSpecContext) IsRuleObjectFieldSpecContext() {}

func NewRuleObjectFieldSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleObjectFieldSpecContext {
	var p = new(RuleObjectFieldSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleObjectFieldSpec

	return p
}

func (s *RuleObjectFieldSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleObjectFieldSpecContext) RuleObjectFieldReference() IRuleObjectFieldReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectFieldReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectFieldReferenceContext)
}

func (s *RuleObjectFieldSpecContext) RuleDefinedObjectClass() IRuleDefinedObjectClassContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinedObjectClassContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinedObjectClassContext)
}

func (s *RuleObjectFieldSpecContext) RuleObjectOptionalitySpec() IRuleObjectOptionalitySpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectOptionalitySpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectOptionalitySpecContext)
}

func (s *RuleObjectFieldSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleObjectFieldSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleObjectFieldSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleObjectFieldSpec(s)
	}
}

func (s *RuleObjectFieldSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleObjectFieldSpec(s)
	}
}

func (s *RuleObjectFieldSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleObjectFieldSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleObjectFieldSpec() (localctx IRuleObjectFieldSpecContext) {
	this := p
	_ = this

	localctx = NewRuleObjectFieldSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 450, asn1ParserRULE_ruleObjectFieldSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1916)
		p.RuleObjectFieldReference()
	}
	{
		p.SetState(1917)
		p.RuleDefinedObjectClass()
	}
	{
		p.SetState(1918)
		p.RuleObjectOptionalitySpec()
	}

	return localctx
}

// IRuleObjectSetFieldSpecContext is an interface to support dynamic dispatch.
type IRuleObjectSetFieldSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleObjectSetFieldSpecContext differentiates from other interfaces.
	IsRuleObjectSetFieldSpecContext()
}

type RuleObjectSetFieldSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleObjectSetFieldSpecContext() *RuleObjectSetFieldSpecContext {
	var p = new(RuleObjectSetFieldSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleObjectSetFieldSpec
	return p
}

func (*RuleObjectSetFieldSpecContext) IsRuleObjectSetFieldSpecContext() {}

func NewRuleObjectSetFieldSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleObjectSetFieldSpecContext {
	var p = new(RuleObjectSetFieldSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleObjectSetFieldSpec

	return p
}

func (s *RuleObjectSetFieldSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleObjectSetFieldSpecContext) RuleObjectSetFieldReference() IRuleObjectSetFieldReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectSetFieldReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectSetFieldReferenceContext)
}

func (s *RuleObjectSetFieldSpecContext) RuleDefinedObjectClass() IRuleDefinedObjectClassContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinedObjectClassContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinedObjectClassContext)
}

func (s *RuleObjectSetFieldSpecContext) RuleObjectSetOptionalitySpec() IRuleObjectSetOptionalitySpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectSetOptionalitySpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectSetOptionalitySpecContext)
}

func (s *RuleObjectSetFieldSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleObjectSetFieldSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleObjectSetFieldSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleObjectSetFieldSpec(s)
	}
}

func (s *RuleObjectSetFieldSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleObjectSetFieldSpec(s)
	}
}

func (s *RuleObjectSetFieldSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleObjectSetFieldSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleObjectSetFieldSpec() (localctx IRuleObjectSetFieldSpecContext) {
	this := p
	_ = this

	localctx = NewRuleObjectSetFieldSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 452, asn1ParserRULE_ruleObjectSetFieldSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1920)
		p.RuleObjectSetFieldReference()
	}
	{
		p.SetState(1921)
		p.RuleDefinedObjectClass()
	}
	{
		p.SetState(1922)
		p.RuleObjectSetOptionalitySpec()
	}

	return localctx
}

// IRuleTypeOptionalitySpecContext is an interface to support dynamic dispatch.
type IRuleTypeOptionalitySpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleTypeOptionalitySpecContext differentiates from other interfaces.
	IsRuleTypeOptionalitySpecContext()
}

type RuleTypeOptionalitySpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleTypeOptionalitySpecContext() *RuleTypeOptionalitySpecContext {
	var p = new(RuleTypeOptionalitySpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleTypeOptionalitySpec
	return p
}

func (*RuleTypeOptionalitySpecContext) IsRuleTypeOptionalitySpecContext() {}

func NewRuleTypeOptionalitySpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleTypeOptionalitySpecContext {
	var p = new(RuleTypeOptionalitySpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleTypeOptionalitySpec

	return p
}

func (s *RuleTypeOptionalitySpecContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleTypeOptionalitySpecContext) OPTIONAL_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserOPTIONAL_SYM, 0)
}

func (s *RuleTypeOptionalitySpecContext) DEFAULT_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserDEFAULT_SYM, 0)
}

func (s *RuleTypeOptionalitySpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleTypeOptionalitySpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleTypeOptionalitySpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleTypeOptionalitySpec(s)
	}
}

func (s *RuleTypeOptionalitySpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleTypeOptionalitySpec(s)
	}
}

func (s *RuleTypeOptionalitySpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleTypeOptionalitySpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleTypeOptionalitySpec() (localctx IRuleTypeOptionalitySpecContext) {
	this := p
	_ = this

	localctx = NewRuleTypeOptionalitySpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 454, asn1ParserRULE_ruleTypeOptionalitySpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1927)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 110, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1924)
			p.Match(asn1ParserOPTIONAL_SYM)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1925)
			p.Match(asn1ParserDEFAULT_SYM)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)

	}

	return localctx
}

// IRuleValueOptionalitySpecContext is an interface to support dynamic dispatch.
type IRuleValueOptionalitySpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleValueOptionalitySpecContext differentiates from other interfaces.
	IsRuleValueOptionalitySpecContext()
}

type RuleValueOptionalitySpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleValueOptionalitySpecContext() *RuleValueOptionalitySpecContext {
	var p = new(RuleValueOptionalitySpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleValueOptionalitySpec
	return p
}

func (*RuleValueOptionalitySpecContext) IsRuleValueOptionalitySpecContext() {}

func NewRuleValueOptionalitySpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleValueOptionalitySpecContext {
	var p = new(RuleValueOptionalitySpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleValueOptionalitySpec

	return p
}

func (s *RuleValueOptionalitySpecContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleValueOptionalitySpecContext) OPTIONAL_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserOPTIONAL_SYM, 0)
}

func (s *RuleValueOptionalitySpecContext) DEFAULT_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserDEFAULT_SYM, 0)
}

func (s *RuleValueOptionalitySpecContext) RuleValue() IRuleValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueContext)
}

func (s *RuleValueOptionalitySpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleValueOptionalitySpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleValueOptionalitySpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleValueOptionalitySpec(s)
	}
}

func (s *RuleValueOptionalitySpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleValueOptionalitySpec(s)
	}
}

func (s *RuleValueOptionalitySpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleValueOptionalitySpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleValueOptionalitySpec() (localctx IRuleValueOptionalitySpecContext) {
	this := p
	_ = this

	localctx = NewRuleValueOptionalitySpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 456, asn1ParserRULE_ruleValueOptionalitySpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1933)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 111, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1929)
			p.Match(asn1ParserOPTIONAL_SYM)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1930)
			p.Match(asn1ParserDEFAULT_SYM)
		}
		{
			p.SetState(1931)
			p.RuleValue()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)

	}

	return localctx
}

// IRuleValueSetOptionalitySpecContext is an interface to support dynamic dispatch.
type IRuleValueSetOptionalitySpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleValueSetOptionalitySpecContext differentiates from other interfaces.
	IsRuleValueSetOptionalitySpecContext()
}

type RuleValueSetOptionalitySpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleValueSetOptionalitySpecContext() *RuleValueSetOptionalitySpecContext {
	var p = new(RuleValueSetOptionalitySpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleValueSetOptionalitySpec
	return p
}

func (*RuleValueSetOptionalitySpecContext) IsRuleValueSetOptionalitySpecContext() {}

func NewRuleValueSetOptionalitySpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleValueSetOptionalitySpecContext {
	var p = new(RuleValueSetOptionalitySpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleValueSetOptionalitySpec

	return p
}

func (s *RuleValueSetOptionalitySpecContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleValueSetOptionalitySpecContext) OPTIONAL_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserOPTIONAL_SYM, 0)
}

func (s *RuleValueSetOptionalitySpecContext) DEFAULT_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserDEFAULT_SYM, 0)
}

func (s *RuleValueSetOptionalitySpecContext) RuleValueSet() IRuleValueSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueSetContext)
}

func (s *RuleValueSetOptionalitySpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleValueSetOptionalitySpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleValueSetOptionalitySpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleValueSetOptionalitySpec(s)
	}
}

func (s *RuleValueSetOptionalitySpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleValueSetOptionalitySpec(s)
	}
}

func (s *RuleValueSetOptionalitySpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleValueSetOptionalitySpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleValueSetOptionalitySpec() (localctx IRuleValueSetOptionalitySpecContext) {
	this := p
	_ = this

	localctx = NewRuleValueSetOptionalitySpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 458, asn1ParserRULE_ruleValueSetOptionalitySpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1939)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 112, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1935)
			p.Match(asn1ParserOPTIONAL_SYM)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1936)
			p.Match(asn1ParserDEFAULT_SYM)
		}
		{
			p.SetState(1937)
			p.RuleValueSet()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)

	}

	return localctx
}

// IRuleObjectOptionalitySpecContext is an interface to support dynamic dispatch.
type IRuleObjectOptionalitySpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleObjectOptionalitySpecContext differentiates from other interfaces.
	IsRuleObjectOptionalitySpecContext()
}

type RuleObjectOptionalitySpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleObjectOptionalitySpecContext() *RuleObjectOptionalitySpecContext {
	var p = new(RuleObjectOptionalitySpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleObjectOptionalitySpec
	return p
}

func (*RuleObjectOptionalitySpecContext) IsRuleObjectOptionalitySpecContext() {}

func NewRuleObjectOptionalitySpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleObjectOptionalitySpecContext {
	var p = new(RuleObjectOptionalitySpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleObjectOptionalitySpec

	return p
}

func (s *RuleObjectOptionalitySpecContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleObjectOptionalitySpecContext) OPTIONAL_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserOPTIONAL_SYM, 0)
}

func (s *RuleObjectOptionalitySpecContext) DEFAULT_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserDEFAULT_SYM, 0)
}

func (s *RuleObjectOptionalitySpecContext) RuleObject() IRuleObjectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectContext)
}

func (s *RuleObjectOptionalitySpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleObjectOptionalitySpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleObjectOptionalitySpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleObjectOptionalitySpec(s)
	}
}

func (s *RuleObjectOptionalitySpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleObjectOptionalitySpec(s)
	}
}

func (s *RuleObjectOptionalitySpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleObjectOptionalitySpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleObjectOptionalitySpec() (localctx IRuleObjectOptionalitySpecContext) {
	this := p
	_ = this

	localctx = NewRuleObjectOptionalitySpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 460, asn1ParserRULE_ruleObjectOptionalitySpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1945)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 113, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1941)
			p.Match(asn1ParserOPTIONAL_SYM)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1942)
			p.Match(asn1ParserDEFAULT_SYM)
		}
		{
			p.SetState(1943)
			p.RuleObject()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)

	}

	return localctx
}

// IRuleObjectSetOptionalitySpecContext is an interface to support dynamic dispatch.
type IRuleObjectSetOptionalitySpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleObjectSetOptionalitySpecContext differentiates from other interfaces.
	IsRuleObjectSetOptionalitySpecContext()
}

type RuleObjectSetOptionalitySpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleObjectSetOptionalitySpecContext() *RuleObjectSetOptionalitySpecContext {
	var p = new(RuleObjectSetOptionalitySpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleObjectSetOptionalitySpec
	return p
}

func (*RuleObjectSetOptionalitySpecContext) IsRuleObjectSetOptionalitySpecContext() {}

func NewRuleObjectSetOptionalitySpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleObjectSetOptionalitySpecContext {
	var p = new(RuleObjectSetOptionalitySpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleObjectSetOptionalitySpec

	return p
}

func (s *RuleObjectSetOptionalitySpecContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleObjectSetOptionalitySpecContext) OPTIONAL_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserOPTIONAL_SYM, 0)
}

func (s *RuleObjectSetOptionalitySpecContext) DEFAULT_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserDEFAULT_SYM, 0)
}

func (s *RuleObjectSetOptionalitySpecContext) RuleObjectSet() IRuleObjectSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectSetContext)
}

func (s *RuleObjectSetOptionalitySpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleObjectSetOptionalitySpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleObjectSetOptionalitySpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleObjectSetOptionalitySpec(s)
	}
}

func (s *RuleObjectSetOptionalitySpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleObjectSetOptionalitySpec(s)
	}
}

func (s *RuleObjectSetOptionalitySpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleObjectSetOptionalitySpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleObjectSetOptionalitySpec() (localctx IRuleObjectSetOptionalitySpecContext) {
	this := p
	_ = this

	localctx = NewRuleObjectSetOptionalitySpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 462, asn1ParserRULE_ruleObjectSetOptionalitySpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1951)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1947)
			p.Match(asn1ParserOPTIONAL_SYM)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1948)
			p.Match(asn1ParserDEFAULT_SYM)
		}
		{
			p.SetState(1949)
			p.RuleObjectSet()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)

	}

	return localctx
}

// IRuleWithSyntaxSpecContext is an interface to support dynamic dispatch.
type IRuleWithSyntaxSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleWithSyntaxSpecContext differentiates from other interfaces.
	IsRuleWithSyntaxSpecContext()
}

type RuleWithSyntaxSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleWithSyntaxSpecContext() *RuleWithSyntaxSpecContext {
	var p = new(RuleWithSyntaxSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleWithSyntaxSpec
	return p
}

func (*RuleWithSyntaxSpecContext) IsRuleWithSyntaxSpecContext() {}

func NewRuleWithSyntaxSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleWithSyntaxSpecContext {
	var p = new(RuleWithSyntaxSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleWithSyntaxSpec

	return p
}

func (s *RuleWithSyntaxSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleWithSyntaxSpecContext) WITH_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserWITH_SYM, 0)
}

func (s *RuleWithSyntaxSpecContext) SYNTAX_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserSYNTAX_SYM, 0)
}

func (s *RuleWithSyntaxSpecContext) RuleSyntaxList() IRuleSyntaxListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSyntaxListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSyntaxListContext)
}

func (s *RuleWithSyntaxSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleWithSyntaxSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleWithSyntaxSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleWithSyntaxSpec(s)
	}
}

func (s *RuleWithSyntaxSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleWithSyntaxSpec(s)
	}
}

func (s *RuleWithSyntaxSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleWithSyntaxSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleWithSyntaxSpec() (localctx IRuleWithSyntaxSpecContext) {
	this := p
	_ = this

	localctx = NewRuleWithSyntaxSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 464, asn1ParserRULE_ruleWithSyntaxSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1953)
		p.Match(asn1ParserWITH_SYM)
	}
	{
		p.SetState(1954)
		p.Match(asn1ParserSYNTAX_SYM)
	}
	{
		p.SetState(1955)
		p.RuleSyntaxList()
	}

	return localctx
}

// IRuleSyntaxListContext is an interface to support dynamic dispatch.
type IRuleSyntaxListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleSyntaxListContext differentiates from other interfaces.
	IsRuleSyntaxListContext()
}

type RuleSyntaxListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleSyntaxListContext() *RuleSyntaxListContext {
	var p = new(RuleSyntaxListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleSyntaxList
	return p
}

func (*RuleSyntaxListContext) IsRuleSyntaxListContext() {}

func NewRuleSyntaxListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleSyntaxListContext {
	var p = new(RuleSyntaxListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleSyntaxList

	return p
}

func (s *RuleSyntaxListContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleSyntaxListContext) CURLY_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_START, 0)
}

func (s *RuleSyntaxListContext) RuleTokenOrGroupSpecList() IRuleTokenOrGroupSpecListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTokenOrGroupSpecListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTokenOrGroupSpecListContext)
}

func (s *RuleSyntaxListContext) CURLY_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_END, 0)
}

func (s *RuleSyntaxListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleSyntaxListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleSyntaxListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleSyntaxList(s)
	}
}

func (s *RuleSyntaxListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleSyntaxList(s)
	}
}

func (s *RuleSyntaxListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleSyntaxList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleSyntaxList() (localctx IRuleSyntaxListContext) {
	this := p
	_ = this

	localctx = NewRuleSyntaxListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 466, asn1ParserRULE_ruleSyntaxList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1957)
		p.Match(asn1ParserCURLY_START)
	}
	{
		p.SetState(1958)
		p.ruleTokenOrGroupSpecList(0)
	}
	{
		p.SetState(1959)
		p.Match(asn1ParserCURLY_END)
	}

	return localctx
}

// IRuleTokenOrGroupSpecListContext is an interface to support dynamic dispatch.
type IRuleTokenOrGroupSpecListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleTokenOrGroupSpecListContext differentiates from other interfaces.
	IsRuleTokenOrGroupSpecListContext()
}

type RuleTokenOrGroupSpecListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleTokenOrGroupSpecListContext() *RuleTokenOrGroupSpecListContext {
	var p = new(RuleTokenOrGroupSpecListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleTokenOrGroupSpecList
	return p
}

func (*RuleTokenOrGroupSpecListContext) IsRuleTokenOrGroupSpecListContext() {}

func NewRuleTokenOrGroupSpecListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleTokenOrGroupSpecListContext {
	var p = new(RuleTokenOrGroupSpecListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleTokenOrGroupSpecList

	return p
}

func (s *RuleTokenOrGroupSpecListContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleTokenOrGroupSpecListContext) RuleTokenOrGroupSpec() IRuleTokenOrGroupSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTokenOrGroupSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTokenOrGroupSpecContext)
}

func (s *RuleTokenOrGroupSpecListContext) RuleTokenOrGroupSpecList() IRuleTokenOrGroupSpecListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTokenOrGroupSpecListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTokenOrGroupSpecListContext)
}

func (s *RuleTokenOrGroupSpecListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleTokenOrGroupSpecListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleTokenOrGroupSpecListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleTokenOrGroupSpecList(s)
	}
}

func (s *RuleTokenOrGroupSpecListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleTokenOrGroupSpecList(s)
	}
}

func (s *RuleTokenOrGroupSpecListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleTokenOrGroupSpecList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleTokenOrGroupSpecList() (localctx IRuleTokenOrGroupSpecListContext) {
	return p.ruleTokenOrGroupSpecList(0)
}

func (p *asn1Parser) ruleTokenOrGroupSpecList(_p int) (localctx IRuleTokenOrGroupSpecListContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRuleTokenOrGroupSpecListContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRuleTokenOrGroupSpecListContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 468
	p.EnterRecursionRule(localctx, 468, asn1ParserRULE_ruleTokenOrGroupSpecList, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1964)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 115, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1962)
			p.RuleTokenOrGroupSpec()
		}

	case 2:

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(1970)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 116, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewRuleTokenOrGroupSpecListContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, asn1ParserRULE_ruleTokenOrGroupSpecList)
			p.SetState(1966)

			if !(p.Precpred(p.GetParserRuleContext(), 3)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
			}
			{
				p.SetState(1967)
				p.RuleTokenOrGroupSpec()
			}

		}
		p.SetState(1972)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 116, p.GetParserRuleContext())
	}

	return localctx
}

// IRuleTokenOrGroupSpecContext is an interface to support dynamic dispatch.
type IRuleTokenOrGroupSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleTokenOrGroupSpecContext differentiates from other interfaces.
	IsRuleTokenOrGroupSpecContext()
}

type RuleTokenOrGroupSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleTokenOrGroupSpecContext() *RuleTokenOrGroupSpecContext {
	var p = new(RuleTokenOrGroupSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleTokenOrGroupSpec
	return p
}

func (*RuleTokenOrGroupSpecContext) IsRuleTokenOrGroupSpecContext() {}

func NewRuleTokenOrGroupSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleTokenOrGroupSpecContext {
	var p = new(RuleTokenOrGroupSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleTokenOrGroupSpec

	return p
}

func (s *RuleTokenOrGroupSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleTokenOrGroupSpecContext) RuleRequiredToken() IRuleRequiredTokenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleRequiredTokenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleRequiredTokenContext)
}

func (s *RuleTokenOrGroupSpecContext) RuleOptionalGroup() IRuleOptionalGroupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleOptionalGroupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleOptionalGroupContext)
}

func (s *RuleTokenOrGroupSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleTokenOrGroupSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleTokenOrGroupSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleTokenOrGroupSpec(s)
	}
}

func (s *RuleTokenOrGroupSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleTokenOrGroupSpec(s)
	}
}

func (s *RuleTokenOrGroupSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleTokenOrGroupSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleTokenOrGroupSpec() (localctx IRuleTokenOrGroupSpecContext) {
	this := p
	_ = this

	localctx = NewRuleTokenOrGroupSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 470, asn1ParserRULE_ruleTokenOrGroupSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1975)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case asn1ParserAND, asn1ParserCOMMA, asn1ParserUCASE_ID, asn1ParserLCASE_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1973)
			p.RuleRequiredToken()
		}

	case asn1ParserSQUARE_START:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1974)
			p.RuleOptionalGroup()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRuleRequiredTokenContext is an interface to support dynamic dispatch.
type IRuleRequiredTokenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleRequiredTokenContext differentiates from other interfaces.
	IsRuleRequiredTokenContext()
}

type RuleRequiredTokenContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleRequiredTokenContext() *RuleRequiredTokenContext {
	var p = new(RuleRequiredTokenContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleRequiredToken
	return p
}

func (*RuleRequiredTokenContext) IsRuleRequiredTokenContext() {}

func NewRuleRequiredTokenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleRequiredTokenContext {
	var p = new(RuleRequiredTokenContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleRequiredToken

	return p
}

func (s *RuleRequiredTokenContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleRequiredTokenContext) RuleLiteral() IRuleLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleLiteralContext)
}

func (s *RuleRequiredTokenContext) RulePrimitiveFieldName() IRulePrimitiveFieldNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRulePrimitiveFieldNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRulePrimitiveFieldNameContext)
}

func (s *RuleRequiredTokenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleRequiredTokenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleRequiredTokenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleRequiredToken(s)
	}
}

func (s *RuleRequiredTokenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleRequiredToken(s)
	}
}

func (s *RuleRequiredTokenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleRequiredToken(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleRequiredToken() (localctx IRuleRequiredTokenContext) {
	this := p
	_ = this

	localctx = NewRuleRequiredTokenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 472, asn1ParserRULE_ruleRequiredToken)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1979)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case asn1ParserCOMMA, asn1ParserUCASE_ID, asn1ParserLCASE_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1977)
			p.RuleLiteral()
		}

	case asn1ParserAND:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1978)
			p.RulePrimitiveFieldName()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRuleOptionalGroupContext is an interface to support dynamic dispatch.
type IRuleOptionalGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleOptionalGroupContext differentiates from other interfaces.
	IsRuleOptionalGroupContext()
}

type RuleOptionalGroupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleOptionalGroupContext() *RuleOptionalGroupContext {
	var p = new(RuleOptionalGroupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleOptionalGroup
	return p
}

func (*RuleOptionalGroupContext) IsRuleOptionalGroupContext() {}

func NewRuleOptionalGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleOptionalGroupContext {
	var p = new(RuleOptionalGroupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleOptionalGroup

	return p
}

func (s *RuleOptionalGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleOptionalGroupContext) SQUARE_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserSQUARE_START, 0)
}

func (s *RuleOptionalGroupContext) RuleTokenOrGroupSpecList() IRuleTokenOrGroupSpecListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTokenOrGroupSpecListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTokenOrGroupSpecListContext)
}

func (s *RuleOptionalGroupContext) SQUARE_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserSQUARE_END, 0)
}

func (s *RuleOptionalGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleOptionalGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleOptionalGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleOptionalGroup(s)
	}
}

func (s *RuleOptionalGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleOptionalGroup(s)
	}
}

func (s *RuleOptionalGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleOptionalGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleOptionalGroup() (localctx IRuleOptionalGroupContext) {
	this := p
	_ = this

	localctx = NewRuleOptionalGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 474, asn1ParserRULE_ruleOptionalGroup)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1981)
		p.Match(asn1ParserSQUARE_START)
	}
	{
		p.SetState(1982)
		p.ruleTokenOrGroupSpecList(0)
	}
	{
		p.SetState(1983)
		p.Match(asn1ParserSQUARE_END)
	}

	return localctx
}

// IRuleParameterizedObjectClassContext is an interface to support dynamic dispatch.
type IRuleParameterizedObjectClassContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleParameterizedObjectClassContext differentiates from other interfaces.
	IsRuleParameterizedObjectClassContext()
}

type RuleParameterizedObjectClassContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleParameterizedObjectClassContext() *RuleParameterizedObjectClassContext {
	var p = new(RuleParameterizedObjectClassContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleParameterizedObjectClass
	return p
}

func (*RuleParameterizedObjectClassContext) IsRuleParameterizedObjectClassContext() {}

func NewRuleParameterizedObjectClassContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleParameterizedObjectClassContext {
	var p = new(RuleParameterizedObjectClassContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleParameterizedObjectClass

	return p
}

func (s *RuleParameterizedObjectClassContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleParameterizedObjectClassContext) RuleDefinedObjectClass() IRuleDefinedObjectClassContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinedObjectClassContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinedObjectClassContext)
}

func (s *RuleParameterizedObjectClassContext) RuleActualParameterList() IRuleActualParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleActualParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleActualParameterListContext)
}

func (s *RuleParameterizedObjectClassContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleParameterizedObjectClassContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleParameterizedObjectClassContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleParameterizedObjectClass(s)
	}
}

func (s *RuleParameterizedObjectClassContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleParameterizedObjectClass(s)
	}
}

func (s *RuleParameterizedObjectClassContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleParameterizedObjectClass(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleParameterizedObjectClass() (localctx IRuleParameterizedObjectClassContext) {
	this := p
	_ = this

	localctx = NewRuleParameterizedObjectClassContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 476, asn1ParserRULE_ruleParameterizedObjectClass)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1985)
		p.RuleDefinedObjectClass()
	}
	{
		p.SetState(1986)
		p.RuleActualParameterList()
	}

	return localctx
}

// IRuleObjectSetContext is an interface to support dynamic dispatch.
type IRuleObjectSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleObjectSetContext differentiates from other interfaces.
	IsRuleObjectSetContext()
}

type RuleObjectSetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleObjectSetContext() *RuleObjectSetContext {
	var p = new(RuleObjectSetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleObjectSet
	return p
}

func (*RuleObjectSetContext) IsRuleObjectSetContext() {}

func NewRuleObjectSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleObjectSetContext {
	var p = new(RuleObjectSetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleObjectSet

	return p
}

func (s *RuleObjectSetContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleObjectSetContext) CURLY_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_START, 0)
}

func (s *RuleObjectSetContext) RuleObjectSetSpec() IRuleObjectSetSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectSetSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectSetSpecContext)
}

func (s *RuleObjectSetContext) CURLY_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_END, 0)
}

func (s *RuleObjectSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleObjectSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleObjectSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleObjectSet(s)
	}
}

func (s *RuleObjectSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleObjectSet(s)
	}
}

func (s *RuleObjectSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleObjectSet(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleObjectSet() (localctx IRuleObjectSetContext) {
	this := p
	_ = this

	localctx = NewRuleObjectSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 478, asn1ParserRULE_ruleObjectSet)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1988)
		p.Match(asn1ParserCURLY_START)
	}
	{
		p.SetState(1989)
		p.RuleObjectSetSpec()
	}
	{
		p.SetState(1990)
		p.Match(asn1ParserCURLY_END)
	}

	return localctx
}

// IRuleObjectSetSpecContext is an interface to support dynamic dispatch.
type IRuleObjectSetSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleObjectSetSpecContext differentiates from other interfaces.
	IsRuleObjectSetSpecContext()
}

type RuleObjectSetSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleObjectSetSpecContext() *RuleObjectSetSpecContext {
	var p = new(RuleObjectSetSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleObjectSetSpec
	return p
}

func (*RuleObjectSetSpecContext) IsRuleObjectSetSpecContext() {}

func NewRuleObjectSetSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleObjectSetSpecContext {
	var p = new(RuleObjectSetSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleObjectSetSpec

	return p
}

func (s *RuleObjectSetSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleObjectSetSpecContext) RuleRootElementSetSpec() IRuleRootElementSetSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleRootElementSetSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleRootElementSetSpecContext)
}

func (s *RuleObjectSetSpecContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(asn1ParserCOMMA)
}

func (s *RuleObjectSetSpecContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(asn1ParserCOMMA, i)
}

func (s *RuleObjectSetSpecContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(asn1ParserELLIPSIS, 0)
}

func (s *RuleObjectSetSpecContext) RuleAdditionalElementSetSpec() IRuleAdditionalElementSetSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleAdditionalElementSetSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleAdditionalElementSetSpecContext)
}

func (s *RuleObjectSetSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleObjectSetSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleObjectSetSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleObjectSetSpec(s)
	}
}

func (s *RuleObjectSetSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleObjectSetSpec(s)
	}
}

func (s *RuleObjectSetSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleObjectSetSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleObjectSetSpec() (localctx IRuleObjectSetSpecContext) {
	this := p
	_ = this

	localctx = NewRuleObjectSetSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 480, asn1ParserRULE_ruleObjectSetSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2007)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 119, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1992)
			p.RuleRootElementSetSpec()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1993)
			p.RuleRootElementSetSpec()
		}
		{
			p.SetState(1994)
			p.Match(asn1ParserCOMMA)
		}
		{
			p.SetState(1995)
			p.Match(asn1ParserELLIPSIS)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1997)
			p.Match(asn1ParserELLIPSIS)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1998)
			p.Match(asn1ParserELLIPSIS)
		}
		{
			p.SetState(1999)
			p.Match(asn1ParserCOMMA)
		}
		{
			p.SetState(2000)
			p.RuleAdditionalElementSetSpec()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2001)
			p.RuleRootElementSetSpec()
		}
		{
			p.SetState(2002)
			p.Match(asn1ParserCOMMA)
		}
		{
			p.SetState(2003)
			p.Match(asn1ParserELLIPSIS)
		}
		{
			p.SetState(2004)
			p.Match(asn1ParserCOMMA)
		}
		{
			p.SetState(2005)
			p.RuleAdditionalElementSetSpec()
		}

	}

	return localctx
}

// IRuleRootElementSetSpecContext is an interface to support dynamic dispatch.
type IRuleRootElementSetSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleRootElementSetSpecContext differentiates from other interfaces.
	IsRuleRootElementSetSpecContext()
}

type RuleRootElementSetSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleRootElementSetSpecContext() *RuleRootElementSetSpecContext {
	var p = new(RuleRootElementSetSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleRootElementSetSpec
	return p
}

func (*RuleRootElementSetSpecContext) IsRuleRootElementSetSpecContext() {}

func NewRuleRootElementSetSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleRootElementSetSpecContext {
	var p = new(RuleRootElementSetSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleRootElementSetSpec

	return p
}

func (s *RuleRootElementSetSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleRootElementSetSpecContext) RuleElementSetSpec() IRuleElementSetSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleElementSetSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleElementSetSpecContext)
}

func (s *RuleRootElementSetSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleRootElementSetSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleRootElementSetSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleRootElementSetSpec(s)
	}
}

func (s *RuleRootElementSetSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleRootElementSetSpec(s)
	}
}

func (s *RuleRootElementSetSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleRootElementSetSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleRootElementSetSpec() (localctx IRuleRootElementSetSpecContext) {
	this := p
	_ = this

	localctx = NewRuleRootElementSetSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 482, asn1ParserRULE_ruleRootElementSetSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2009)
		p.RuleElementSetSpec()
	}

	return localctx
}

// IRuleAdditionalElementSetSpecContext is an interface to support dynamic dispatch.
type IRuleAdditionalElementSetSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleAdditionalElementSetSpecContext differentiates from other interfaces.
	IsRuleAdditionalElementSetSpecContext()
}

type RuleAdditionalElementSetSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleAdditionalElementSetSpecContext() *RuleAdditionalElementSetSpecContext {
	var p = new(RuleAdditionalElementSetSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleAdditionalElementSetSpec
	return p
}

func (*RuleAdditionalElementSetSpecContext) IsRuleAdditionalElementSetSpecContext() {}

func NewRuleAdditionalElementSetSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleAdditionalElementSetSpecContext {
	var p = new(RuleAdditionalElementSetSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleAdditionalElementSetSpec

	return p
}

func (s *RuleAdditionalElementSetSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleAdditionalElementSetSpecContext) RuleElementSetSpec() IRuleElementSetSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleElementSetSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleElementSetSpecContext)
}

func (s *RuleAdditionalElementSetSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleAdditionalElementSetSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleAdditionalElementSetSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleAdditionalElementSetSpec(s)
	}
}

func (s *RuleAdditionalElementSetSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleAdditionalElementSetSpec(s)
	}
}

func (s *RuleAdditionalElementSetSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleAdditionalElementSetSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleAdditionalElementSetSpec() (localctx IRuleAdditionalElementSetSpecContext) {
	this := p
	_ = this

	localctx = NewRuleAdditionalElementSetSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 484, asn1ParserRULE_ruleAdditionalElementSetSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2011)
		p.RuleElementSetSpec()
	}

	return localctx
}

// IRuleElementSetSpecsContext is an interface to support dynamic dispatch.
type IRuleElementSetSpecsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleElementSetSpecsContext differentiates from other interfaces.
	IsRuleElementSetSpecsContext()
}

type RuleElementSetSpecsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleElementSetSpecsContext() *RuleElementSetSpecsContext {
	var p = new(RuleElementSetSpecsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleElementSetSpecs
	return p
}

func (*RuleElementSetSpecsContext) IsRuleElementSetSpecsContext() {}

func NewRuleElementSetSpecsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleElementSetSpecsContext {
	var p = new(RuleElementSetSpecsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleElementSetSpecs

	return p
}

func (s *RuleElementSetSpecsContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleElementSetSpecsContext) RuleRootElementSetSpec() IRuleRootElementSetSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleRootElementSetSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleRootElementSetSpecContext)
}

func (s *RuleElementSetSpecsContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(asn1ParserCOMMA)
}

func (s *RuleElementSetSpecsContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(asn1ParserCOMMA, i)
}

func (s *RuleElementSetSpecsContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(asn1ParserELLIPSIS, 0)
}

func (s *RuleElementSetSpecsContext) RuleAdditionalElementSetSpec() IRuleAdditionalElementSetSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleAdditionalElementSetSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleAdditionalElementSetSpecContext)
}

func (s *RuleElementSetSpecsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleElementSetSpecsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleElementSetSpecsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleElementSetSpecs(s)
	}
}

func (s *RuleElementSetSpecsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleElementSetSpecs(s)
	}
}

func (s *RuleElementSetSpecsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleElementSetSpecs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleElementSetSpecs() (localctx IRuleElementSetSpecsContext) {
	this := p
	_ = this

	localctx = NewRuleElementSetSpecsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 486, asn1ParserRULE_ruleElementSetSpecs)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2024)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 120, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2013)
			p.RuleRootElementSetSpec()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2014)
			p.RuleRootElementSetSpec()
		}
		{
			p.SetState(2015)
			p.Match(asn1ParserCOMMA)
		}
		{
			p.SetState(2016)
			p.Match(asn1ParserELLIPSIS)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2018)
			p.RuleRootElementSetSpec()
		}
		{
			p.SetState(2019)
			p.Match(asn1ParserCOMMA)
		}
		{
			p.SetState(2020)
			p.Match(asn1ParserELLIPSIS)
		}
		{
			p.SetState(2021)
			p.Match(asn1ParserCOMMA)
		}
		{
			p.SetState(2022)
			p.RuleAdditionalElementSetSpec()
		}

	}

	return localctx
}

// IRuleElementSetSpecContext is an interface to support dynamic dispatch.
type IRuleElementSetSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleElementSetSpecContext differentiates from other interfaces.
	IsRuleElementSetSpecContext()
}

type RuleElementSetSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleElementSetSpecContext() *RuleElementSetSpecContext {
	var p = new(RuleElementSetSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleElementSetSpec
	return p
}

func (*RuleElementSetSpecContext) IsRuleElementSetSpecContext() {}

func NewRuleElementSetSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleElementSetSpecContext {
	var p = new(RuleElementSetSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleElementSetSpec

	return p
}

func (s *RuleElementSetSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleElementSetSpecContext) RuleUnions() IRuleUnionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleUnionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleUnionsContext)
}

func (s *RuleElementSetSpecContext) ALL_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserALL_SYM, 0)
}

func (s *RuleElementSetSpecContext) RuleExclusions() IRuleExclusionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleExclusionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleExclusionsContext)
}

func (s *RuleElementSetSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleElementSetSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleElementSetSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleElementSetSpec(s)
	}
}

func (s *RuleElementSetSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleElementSetSpec(s)
	}
}

func (s *RuleElementSetSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleElementSetSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleElementSetSpec() (localctx IRuleElementSetSpecContext) {
	this := p
	_ = this

	localctx = NewRuleElementSetSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 488, asn1ParserRULE_ruleElementSetSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2029)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case asn1ParserABSTRACT_SYNTAX_SYM, asn1ParserBIT_SYM, asn1ParserBMP_STRING_SYM, asn1ParserBOOLEAN_SYM, asn1ParserCHARACTER_SYM, asn1ParserCHOICE_SYM, asn1ParserCONTAINING_SYM, asn1ParserDATE_SYM, asn1ParserDATE_TIME_SYM, asn1ParserDURATION_SYM, asn1ParserEMBEDDED_SYM, asn1ParserENUMERATED_SYM, asn1ParserEXTERNAL_SYM, asn1ParserFALSE_SYM, asn1ParserFROM_SYM, asn1ParserGENERALIZED_TIME_SYM, asn1ParserGENERAL_STRING_SYM, asn1ParserGRAPHIC_STRING_SYM, asn1ParserIA5_STRING_SYM, asn1ParserINCLUDES_SYM, asn1ParserINSTANCE_SYM, asn1ParserINTEGER_SYM, asn1ParserISO646_STRING_SYM, asn1ParserMIN_SYM, asn1ParserMINUS_INFINITY_SYM, asn1ParserNOT_A_NUMBER_SYM, asn1ParserNULL_SYM, asn1ParserNUMERIC_STRING_SYM, asn1ParserOBJECT_SYM, asn1ParserOCTET_SYM, asn1ParserOID_IRI_SYM, asn1ParserPATTERN_SYM, asn1ParserPLUS_INFINITY_SYM, asn1ParserPRINTABLE_STRING_SYM, asn1ParserREAL_SYM, asn1ParserRELATIVE_OID_SYM, asn1ParserRELATIVE_OID_IRI_SYM, asn1ParserSEQUENCE_SYM, asn1ParserSET_SYM, asn1ParserSETTINGS_SYM, asn1ParserSIZE_SYM, asn1ParserT61_STRING_SYM, asn1ParserTELETEX_STRING_SYM, asn1ParserTIME_SYM, asn1ParserTIME_OF_DAY_SYM, asn1ParserTRUE_SYM, asn1ParserTYPE_IDENTIFIER_SYM, asn1ParserUNIVERSAL_STRING_SYM, asn1ParserUTC_TIME_SYM, asn1ParserUTF8_STRING_SYM, asn1ParserVIDEOTEX_STRING_SYM, asn1ParserVISIBLE_STRING_SYM, asn1ParserWITH_SYM, asn1ParserCURLY_START, asn1ParserROUND_START, asn1ParserMINUS, asn1ParserFLOAT, asn1ParserNUMBER, asn1ParserHEX_STRING, asn1ParserBIN_STRING, asn1ParserCHAR_STRING, asn1ParserUCASE_ID, asn1ParserLCASE_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2026)
			p.ruleUnions(0)
		}

	case asn1ParserALL_SYM:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2027)
			p.Match(asn1ParserALL_SYM)
		}
		{
			p.SetState(2028)
			p.RuleExclusions()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRuleUnionsContext is an interface to support dynamic dispatch.
type IRuleUnionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleUnionsContext differentiates from other interfaces.
	IsRuleUnionsContext()
}

type RuleUnionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleUnionsContext() *RuleUnionsContext {
	var p = new(RuleUnionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleUnions
	return p
}

func (*RuleUnionsContext) IsRuleUnionsContext() {}

func NewRuleUnionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleUnionsContext {
	var p = new(RuleUnionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleUnions

	return p
}

func (s *RuleUnionsContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleUnionsContext) RuleIntersections() IRuleIntersectionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleIntersectionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleIntersectionsContext)
}

func (s *RuleUnionsContext) RuleUnions() IRuleUnionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleUnionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleUnionsContext)
}

func (s *RuleUnionsContext) RuleUnionMark() IRuleUnionMarkContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleUnionMarkContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleUnionMarkContext)
}

func (s *RuleUnionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleUnionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleUnionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleUnions(s)
	}
}

func (s *RuleUnionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleUnions(s)
	}
}

func (s *RuleUnionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleUnions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleUnions() (localctx IRuleUnionsContext) {
	return p.ruleUnions(0)
}

func (p *asn1Parser) ruleUnions(_p int) (localctx IRuleUnionsContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRuleUnionsContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRuleUnionsContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 490
	p.EnterRecursionRule(localctx, 490, asn1ParserRULE_ruleUnions, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2032)
		p.ruleIntersections(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2040)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewRuleUnionsContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, asn1ParserRULE_ruleUnions)
			p.SetState(2034)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(2035)
				p.RuleUnionMark()
			}
			{
				p.SetState(2036)
				p.ruleIntersections(0)
			}

		}
		p.SetState(2042)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext())
	}

	return localctx
}

// IRuleExclusionsContext is an interface to support dynamic dispatch.
type IRuleExclusionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleExclusionsContext differentiates from other interfaces.
	IsRuleExclusionsContext()
}

type RuleExclusionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleExclusionsContext() *RuleExclusionsContext {
	var p = new(RuleExclusionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleExclusions
	return p
}

func (*RuleExclusionsContext) IsRuleExclusionsContext() {}

func NewRuleExclusionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleExclusionsContext {
	var p = new(RuleExclusionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleExclusions

	return p
}

func (s *RuleExclusionsContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleExclusionsContext) EXCEPT_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserEXCEPT_SYM, 0)
}

func (s *RuleExclusionsContext) RuleElements() IRuleElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleElementsContext)
}

func (s *RuleExclusionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleExclusionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleExclusionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleExclusions(s)
	}
}

func (s *RuleExclusionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleExclusions(s)
	}
}

func (s *RuleExclusionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleExclusions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleExclusions() (localctx IRuleExclusionsContext) {
	this := p
	_ = this

	localctx = NewRuleExclusionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 492, asn1ParserRULE_ruleExclusions)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2043)
		p.Match(asn1ParserEXCEPT_SYM)
	}
	{
		p.SetState(2044)
		p.RuleElements()
	}

	return localctx
}

// IRuleIntersectionsContext is an interface to support dynamic dispatch.
type IRuleIntersectionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleIntersectionsContext differentiates from other interfaces.
	IsRuleIntersectionsContext()
}

type RuleIntersectionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleIntersectionsContext() *RuleIntersectionsContext {
	var p = new(RuleIntersectionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleIntersections
	return p
}

func (*RuleIntersectionsContext) IsRuleIntersectionsContext() {}

func NewRuleIntersectionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleIntersectionsContext {
	var p = new(RuleIntersectionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleIntersections

	return p
}

func (s *RuleIntersectionsContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleIntersectionsContext) RuleIntersectionElements() IRuleIntersectionElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleIntersectionElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleIntersectionElementsContext)
}

func (s *RuleIntersectionsContext) RuleIntersections() IRuleIntersectionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleIntersectionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleIntersectionsContext)
}

func (s *RuleIntersectionsContext) RuleIntersectionMark() IRuleIntersectionMarkContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleIntersectionMarkContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleIntersectionMarkContext)
}

func (s *RuleIntersectionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleIntersectionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleIntersectionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleIntersections(s)
	}
}

func (s *RuleIntersectionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleIntersections(s)
	}
}

func (s *RuleIntersectionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleIntersections(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleIntersections() (localctx IRuleIntersectionsContext) {
	return p.ruleIntersections(0)
}

func (p *asn1Parser) ruleIntersections(_p int) (localctx IRuleIntersectionsContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRuleIntersectionsContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRuleIntersectionsContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 494
	p.EnterRecursionRule(localctx, 494, asn1ParserRULE_ruleIntersections, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2047)
		p.RuleIntersectionElements()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2055)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 123, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewRuleIntersectionsContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, asn1ParserRULE_ruleIntersections)
			p.SetState(2049)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			{
				p.SetState(2050)
				p.RuleIntersectionMark()
			}
			{
				p.SetState(2051)
				p.RuleIntersectionElements()
			}

		}
		p.SetState(2057)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 123, p.GetParserRuleContext())
	}

	return localctx
}

// IRuleUElemsContext is an interface to support dynamic dispatch.
type IRuleUElemsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleUElemsContext differentiates from other interfaces.
	IsRuleUElemsContext()
}

type RuleUElemsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleUElemsContext() *RuleUElemsContext {
	var p = new(RuleUElemsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleUElems
	return p
}

func (*RuleUElemsContext) IsRuleUElemsContext() {}

func NewRuleUElemsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleUElemsContext {
	var p = new(RuleUElemsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleUElems

	return p
}

func (s *RuleUElemsContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleUElemsContext) RuleUnions() IRuleUnionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleUnionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleUnionsContext)
}

func (s *RuleUElemsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleUElemsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleUElemsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleUElems(s)
	}
}

func (s *RuleUElemsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleUElems(s)
	}
}

func (s *RuleUElemsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleUElems(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleUElems() (localctx IRuleUElemsContext) {
	this := p
	_ = this

	localctx = NewRuleUElemsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 496, asn1ParserRULE_ruleUElems)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2058)
		p.ruleUnions(0)
	}

	return localctx
}

// IRuleUnionMarkContext is an interface to support dynamic dispatch.
type IRuleUnionMarkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleUnionMarkContext differentiates from other interfaces.
	IsRuleUnionMarkContext()
}

type RuleUnionMarkContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleUnionMarkContext() *RuleUnionMarkContext {
	var p = new(RuleUnionMarkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleUnionMark
	return p
}

func (*RuleUnionMarkContext) IsRuleUnionMarkContext() {}

func NewRuleUnionMarkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleUnionMarkContext {
	var p = new(RuleUnionMarkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleUnionMark

	return p
}

func (s *RuleUnionMarkContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleUnionMarkContext) PIPE() antlr.TerminalNode {
	return s.GetToken(asn1ParserPIPE, 0)
}

func (s *RuleUnionMarkContext) UNION_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserUNION_SYM, 0)
}

func (s *RuleUnionMarkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleUnionMarkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleUnionMarkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleUnionMark(s)
	}
}

func (s *RuleUnionMarkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleUnionMark(s)
	}
}

func (s *RuleUnionMarkContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleUnionMark(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleUnionMark() (localctx IRuleUnionMarkContext) {
	this := p
	_ = this

	localctx = NewRuleUnionMarkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 498, asn1ParserRULE_ruleUnionMark)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2060)
		_la = p.GetTokenStream().LA(1)

		if !(_la == asn1ParserUNION_SYM || _la == asn1ParserPIPE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IRuleLowerEndValueContext is an interface to support dynamic dispatch.
type IRuleLowerEndValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleLowerEndValueContext differentiates from other interfaces.
	IsRuleLowerEndValueContext()
}

type RuleLowerEndValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleLowerEndValueContext() *RuleLowerEndValueContext {
	var p = new(RuleLowerEndValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleLowerEndValue
	return p
}

func (*RuleLowerEndValueContext) IsRuleLowerEndValueContext() {}

func NewRuleLowerEndValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleLowerEndValueContext {
	var p = new(RuleLowerEndValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleLowerEndValue

	return p
}

func (s *RuleLowerEndValueContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleLowerEndValueContext) RuleValue() IRuleValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueContext)
}

func (s *RuleLowerEndValueContext) MIN_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserMIN_SYM, 0)
}

func (s *RuleLowerEndValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleLowerEndValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleLowerEndValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleLowerEndValue(s)
	}
}

func (s *RuleLowerEndValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleLowerEndValue(s)
	}
}

func (s *RuleLowerEndValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleLowerEndValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleLowerEndValue() (localctx IRuleLowerEndValueContext) {
	this := p
	_ = this

	localctx = NewRuleLowerEndValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 500, asn1ParserRULE_ruleLowerEndValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2064)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case asn1ParserABSTRACT_SYNTAX_SYM, asn1ParserBIT_SYM, asn1ParserBMP_STRING_SYM, asn1ParserBOOLEAN_SYM, asn1ParserCHARACTER_SYM, asn1ParserCHOICE_SYM, asn1ParserCONTAINING_SYM, asn1ParserDATE_SYM, asn1ParserDATE_TIME_SYM, asn1ParserDURATION_SYM, asn1ParserEMBEDDED_SYM, asn1ParserENUMERATED_SYM, asn1ParserEXTERNAL_SYM, asn1ParserFALSE_SYM, asn1ParserGENERALIZED_TIME_SYM, asn1ParserGENERAL_STRING_SYM, asn1ParserGRAPHIC_STRING_SYM, asn1ParserIA5_STRING_SYM, asn1ParserINSTANCE_SYM, asn1ParserINTEGER_SYM, asn1ParserISO646_STRING_SYM, asn1ParserMINUS_INFINITY_SYM, asn1ParserNOT_A_NUMBER_SYM, asn1ParserNULL_SYM, asn1ParserNUMERIC_STRING_SYM, asn1ParserOBJECT_SYM, asn1ParserOCTET_SYM, asn1ParserOID_IRI_SYM, asn1ParserPLUS_INFINITY_SYM, asn1ParserPRINTABLE_STRING_SYM, asn1ParserREAL_SYM, asn1ParserRELATIVE_OID_SYM, asn1ParserRELATIVE_OID_IRI_SYM, asn1ParserSEQUENCE_SYM, asn1ParserSET_SYM, asn1ParserT61_STRING_SYM, asn1ParserTELETEX_STRING_SYM, asn1ParserTIME_SYM, asn1ParserTIME_OF_DAY_SYM, asn1ParserTRUE_SYM, asn1ParserTYPE_IDENTIFIER_SYM, asn1ParserUNIVERSAL_STRING_SYM, asn1ParserUTC_TIME_SYM, asn1ParserUTF8_STRING_SYM, asn1ParserVIDEOTEX_STRING_SYM, asn1ParserVISIBLE_STRING_SYM, asn1ParserCURLY_START, asn1ParserMINUS, asn1ParserFLOAT, asn1ParserNUMBER, asn1ParserHEX_STRING, asn1ParserBIN_STRING, asn1ParserCHAR_STRING, asn1ParserUCASE_ID, asn1ParserLCASE_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2062)
			p.RuleValue()
		}

	case asn1ParserMIN_SYM:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2063)
			p.Match(asn1ParserMIN_SYM)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRuleUpperEndValueContext is an interface to support dynamic dispatch.
type IRuleUpperEndValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleUpperEndValueContext differentiates from other interfaces.
	IsRuleUpperEndValueContext()
}

type RuleUpperEndValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleUpperEndValueContext() *RuleUpperEndValueContext {
	var p = new(RuleUpperEndValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleUpperEndValue
	return p
}

func (*RuleUpperEndValueContext) IsRuleUpperEndValueContext() {}

func NewRuleUpperEndValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleUpperEndValueContext {
	var p = new(RuleUpperEndValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleUpperEndValue

	return p
}

func (s *RuleUpperEndValueContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleUpperEndValueContext) RuleValue() IRuleValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueContext)
}

func (s *RuleUpperEndValueContext) MAX_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserMAX_SYM, 0)
}

func (s *RuleUpperEndValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleUpperEndValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleUpperEndValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleUpperEndValue(s)
	}
}

func (s *RuleUpperEndValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleUpperEndValue(s)
	}
}

func (s *RuleUpperEndValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleUpperEndValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleUpperEndValue() (localctx IRuleUpperEndValueContext) {
	this := p
	_ = this

	localctx = NewRuleUpperEndValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 502, asn1ParserRULE_ruleUpperEndValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2068)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case asn1ParserABSTRACT_SYNTAX_SYM, asn1ParserBIT_SYM, asn1ParserBMP_STRING_SYM, asn1ParserBOOLEAN_SYM, asn1ParserCHARACTER_SYM, asn1ParserCHOICE_SYM, asn1ParserCONTAINING_SYM, asn1ParserDATE_SYM, asn1ParserDATE_TIME_SYM, asn1ParserDURATION_SYM, asn1ParserEMBEDDED_SYM, asn1ParserENUMERATED_SYM, asn1ParserEXTERNAL_SYM, asn1ParserFALSE_SYM, asn1ParserGENERALIZED_TIME_SYM, asn1ParserGENERAL_STRING_SYM, asn1ParserGRAPHIC_STRING_SYM, asn1ParserIA5_STRING_SYM, asn1ParserINSTANCE_SYM, asn1ParserINTEGER_SYM, asn1ParserISO646_STRING_SYM, asn1ParserMINUS_INFINITY_SYM, asn1ParserNOT_A_NUMBER_SYM, asn1ParserNULL_SYM, asn1ParserNUMERIC_STRING_SYM, asn1ParserOBJECT_SYM, asn1ParserOCTET_SYM, asn1ParserOID_IRI_SYM, asn1ParserPLUS_INFINITY_SYM, asn1ParserPRINTABLE_STRING_SYM, asn1ParserREAL_SYM, asn1ParserRELATIVE_OID_SYM, asn1ParserRELATIVE_OID_IRI_SYM, asn1ParserSEQUENCE_SYM, asn1ParserSET_SYM, asn1ParserT61_STRING_SYM, asn1ParserTELETEX_STRING_SYM, asn1ParserTIME_SYM, asn1ParserTIME_OF_DAY_SYM, asn1ParserTRUE_SYM, asn1ParserTYPE_IDENTIFIER_SYM, asn1ParserUNIVERSAL_STRING_SYM, asn1ParserUTC_TIME_SYM, asn1ParserUTF8_STRING_SYM, asn1ParserVIDEOTEX_STRING_SYM, asn1ParserVISIBLE_STRING_SYM, asn1ParserCURLY_START, asn1ParserMINUS, asn1ParserFLOAT, asn1ParserNUMBER, asn1ParserHEX_STRING, asn1ParserBIN_STRING, asn1ParserCHAR_STRING, asn1ParserUCASE_ID, asn1ParserLCASE_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2066)
			p.RuleValue()
		}

	case asn1ParserMAX_SYM:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2067)
			p.Match(asn1ParserMAX_SYM)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRuleIncludesContext is an interface to support dynamic dispatch.
type IRuleIncludesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleIncludesContext differentiates from other interfaces.
	IsRuleIncludesContext()
}

type RuleIncludesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleIncludesContext() *RuleIncludesContext {
	var p = new(RuleIncludesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleIncludes
	return p
}

func (*RuleIncludesContext) IsRuleIncludesContext() {}

func NewRuleIncludesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleIncludesContext {
	var p = new(RuleIncludesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleIncludes

	return p
}

func (s *RuleIncludesContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleIncludesContext) INCLUDES_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserINCLUDES_SYM, 0)
}

func (s *RuleIncludesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleIncludesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleIncludesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleIncludes(s)
	}
}

func (s *RuleIncludesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleIncludes(s)
	}
}

func (s *RuleIncludesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleIncludes(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleIncludes() (localctx IRuleIncludesContext) {
	this := p
	_ = this

	localctx = NewRuleIncludesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 504, asn1ParserRULE_ruleIncludes)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2072)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case asn1ParserINCLUDES_SYM:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2070)
			p.Match(asn1ParserINCLUDES_SYM)
		}

	case asn1ParserABSTRACT_SYNTAX_SYM, asn1ParserBIT_SYM, asn1ParserBMP_STRING_SYM, asn1ParserBOOLEAN_SYM, asn1ParserCHARACTER_SYM, asn1ParserCHOICE_SYM, asn1ParserDATE_SYM, asn1ParserDATE_TIME_SYM, asn1ParserDURATION_SYM, asn1ParserEMBEDDED_SYM, asn1ParserENUMERATED_SYM, asn1ParserEXTERNAL_SYM, asn1ParserGENERALIZED_TIME_SYM, asn1ParserGENERAL_STRING_SYM, asn1ParserGRAPHIC_STRING_SYM, asn1ParserIA5_STRING_SYM, asn1ParserINSTANCE_SYM, asn1ParserINTEGER_SYM, asn1ParserISO646_STRING_SYM, asn1ParserNULL_SYM, asn1ParserNUMERIC_STRING_SYM, asn1ParserOBJECT_SYM, asn1ParserOCTET_SYM, asn1ParserOID_IRI_SYM, asn1ParserPRINTABLE_STRING_SYM, asn1ParserREAL_SYM, asn1ParserRELATIVE_OID_SYM, asn1ParserRELATIVE_OID_IRI_SYM, asn1ParserSEQUENCE_SYM, asn1ParserSET_SYM, asn1ParserT61_STRING_SYM, asn1ParserTELETEX_STRING_SYM, asn1ParserTIME_SYM, asn1ParserTIME_OF_DAY_SYM, asn1ParserTYPE_IDENTIFIER_SYM, asn1ParserUNIVERSAL_STRING_SYM, asn1ParserUTC_TIME_SYM, asn1ParserUTF8_STRING_SYM, asn1ParserVIDEOTEX_STRING_SYM, asn1ParserVISIBLE_STRING_SYM, asn1ParserUCASE_ID, asn1ParserLCASE_ID:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRuleLowerEndpointContext is an interface to support dynamic dispatch.
type IRuleLowerEndpointContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleLowerEndpointContext differentiates from other interfaces.
	IsRuleLowerEndpointContext()
}

type RuleLowerEndpointContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleLowerEndpointContext() *RuleLowerEndpointContext {
	var p = new(RuleLowerEndpointContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleLowerEndpoint
	return p
}

func (*RuleLowerEndpointContext) IsRuleLowerEndpointContext() {}

func NewRuleLowerEndpointContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleLowerEndpointContext {
	var p = new(RuleLowerEndpointContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleLowerEndpoint

	return p
}

func (s *RuleLowerEndpointContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleLowerEndpointContext) RuleLowerEndValue() IRuleLowerEndValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleLowerEndValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleLowerEndValueContext)
}

func (s *RuleLowerEndpointContext) LESS() antlr.TerminalNode {
	return s.GetToken(asn1ParserLESS, 0)
}

func (s *RuleLowerEndpointContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleLowerEndpointContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleLowerEndpointContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleLowerEndpoint(s)
	}
}

func (s *RuleLowerEndpointContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleLowerEndpoint(s)
	}
}

func (s *RuleLowerEndpointContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleLowerEndpoint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleLowerEndpoint() (localctx IRuleLowerEndpointContext) {
	this := p
	_ = this

	localctx = NewRuleLowerEndpointContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 506, asn1ParserRULE_ruleLowerEndpoint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2078)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 127, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2074)
			p.RuleLowerEndValue()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2075)
			p.RuleLowerEndValue()
		}
		{
			p.SetState(2076)
			p.Match(asn1ParserLESS)
		}

	}

	return localctx
}

// IRuleUpperEndpointContext is an interface to support dynamic dispatch.
type IRuleUpperEndpointContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleUpperEndpointContext differentiates from other interfaces.
	IsRuleUpperEndpointContext()
}

type RuleUpperEndpointContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleUpperEndpointContext() *RuleUpperEndpointContext {
	var p = new(RuleUpperEndpointContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleUpperEndpoint
	return p
}

func (*RuleUpperEndpointContext) IsRuleUpperEndpointContext() {}

func NewRuleUpperEndpointContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleUpperEndpointContext {
	var p = new(RuleUpperEndpointContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleUpperEndpoint

	return p
}

func (s *RuleUpperEndpointContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleUpperEndpointContext) RuleUpperEndValue() IRuleUpperEndValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleUpperEndValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleUpperEndValueContext)
}

func (s *RuleUpperEndpointContext) LESS() antlr.TerminalNode {
	return s.GetToken(asn1ParserLESS, 0)
}

func (s *RuleUpperEndpointContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleUpperEndpointContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleUpperEndpointContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleUpperEndpoint(s)
	}
}

func (s *RuleUpperEndpointContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleUpperEndpoint(s)
	}
}

func (s *RuleUpperEndpointContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleUpperEndpoint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleUpperEndpoint() (localctx IRuleUpperEndpointContext) {
	this := p
	_ = this

	localctx = NewRuleUpperEndpointContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 508, asn1ParserRULE_ruleUpperEndpoint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2083)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case asn1ParserABSTRACT_SYNTAX_SYM, asn1ParserBIT_SYM, asn1ParserBMP_STRING_SYM, asn1ParserBOOLEAN_SYM, asn1ParserCHARACTER_SYM, asn1ParserCHOICE_SYM, asn1ParserCONTAINING_SYM, asn1ParserDATE_SYM, asn1ParserDATE_TIME_SYM, asn1ParserDURATION_SYM, asn1ParserEMBEDDED_SYM, asn1ParserENUMERATED_SYM, asn1ParserEXTERNAL_SYM, asn1ParserFALSE_SYM, asn1ParserGENERALIZED_TIME_SYM, asn1ParserGENERAL_STRING_SYM, asn1ParserGRAPHIC_STRING_SYM, asn1ParserIA5_STRING_SYM, asn1ParserINSTANCE_SYM, asn1ParserINTEGER_SYM, asn1ParserISO646_STRING_SYM, asn1ParserMAX_SYM, asn1ParserMINUS_INFINITY_SYM, asn1ParserNOT_A_NUMBER_SYM, asn1ParserNULL_SYM, asn1ParserNUMERIC_STRING_SYM, asn1ParserOBJECT_SYM, asn1ParserOCTET_SYM, asn1ParserOID_IRI_SYM, asn1ParserPLUS_INFINITY_SYM, asn1ParserPRINTABLE_STRING_SYM, asn1ParserREAL_SYM, asn1ParserRELATIVE_OID_SYM, asn1ParserRELATIVE_OID_IRI_SYM, asn1ParserSEQUENCE_SYM, asn1ParserSET_SYM, asn1ParserT61_STRING_SYM, asn1ParserTELETEX_STRING_SYM, asn1ParserTIME_SYM, asn1ParserTIME_OF_DAY_SYM, asn1ParserTRUE_SYM, asn1ParserTYPE_IDENTIFIER_SYM, asn1ParserUNIVERSAL_STRING_SYM, asn1ParserUTC_TIME_SYM, asn1ParserUTF8_STRING_SYM, asn1ParserVIDEOTEX_STRING_SYM, asn1ParserVISIBLE_STRING_SYM, asn1ParserCURLY_START, asn1ParserMINUS, asn1ParserFLOAT, asn1ParserNUMBER, asn1ParserHEX_STRING, asn1ParserBIN_STRING, asn1ParserCHAR_STRING, asn1ParserUCASE_ID, asn1ParserLCASE_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2080)
			p.RuleUpperEndValue()
		}

	case asn1ParserLESS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2081)
			p.Match(asn1ParserLESS)
		}
		{
			p.SetState(2082)
			p.RuleUpperEndValue()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRuleLevelContext is an interface to support dynamic dispatch.
type IRuleLevelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleLevelContext differentiates from other interfaces.
	IsRuleLevelContext()
}

type RuleLevelContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleLevelContext() *RuleLevelContext {
	var p = new(RuleLevelContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleLevel
	return p
}

func (*RuleLevelContext) IsRuleLevelContext() {}

func NewRuleLevelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleLevelContext {
	var p = new(RuleLevelContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleLevel

	return p
}

func (s *RuleLevelContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleLevelContext) DOT() antlr.TerminalNode {
	return s.GetToken(asn1ParserDOT, 0)
}

func (s *RuleLevelContext) RuleLevel() IRuleLevelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleLevelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleLevelContext)
}

func (s *RuleLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleLevelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleLevel(s)
	}
}

func (s *RuleLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleLevel(s)
	}
}

func (s *RuleLevelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleLevel(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleLevel() (localctx IRuleLevelContext) {
	this := p
	_ = this

	localctx = NewRuleLevelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 510, asn1ParserRULE_ruleLevel)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2088)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case asn1ParserDOT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2085)
			p.Match(asn1ParserDOT)
		}
		{
			p.SetState(2086)
			p.RuleLevel()
		}

	case asn1ParserLCASE_ID:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRuleComponentIdListContext is an interface to support dynamic dispatch.
type IRuleComponentIdListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleComponentIdListContext differentiates from other interfaces.
	IsRuleComponentIdListContext()
}

type RuleComponentIdListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleComponentIdListContext() *RuleComponentIdListContext {
	var p = new(RuleComponentIdListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleComponentIdList
	return p
}

func (*RuleComponentIdListContext) IsRuleComponentIdListContext() {}

func NewRuleComponentIdListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleComponentIdListContext {
	var p = new(RuleComponentIdListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleComponentIdList

	return p
}

func (s *RuleComponentIdListContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleComponentIdListContext) RuleIdentifier() IRuleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleIdentifierContext)
}

func (s *RuleComponentIdListContext) RuleComponentIdList() IRuleComponentIdListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleComponentIdListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleComponentIdListContext)
}

func (s *RuleComponentIdListContext) DOT() antlr.TerminalNode {
	return s.GetToken(asn1ParserDOT, 0)
}

func (s *RuleComponentIdListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleComponentIdListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleComponentIdListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleComponentIdList(s)
	}
}

func (s *RuleComponentIdListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleComponentIdList(s)
	}
}

func (s *RuleComponentIdListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleComponentIdList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleComponentIdList() (localctx IRuleComponentIdListContext) {
	return p.ruleComponentIdList(0)
}

func (p *asn1Parser) ruleComponentIdList(_p int) (localctx IRuleComponentIdListContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRuleComponentIdListContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRuleComponentIdListContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 512
	p.EnterRecursionRule(localctx, 512, asn1ParserRULE_ruleComponentIdList, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2091)
		p.RuleIdentifier()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2098)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 130, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewRuleComponentIdListContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, asn1ParserRULE_ruleComponentIdList)
			p.SetState(2093)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(2094)
				p.Match(asn1ParserDOT)
			}
			{
				p.SetState(2095)
				p.RuleIdentifier()
			}

		}
		p.SetState(2100)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 130, p.GetParserRuleContext())
	}

	return localctx
}

// IRuleAtNotationContext is an interface to support dynamic dispatch.
type IRuleAtNotationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleAtNotationContext differentiates from other interfaces.
	IsRuleAtNotationContext()
}

type RuleAtNotationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleAtNotationContext() *RuleAtNotationContext {
	var p = new(RuleAtNotationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleAtNotation
	return p
}

func (*RuleAtNotationContext) IsRuleAtNotationContext() {}

func NewRuleAtNotationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleAtNotationContext {
	var p = new(RuleAtNotationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleAtNotation

	return p
}

func (s *RuleAtNotationContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleAtNotationContext) AT() antlr.TerminalNode {
	return s.GetToken(asn1ParserAT, 0)
}

func (s *RuleAtNotationContext) RuleComponentIdList() IRuleComponentIdListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleComponentIdListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleComponentIdListContext)
}

func (s *RuleAtNotationContext) DOT() antlr.TerminalNode {
	return s.GetToken(asn1ParserDOT, 0)
}

func (s *RuleAtNotationContext) RuleLevel() IRuleLevelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleLevelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleLevelContext)
}

func (s *RuleAtNotationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleAtNotationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleAtNotationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleAtNotation(s)
	}
}

func (s *RuleAtNotationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleAtNotation(s)
	}
}

func (s *RuleAtNotationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleAtNotation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleAtNotation() (localctx IRuleAtNotationContext) {
	this := p
	_ = this

	localctx = NewRuleAtNotationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 514, asn1ParserRULE_ruleAtNotation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2108)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 131, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2101)
			p.Match(asn1ParserAT)
		}
		{
			p.SetState(2102)
			p.ruleComponentIdList(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2103)
			p.Match(asn1ParserAT)
		}
		{
			p.SetState(2104)
			p.Match(asn1ParserDOT)
		}
		{
			p.SetState(2105)
			p.RuleLevel()
		}
		{
			p.SetState(2106)
			p.ruleComponentIdList(0)
		}

	}

	return localctx
}

// IRuleAtNotationListContext is an interface to support dynamic dispatch.
type IRuleAtNotationListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleAtNotationListContext differentiates from other interfaces.
	IsRuleAtNotationListContext()
}

type RuleAtNotationListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleAtNotationListContext() *RuleAtNotationListContext {
	var p = new(RuleAtNotationListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleAtNotationList
	return p
}

func (*RuleAtNotationListContext) IsRuleAtNotationListContext() {}

func NewRuleAtNotationListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleAtNotationListContext {
	var p = new(RuleAtNotationListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleAtNotationList

	return p
}

func (s *RuleAtNotationListContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleAtNotationListContext) RuleAtNotation() IRuleAtNotationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleAtNotationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleAtNotationContext)
}

func (s *RuleAtNotationListContext) RuleAtNotationList() IRuleAtNotationListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleAtNotationListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleAtNotationListContext)
}

func (s *RuleAtNotationListContext) COMMA() antlr.TerminalNode {
	return s.GetToken(asn1ParserCOMMA, 0)
}

func (s *RuleAtNotationListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleAtNotationListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleAtNotationListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleAtNotationList(s)
	}
}

func (s *RuleAtNotationListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleAtNotationList(s)
	}
}

func (s *RuleAtNotationListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleAtNotationList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleAtNotationList() (localctx IRuleAtNotationListContext) {
	return p.ruleAtNotationList(0)
}

func (p *asn1Parser) ruleAtNotationList(_p int) (localctx IRuleAtNotationListContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRuleAtNotationListContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRuleAtNotationListContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 516
	p.EnterRecursionRule(localctx, 516, asn1ParserRULE_ruleAtNotationList, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2111)
		p.RuleAtNotation()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2118)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 132, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewRuleAtNotationListContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, asn1ParserRULE_ruleAtNotationList)
			p.SetState(2113)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(2114)
				p.Match(asn1ParserCOMMA)
			}
			{
				p.SetState(2115)
				p.RuleAtNotation()
			}

		}
		p.SetState(2120)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 132, p.GetParserRuleContext())
	}

	return localctx
}

// IRuleUserDefinedConstraintParameterContext is an interface to support dynamic dispatch.
type IRuleUserDefinedConstraintParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleUserDefinedConstraintParameterContext differentiates from other interfaces.
	IsRuleUserDefinedConstraintParameterContext()
}

type RuleUserDefinedConstraintParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleUserDefinedConstraintParameterContext() *RuleUserDefinedConstraintParameterContext {
	var p = new(RuleUserDefinedConstraintParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleUserDefinedConstraintParameter
	return p
}

func (*RuleUserDefinedConstraintParameterContext) IsRuleUserDefinedConstraintParameterContext() {}

func NewRuleUserDefinedConstraintParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleUserDefinedConstraintParameterContext {
	var p = new(RuleUserDefinedConstraintParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleUserDefinedConstraintParameter

	return p
}

func (s *RuleUserDefinedConstraintParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleUserDefinedConstraintParameterContext) RuleGovernor() IRuleGovernorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleGovernorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleGovernorContext)
}

func (s *RuleUserDefinedConstraintParameterContext) COLON() antlr.TerminalNode {
	return s.GetToken(asn1ParserCOLON, 0)
}

func (s *RuleUserDefinedConstraintParameterContext) RuleValue() IRuleValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueContext)
}

func (s *RuleUserDefinedConstraintParameterContext) RuleObject() IRuleObjectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectContext)
}

func (s *RuleUserDefinedConstraintParameterContext) RuleDefinedObjectSet() IRuleDefinedObjectSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinedObjectSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinedObjectSetContext)
}

func (s *RuleUserDefinedConstraintParameterContext) RuleType() IRuleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeContext)
}

func (s *RuleUserDefinedConstraintParameterContext) RuleDefinedObjectClass() IRuleDefinedObjectClassContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinedObjectClassContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinedObjectClassContext)
}

func (s *RuleUserDefinedConstraintParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleUserDefinedConstraintParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleUserDefinedConstraintParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleUserDefinedConstraintParameter(s)
	}
}

func (s *RuleUserDefinedConstraintParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleUserDefinedConstraintParameter(s)
	}
}

func (s *RuleUserDefinedConstraintParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleUserDefinedConstraintParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleUserDefinedConstraintParameter() (localctx IRuleUserDefinedConstraintParameterContext) {
	this := p
	_ = this

	localctx = NewRuleUserDefinedConstraintParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 518, asn1ParserRULE_ruleUserDefinedConstraintParameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2132)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 133, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2121)
			p.RuleGovernor()
		}
		{
			p.SetState(2122)
			p.Match(asn1ParserCOLON)
		}
		{
			p.SetState(2123)
			p.RuleValue()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2125)
			p.RuleGovernor()
		}
		{
			p.SetState(2126)
			p.Match(asn1ParserCOLON)
		}
		{
			p.SetState(2127)
			p.RuleObject()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2129)
			p.RuleDefinedObjectSet()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2130)
			p.RuleType()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2131)
			p.RuleDefinedObjectClass()
		}

	}

	return localctx
}

// IRuleUserDefinedConstraintParameterListContext is an interface to support dynamic dispatch.
type IRuleUserDefinedConstraintParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleUserDefinedConstraintParameterListContext differentiates from other interfaces.
	IsRuleUserDefinedConstraintParameterListContext()
}

type RuleUserDefinedConstraintParameterListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleUserDefinedConstraintParameterListContext() *RuleUserDefinedConstraintParameterListContext {
	var p = new(RuleUserDefinedConstraintParameterListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleUserDefinedConstraintParameterList
	return p
}

func (*RuleUserDefinedConstraintParameterListContext) IsRuleUserDefinedConstraintParameterListContext() {
}

func NewRuleUserDefinedConstraintParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleUserDefinedConstraintParameterListContext {
	var p = new(RuleUserDefinedConstraintParameterListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleUserDefinedConstraintParameterList

	return p
}

func (s *RuleUserDefinedConstraintParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleUserDefinedConstraintParameterListContext) RuleUserDefinedConstraintParameter() IRuleUserDefinedConstraintParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleUserDefinedConstraintParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleUserDefinedConstraintParameterContext)
}

func (s *RuleUserDefinedConstraintParameterListContext) RuleUserDefinedConstraintParameterList() IRuleUserDefinedConstraintParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleUserDefinedConstraintParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleUserDefinedConstraintParameterListContext)
}

func (s *RuleUserDefinedConstraintParameterListContext) COMMA() antlr.TerminalNode {
	return s.GetToken(asn1ParserCOMMA, 0)
}

func (s *RuleUserDefinedConstraintParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleUserDefinedConstraintParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleUserDefinedConstraintParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleUserDefinedConstraintParameterList(s)
	}
}

func (s *RuleUserDefinedConstraintParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleUserDefinedConstraintParameterList(s)
	}
}

func (s *RuleUserDefinedConstraintParameterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleUserDefinedConstraintParameterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleUserDefinedConstraintParameterList() (localctx IRuleUserDefinedConstraintParameterListContext) {
	return p.ruleUserDefinedConstraintParameterList(0)
}

func (p *asn1Parser) ruleUserDefinedConstraintParameterList(_p int) (localctx IRuleUserDefinedConstraintParameterListContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRuleUserDefinedConstraintParameterListContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRuleUserDefinedConstraintParameterListContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 520
	p.EnterRecursionRule(localctx, 520, asn1ParserRULE_ruleUserDefinedConstraintParameterList, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2137)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 134, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2135)
			p.RuleUserDefinedConstraintParameter()
		}

	case 2:

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2144)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 135, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewRuleUserDefinedConstraintParameterListContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, asn1ParserRULE_ruleUserDefinedConstraintParameterList)
			p.SetState(2139)

			if !(p.Precpred(p.GetParserRuleContext(), 3)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
			}
			{
				p.SetState(2140)
				p.Match(asn1ParserCOMMA)
			}
			{
				p.SetState(2141)
				p.RuleUserDefinedConstraintParameter()
			}

		}
		p.SetState(2146)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 135, p.GetParserRuleContext())
	}

	return localctx
}

// IRuleUserDefinedConstraintContext is an interface to support dynamic dispatch.
type IRuleUserDefinedConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleUserDefinedConstraintContext differentiates from other interfaces.
	IsRuleUserDefinedConstraintContext()
}

type RuleUserDefinedConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleUserDefinedConstraintContext() *RuleUserDefinedConstraintContext {
	var p = new(RuleUserDefinedConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleUserDefinedConstraint
	return p
}

func (*RuleUserDefinedConstraintContext) IsRuleUserDefinedConstraintContext() {}

func NewRuleUserDefinedConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleUserDefinedConstraintContext {
	var p = new(RuleUserDefinedConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleUserDefinedConstraint

	return p
}

func (s *RuleUserDefinedConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleUserDefinedConstraintContext) CONSTRAINED_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserCONSTRAINED_SYM, 0)
}

func (s *RuleUserDefinedConstraintContext) BY_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserBY_SYM, 0)
}

func (s *RuleUserDefinedConstraintContext) CURLY_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_START, 0)
}

func (s *RuleUserDefinedConstraintContext) RuleUserDefinedConstraintParameterList() IRuleUserDefinedConstraintParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleUserDefinedConstraintParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleUserDefinedConstraintParameterListContext)
}

func (s *RuleUserDefinedConstraintContext) CURLY_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_END, 0)
}

func (s *RuleUserDefinedConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleUserDefinedConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleUserDefinedConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleUserDefinedConstraint(s)
	}
}

func (s *RuleUserDefinedConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleUserDefinedConstraint(s)
	}
}

func (s *RuleUserDefinedConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleUserDefinedConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleUserDefinedConstraint() (localctx IRuleUserDefinedConstraintContext) {
	this := p
	_ = this

	localctx = NewRuleUserDefinedConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 522, asn1ParserRULE_ruleUserDefinedConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2147)
		p.Match(asn1ParserCONSTRAINED_SYM)
	}
	{
		p.SetState(2148)
		p.Match(asn1ParserBY_SYM)
	}
	{
		p.SetState(2149)
		p.Match(asn1ParserCURLY_START)
	}
	{
		p.SetState(2150)
		p.ruleUserDefinedConstraintParameterList(0)
	}
	{
		p.SetState(2151)
		p.Match(asn1ParserCURLY_END)
	}

	return localctx
}

// IRuleSimpleTableConstraintContext is an interface to support dynamic dispatch.
type IRuleSimpleTableConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleSimpleTableConstraintContext differentiates from other interfaces.
	IsRuleSimpleTableConstraintContext()
}

type RuleSimpleTableConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleSimpleTableConstraintContext() *RuleSimpleTableConstraintContext {
	var p = new(RuleSimpleTableConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleSimpleTableConstraint
	return p
}

func (*RuleSimpleTableConstraintContext) IsRuleSimpleTableConstraintContext() {}

func NewRuleSimpleTableConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleSimpleTableConstraintContext {
	var p = new(RuleSimpleTableConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleSimpleTableConstraint

	return p
}

func (s *RuleSimpleTableConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleSimpleTableConstraintContext) RuleObjectSet() IRuleObjectSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectSetContext)
}

func (s *RuleSimpleTableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleSimpleTableConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleSimpleTableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleSimpleTableConstraint(s)
	}
}

func (s *RuleSimpleTableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleSimpleTableConstraint(s)
	}
}

func (s *RuleSimpleTableConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleSimpleTableConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleSimpleTableConstraint() (localctx IRuleSimpleTableConstraintContext) {
	this := p
	_ = this

	localctx = NewRuleSimpleTableConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 524, asn1ParserRULE_ruleSimpleTableConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2153)
		p.RuleObjectSet()
	}

	return localctx
}

// IRuleComponentRelationConstraintContext is an interface to support dynamic dispatch.
type IRuleComponentRelationConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleComponentRelationConstraintContext differentiates from other interfaces.
	IsRuleComponentRelationConstraintContext()
}

type RuleComponentRelationConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleComponentRelationConstraintContext() *RuleComponentRelationConstraintContext {
	var p = new(RuleComponentRelationConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleComponentRelationConstraint
	return p
}

func (*RuleComponentRelationConstraintContext) IsRuleComponentRelationConstraintContext() {}

func NewRuleComponentRelationConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleComponentRelationConstraintContext {
	var p = new(RuleComponentRelationConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleComponentRelationConstraint

	return p
}

func (s *RuleComponentRelationConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleComponentRelationConstraintContext) AllCURLY_START() []antlr.TerminalNode {
	return s.GetTokens(asn1ParserCURLY_START)
}

func (s *RuleComponentRelationConstraintContext) CURLY_START(i int) antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_START, i)
}

func (s *RuleComponentRelationConstraintContext) RuleDefinedObjectSet() IRuleDefinedObjectSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinedObjectSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinedObjectSetContext)
}

func (s *RuleComponentRelationConstraintContext) AllCURLY_END() []antlr.TerminalNode {
	return s.GetTokens(asn1ParserCURLY_END)
}

func (s *RuleComponentRelationConstraintContext) CURLY_END(i int) antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_END, i)
}

func (s *RuleComponentRelationConstraintContext) RuleAtNotationList() IRuleAtNotationListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleAtNotationListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleAtNotationListContext)
}

func (s *RuleComponentRelationConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleComponentRelationConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleComponentRelationConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleComponentRelationConstraint(s)
	}
}

func (s *RuleComponentRelationConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleComponentRelationConstraint(s)
	}
}

func (s *RuleComponentRelationConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleComponentRelationConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleComponentRelationConstraint() (localctx IRuleComponentRelationConstraintContext) {
	this := p
	_ = this

	localctx = NewRuleComponentRelationConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 526, asn1ParserRULE_ruleComponentRelationConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2155)
		p.Match(asn1ParserCURLY_START)
	}
	{
		p.SetState(2156)
		p.RuleDefinedObjectSet()
	}
	{
		p.SetState(2157)
		p.Match(asn1ParserCURLY_END)
	}
	{
		p.SetState(2158)
		p.Match(asn1ParserCURLY_START)
	}
	{
		p.SetState(2159)
		p.ruleAtNotationList(0)
	}
	{
		p.SetState(2160)
		p.Match(asn1ParserCURLY_END)
	}

	return localctx
}

// IRuleTableConstraintContext is an interface to support dynamic dispatch.
type IRuleTableConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleTableConstraintContext differentiates from other interfaces.
	IsRuleTableConstraintContext()
}

type RuleTableConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleTableConstraintContext() *RuleTableConstraintContext {
	var p = new(RuleTableConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleTableConstraint
	return p
}

func (*RuleTableConstraintContext) IsRuleTableConstraintContext() {}

func NewRuleTableConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleTableConstraintContext {
	var p = new(RuleTableConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleTableConstraint

	return p
}

func (s *RuleTableConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleTableConstraintContext) RuleSimpleTableConstraint() IRuleSimpleTableConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSimpleTableConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSimpleTableConstraintContext)
}

func (s *RuleTableConstraintContext) RuleComponentRelationConstraint() IRuleComponentRelationConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleComponentRelationConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleComponentRelationConstraintContext)
}

func (s *RuleTableConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleTableConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleTableConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleTableConstraint(s)
	}
}

func (s *RuleTableConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleTableConstraint(s)
	}
}

func (s *RuleTableConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleTableConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleTableConstraint() (localctx IRuleTableConstraintContext) {
	this := p
	_ = this

	localctx = NewRuleTableConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 528, asn1ParserRULE_ruleTableConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2164)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2162)
			p.RuleSimpleTableConstraint()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2163)
			p.RuleComponentRelationConstraint()
		}

	}

	return localctx
}

// IRuleContentsConstraintContext is an interface to support dynamic dispatch.
type IRuleContentsConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleContentsConstraintContext differentiates from other interfaces.
	IsRuleContentsConstraintContext()
}

type RuleContentsConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleContentsConstraintContext() *RuleContentsConstraintContext {
	var p = new(RuleContentsConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleContentsConstraint
	return p
}

func (*RuleContentsConstraintContext) IsRuleContentsConstraintContext() {}

func NewRuleContentsConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleContentsConstraintContext {
	var p = new(RuleContentsConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleContentsConstraint

	return p
}

func (s *RuleContentsConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleContentsConstraintContext) CONTAINING_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserCONTAINING_SYM, 0)
}

func (s *RuleContentsConstraintContext) RuleType() IRuleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeContext)
}

func (s *RuleContentsConstraintContext) ENCODED_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserENCODED_SYM, 0)
}

func (s *RuleContentsConstraintContext) BY_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserBY_SYM, 0)
}

func (s *RuleContentsConstraintContext) RuleValue() IRuleValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueContext)
}

func (s *RuleContentsConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleContentsConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleContentsConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleContentsConstraint(s)
	}
}

func (s *RuleContentsConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleContentsConstraint(s)
	}
}

func (s *RuleContentsConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleContentsConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleContentsConstraint() (localctx IRuleContentsConstraintContext) {
	this := p
	_ = this

	localctx = NewRuleContentsConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 530, asn1ParserRULE_ruleContentsConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2177)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2166)
			p.Match(asn1ParserCONTAINING_SYM)
		}
		{
			p.SetState(2167)
			p.RuleType()
		}
		{
			p.SetState(2168)
			p.Match(asn1ParserENCODED_SYM)
		}
		{
			p.SetState(2169)
			p.Match(asn1ParserBY_SYM)
		}
		{
			p.SetState(2170)
			p.RuleValue()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2172)
			p.Match(asn1ParserCONTAINING_SYM)
		}
		{
			p.SetState(2173)
			p.RuleType()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2174)
			p.Match(asn1ParserENCODED_SYM)
		}
		{
			p.SetState(2175)
			p.Match(asn1ParserBY_SYM)
		}
		{
			p.SetState(2176)
			p.RuleValue()
		}

	}

	return localctx
}

// IRuleSubtypeConstraintContext is an interface to support dynamic dispatch.
type IRuleSubtypeConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleSubtypeConstraintContext differentiates from other interfaces.
	IsRuleSubtypeConstraintContext()
}

type RuleSubtypeConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleSubtypeConstraintContext() *RuleSubtypeConstraintContext {
	var p = new(RuleSubtypeConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleSubtypeConstraint
	return p
}

func (*RuleSubtypeConstraintContext) IsRuleSubtypeConstraintContext() {}

func NewRuleSubtypeConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleSubtypeConstraintContext {
	var p = new(RuleSubtypeConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleSubtypeConstraint

	return p
}

func (s *RuleSubtypeConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleSubtypeConstraintContext) RuleElementSetSpecs() IRuleElementSetSpecsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleElementSetSpecsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleElementSetSpecsContext)
}

func (s *RuleSubtypeConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleSubtypeConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleSubtypeConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleSubtypeConstraint(s)
	}
}

func (s *RuleSubtypeConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleSubtypeConstraint(s)
	}
}

func (s *RuleSubtypeConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleSubtypeConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleSubtypeConstraint() (localctx IRuleSubtypeConstraintContext) {
	this := p
	_ = this

	localctx = NewRuleSubtypeConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 532, asn1ParserRULE_ruleSubtypeConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2179)
		p.RuleElementSetSpecs()
	}

	return localctx
}

// IRuleGeneralConstraintContext is an interface to support dynamic dispatch.
type IRuleGeneralConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleGeneralConstraintContext differentiates from other interfaces.
	IsRuleGeneralConstraintContext()
}

type RuleGeneralConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleGeneralConstraintContext() *RuleGeneralConstraintContext {
	var p = new(RuleGeneralConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleGeneralConstraint
	return p
}

func (*RuleGeneralConstraintContext) IsRuleGeneralConstraintContext() {}

func NewRuleGeneralConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleGeneralConstraintContext {
	var p = new(RuleGeneralConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleGeneralConstraint

	return p
}

func (s *RuleGeneralConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleGeneralConstraintContext) RuleUserDefinedConstraint() IRuleUserDefinedConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleUserDefinedConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleUserDefinedConstraintContext)
}

func (s *RuleGeneralConstraintContext) RuleTableConstraint() IRuleTableConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTableConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTableConstraintContext)
}

func (s *RuleGeneralConstraintContext) RuleContentsConstraint() IRuleContentsConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleContentsConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleContentsConstraintContext)
}

func (s *RuleGeneralConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleGeneralConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleGeneralConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleGeneralConstraint(s)
	}
}

func (s *RuleGeneralConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleGeneralConstraint(s)
	}
}

func (s *RuleGeneralConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleGeneralConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleGeneralConstraint() (localctx IRuleGeneralConstraintContext) {
	this := p
	_ = this

	localctx = NewRuleGeneralConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 534, asn1ParserRULE_ruleGeneralConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2184)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case asn1ParserCONSTRAINED_SYM:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2181)
			p.RuleUserDefinedConstraint()
		}

	case asn1ParserCURLY_START:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2182)
			p.RuleTableConstraint()
		}

	case asn1ParserCONTAINING_SYM, asn1ParserENCODED_SYM:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2183)
			p.RuleContentsConstraint()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRuleConstraintSpecContext is an interface to support dynamic dispatch.
type IRuleConstraintSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleConstraintSpecContext differentiates from other interfaces.
	IsRuleConstraintSpecContext()
}

type RuleConstraintSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleConstraintSpecContext() *RuleConstraintSpecContext {
	var p = new(RuleConstraintSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleConstraintSpec
	return p
}

func (*RuleConstraintSpecContext) IsRuleConstraintSpecContext() {}

func NewRuleConstraintSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleConstraintSpecContext {
	var p = new(RuleConstraintSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleConstraintSpec

	return p
}

func (s *RuleConstraintSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleConstraintSpecContext) RuleSubtypeConstraint() IRuleSubtypeConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSubtypeConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSubtypeConstraintContext)
}

func (s *RuleConstraintSpecContext) RuleGeneralConstraint() IRuleGeneralConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleGeneralConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleGeneralConstraintContext)
}

func (s *RuleConstraintSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleConstraintSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleConstraintSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleConstraintSpec(s)
	}
}

func (s *RuleConstraintSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleConstraintSpec(s)
	}
}

func (s *RuleConstraintSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleConstraintSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleConstraintSpec() (localctx IRuleConstraintSpecContext) {
	this := p
	_ = this

	localctx = NewRuleConstraintSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 536, asn1ParserRULE_ruleConstraintSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2188)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 139, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2186)
			p.RuleSubtypeConstraint()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2187)
			p.RuleGeneralConstraint()
		}

	}

	return localctx
}

// IRuleSignedNumberContext is an interface to support dynamic dispatch.
type IRuleSignedNumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleSignedNumberContext differentiates from other interfaces.
	IsRuleSignedNumberContext()
}

type RuleSignedNumberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleSignedNumberContext() *RuleSignedNumberContext {
	var p = new(RuleSignedNumberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleSignedNumber
	return p
}

func (*RuleSignedNumberContext) IsRuleSignedNumberContext() {}

func NewRuleSignedNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleSignedNumberContext {
	var p = new(RuleSignedNumberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleSignedNumber

	return p
}

func (s *RuleSignedNumberContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleSignedNumberContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(asn1ParserNUMBER, 0)
}

func (s *RuleSignedNumberContext) MINUS() antlr.TerminalNode {
	return s.GetToken(asn1ParserMINUS, 0)
}

func (s *RuleSignedNumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleSignedNumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleSignedNumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleSignedNumber(s)
	}
}

func (s *RuleSignedNumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleSignedNumber(s)
	}
}

func (s *RuleSignedNumberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleSignedNumber(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleSignedNumber() (localctx IRuleSignedNumberContext) {
	this := p
	_ = this

	localctx = NewRuleSignedNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 538, asn1ParserRULE_ruleSignedNumber)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2193)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case asn1ParserNUMBER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2190)
			p.Match(asn1ParserNUMBER)
		}

	case asn1ParserMINUS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2191)
			p.Match(asn1ParserMINUS)
		}
		{
			p.SetState(2192)
			p.Match(asn1ParserNUMBER)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRuleExceptionIdentificationContext is an interface to support dynamic dispatch.
type IRuleExceptionIdentificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleExceptionIdentificationContext differentiates from other interfaces.
	IsRuleExceptionIdentificationContext()
}

type RuleExceptionIdentificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleExceptionIdentificationContext() *RuleExceptionIdentificationContext {
	var p = new(RuleExceptionIdentificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleExceptionIdentification
	return p
}

func (*RuleExceptionIdentificationContext) IsRuleExceptionIdentificationContext() {}

func NewRuleExceptionIdentificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleExceptionIdentificationContext {
	var p = new(RuleExceptionIdentificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleExceptionIdentification

	return p
}

func (s *RuleExceptionIdentificationContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleExceptionIdentificationContext) RuleSignedNumber() IRuleSignedNumberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSignedNumberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSignedNumberContext)
}

func (s *RuleExceptionIdentificationContext) RuleDefinedValue() IRuleDefinedValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinedValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinedValueContext)
}

func (s *RuleExceptionIdentificationContext) RuleType() IRuleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeContext)
}

func (s *RuleExceptionIdentificationContext) COLON() antlr.TerminalNode {
	return s.GetToken(asn1ParserCOLON, 0)
}

func (s *RuleExceptionIdentificationContext) RuleValue() IRuleValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueContext)
}

func (s *RuleExceptionIdentificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleExceptionIdentificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleExceptionIdentificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleExceptionIdentification(s)
	}
}

func (s *RuleExceptionIdentificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleExceptionIdentification(s)
	}
}

func (s *RuleExceptionIdentificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleExceptionIdentification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleExceptionIdentification() (localctx IRuleExceptionIdentificationContext) {
	this := p
	_ = this

	localctx = NewRuleExceptionIdentificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 540, asn1ParserRULE_ruleExceptionIdentification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2201)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 141, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2195)
			p.RuleSignedNumber()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2196)
			p.RuleDefinedValue()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2197)
			p.RuleType()
		}
		{
			p.SetState(2198)
			p.Match(asn1ParserCOLON)
		}
		{
			p.SetState(2199)
			p.RuleValue()
		}

	}

	return localctx
}

// IRuleExceptionSpecContext is an interface to support dynamic dispatch.
type IRuleExceptionSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleExceptionSpecContext differentiates from other interfaces.
	IsRuleExceptionSpecContext()
}

type RuleExceptionSpecContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleExceptionSpecContext() *RuleExceptionSpecContext {
	var p = new(RuleExceptionSpecContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleExceptionSpec
	return p
}

func (*RuleExceptionSpecContext) IsRuleExceptionSpecContext() {}

func NewRuleExceptionSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleExceptionSpecContext {
	var p = new(RuleExceptionSpecContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleExceptionSpec

	return p
}

func (s *RuleExceptionSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleExceptionSpecContext) EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(asn1ParserEXCLAMATION, 0)
}

func (s *RuleExceptionSpecContext) RuleExceptionIdentification() IRuleExceptionIdentificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleExceptionIdentificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleExceptionIdentificationContext)
}

func (s *RuleExceptionSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleExceptionSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleExceptionSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleExceptionSpec(s)
	}
}

func (s *RuleExceptionSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleExceptionSpec(s)
	}
}

func (s *RuleExceptionSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleExceptionSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleExceptionSpec() (localctx IRuleExceptionSpecContext) {
	this := p
	_ = this

	localctx = NewRuleExceptionSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 542, asn1ParserRULE_ruleExceptionSpec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2206)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case asn1ParserEXCLAMATION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2203)
			p.Match(asn1ParserEXCLAMATION)
		}
		{
			p.SetState(2204)
			p.RuleExceptionIdentification()
		}

	case asn1ParserCURLY_END, asn1ParserROUND_END, asn1ParserCOMMA:
		p.EnterOuterAlt(localctx, 2)

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRuleConstraintContext is an interface to support dynamic dispatch.
type IRuleConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleConstraintContext differentiates from other interfaces.
	IsRuleConstraintContext()
}

type RuleConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleConstraintContext() *RuleConstraintContext {
	var p = new(RuleConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleConstraint
	return p
}

func (*RuleConstraintContext) IsRuleConstraintContext() {}

func NewRuleConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleConstraintContext {
	var p = new(RuleConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleConstraint

	return p
}

func (s *RuleConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleConstraintContext) ROUND_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserROUND_START, 0)
}

func (s *RuleConstraintContext) RuleConstraintSpec() IRuleConstraintSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleConstraintSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleConstraintSpecContext)
}

func (s *RuleConstraintContext) RuleExceptionSpec() IRuleExceptionSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleExceptionSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleExceptionSpecContext)
}

func (s *RuleConstraintContext) ROUND_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserROUND_END, 0)
}

func (s *RuleConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleConstraint(s)
	}
}

func (s *RuleConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleConstraint(s)
	}
}

func (s *RuleConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleConstraint() (localctx IRuleConstraintContext) {
	this := p
	_ = this

	localctx = NewRuleConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 544, asn1ParserRULE_ruleConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2208)
		p.Match(asn1ParserROUND_START)
	}
	{
		p.SetState(2209)
		p.RuleConstraintSpec()
	}
	{
		p.SetState(2210)
		p.RuleExceptionSpec()
	}
	{
		p.SetState(2211)
		p.Match(asn1ParserROUND_END)
	}

	return localctx
}

// IRuleSingleTypeConstraintContext is an interface to support dynamic dispatch.
type IRuleSingleTypeConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleSingleTypeConstraintContext differentiates from other interfaces.
	IsRuleSingleTypeConstraintContext()
}

type RuleSingleTypeConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleSingleTypeConstraintContext() *RuleSingleTypeConstraintContext {
	var p = new(RuleSingleTypeConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleSingleTypeConstraint
	return p
}

func (*RuleSingleTypeConstraintContext) IsRuleSingleTypeConstraintContext() {}

func NewRuleSingleTypeConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleSingleTypeConstraintContext {
	var p = new(RuleSingleTypeConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleSingleTypeConstraint

	return p
}

func (s *RuleSingleTypeConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleSingleTypeConstraintContext) RuleConstraint() IRuleConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleConstraintContext)
}

func (s *RuleSingleTypeConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleSingleTypeConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleSingleTypeConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleSingleTypeConstraint(s)
	}
}

func (s *RuleSingleTypeConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleSingleTypeConstraint(s)
	}
}

func (s *RuleSingleTypeConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleSingleTypeConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleSingleTypeConstraint() (localctx IRuleSingleTypeConstraintContext) {
	this := p
	_ = this

	localctx = NewRuleSingleTypeConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 546, asn1ParserRULE_ruleSingleTypeConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2213)
		p.RuleConstraint()
	}

	return localctx
}

// IRuleValueConstraintContext is an interface to support dynamic dispatch.
type IRuleValueConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleValueConstraintContext differentiates from other interfaces.
	IsRuleValueConstraintContext()
}

type RuleValueConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleValueConstraintContext() *RuleValueConstraintContext {
	var p = new(RuleValueConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleValueConstraint
	return p
}

func (*RuleValueConstraintContext) IsRuleValueConstraintContext() {}

func NewRuleValueConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleValueConstraintContext {
	var p = new(RuleValueConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleValueConstraint

	return p
}

func (s *RuleValueConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleValueConstraintContext) RuleConstraint() IRuleConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleConstraintContext)
}

func (s *RuleValueConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleValueConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleValueConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleValueConstraint(s)
	}
}

func (s *RuleValueConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleValueConstraint(s)
	}
}

func (s *RuleValueConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleValueConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleValueConstraint() (localctx IRuleValueConstraintContext) {
	this := p
	_ = this

	localctx = NewRuleValueConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 548, asn1ParserRULE_ruleValueConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2217)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 143, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2215)
			p.RuleConstraint()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)

	}

	return localctx
}

// IRulePresenceConstraintContext is an interface to support dynamic dispatch.
type IRulePresenceConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRulePresenceConstraintContext differentiates from other interfaces.
	IsRulePresenceConstraintContext()
}

type RulePresenceConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRulePresenceConstraintContext() *RulePresenceConstraintContext {
	var p = new(RulePresenceConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_rulePresenceConstraint
	return p
}

func (*RulePresenceConstraintContext) IsRulePresenceConstraintContext() {}

func NewRulePresenceConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RulePresenceConstraintContext {
	var p = new(RulePresenceConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_rulePresenceConstraint

	return p
}

func (s *RulePresenceConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *RulePresenceConstraintContext) PRESENT_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserPRESENT_SYM, 0)
}

func (s *RulePresenceConstraintContext) ABSENT_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserABSENT_SYM, 0)
}

func (s *RulePresenceConstraintContext) OPTIONAL_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserOPTIONAL_SYM, 0)
}

func (s *RulePresenceConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RulePresenceConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RulePresenceConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRulePresenceConstraint(s)
	}
}

func (s *RulePresenceConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRulePresenceConstraint(s)
	}
}

func (s *RulePresenceConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRulePresenceConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RulePresenceConstraint() (localctx IRulePresenceConstraintContext) {
	this := p
	_ = this

	localctx = NewRulePresenceConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 550, asn1ParserRULE_rulePresenceConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2223)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 144, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2219)
			p.Match(asn1ParserPRESENT_SYM)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2220)
			p.Match(asn1ParserABSENT_SYM)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2221)
			p.Match(asn1ParserOPTIONAL_SYM)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)

	}

	return localctx
}

// IRuleComponentConstraintContext is an interface to support dynamic dispatch.
type IRuleComponentConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleComponentConstraintContext differentiates from other interfaces.
	IsRuleComponentConstraintContext()
}

type RuleComponentConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleComponentConstraintContext() *RuleComponentConstraintContext {
	var p = new(RuleComponentConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleComponentConstraint
	return p
}

func (*RuleComponentConstraintContext) IsRuleComponentConstraintContext() {}

func NewRuleComponentConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleComponentConstraintContext {
	var p = new(RuleComponentConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleComponentConstraint

	return p
}

func (s *RuleComponentConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleComponentConstraintContext) RuleValueConstraint() IRuleValueConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueConstraintContext)
}

func (s *RuleComponentConstraintContext) RulePresenceConstraint() IRulePresenceConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRulePresenceConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRulePresenceConstraintContext)
}

func (s *RuleComponentConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleComponentConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleComponentConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleComponentConstraint(s)
	}
}

func (s *RuleComponentConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleComponentConstraint(s)
	}
}

func (s *RuleComponentConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleComponentConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleComponentConstraint() (localctx IRuleComponentConstraintContext) {
	this := p
	_ = this

	localctx = NewRuleComponentConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 552, asn1ParserRULE_ruleComponentConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2225)
		p.RuleValueConstraint()
	}
	{
		p.SetState(2226)
		p.RulePresenceConstraint()
	}

	return localctx
}

// IRuleNamedConstraintContext is an interface to support dynamic dispatch.
type IRuleNamedConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleNamedConstraintContext differentiates from other interfaces.
	IsRuleNamedConstraintContext()
}

type RuleNamedConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleNamedConstraintContext() *RuleNamedConstraintContext {
	var p = new(RuleNamedConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleNamedConstraint
	return p
}

func (*RuleNamedConstraintContext) IsRuleNamedConstraintContext() {}

func NewRuleNamedConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleNamedConstraintContext {
	var p = new(RuleNamedConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleNamedConstraint

	return p
}

func (s *RuleNamedConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleNamedConstraintContext) RuleIdentifier() IRuleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleIdentifierContext)
}

func (s *RuleNamedConstraintContext) RuleComponentConstraint() IRuleComponentConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleComponentConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleComponentConstraintContext)
}

func (s *RuleNamedConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleNamedConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleNamedConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleNamedConstraint(s)
	}
}

func (s *RuleNamedConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleNamedConstraint(s)
	}
}

func (s *RuleNamedConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleNamedConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleNamedConstraint() (localctx IRuleNamedConstraintContext) {
	this := p
	_ = this

	localctx = NewRuleNamedConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 554, asn1ParserRULE_ruleNamedConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2228)
		p.RuleIdentifier()
	}
	{
		p.SetState(2229)
		p.RuleComponentConstraint()
	}

	return localctx
}

// IRuleTypeConstraintsContext is an interface to support dynamic dispatch.
type IRuleTypeConstraintsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleTypeConstraintsContext differentiates from other interfaces.
	IsRuleTypeConstraintsContext()
}

type RuleTypeConstraintsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleTypeConstraintsContext() *RuleTypeConstraintsContext {
	var p = new(RuleTypeConstraintsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleTypeConstraints
	return p
}

func (*RuleTypeConstraintsContext) IsRuleTypeConstraintsContext() {}

func NewRuleTypeConstraintsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleTypeConstraintsContext {
	var p = new(RuleTypeConstraintsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleTypeConstraints

	return p
}

func (s *RuleTypeConstraintsContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleTypeConstraintsContext) RuleNamedConstraint() IRuleNamedConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleNamedConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleNamedConstraintContext)
}

func (s *RuleTypeConstraintsContext) RuleTypeConstraints() IRuleTypeConstraintsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeConstraintsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeConstraintsContext)
}

func (s *RuleTypeConstraintsContext) COMMA() antlr.TerminalNode {
	return s.GetToken(asn1ParserCOMMA, 0)
}

func (s *RuleTypeConstraintsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleTypeConstraintsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleTypeConstraintsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleTypeConstraints(s)
	}
}

func (s *RuleTypeConstraintsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleTypeConstraints(s)
	}
}

func (s *RuleTypeConstraintsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleTypeConstraints(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleTypeConstraints() (localctx IRuleTypeConstraintsContext) {
	return p.ruleTypeConstraints(0)
}

func (p *asn1Parser) ruleTypeConstraints(_p int) (localctx IRuleTypeConstraintsContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRuleTypeConstraintsContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRuleTypeConstraintsContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 556
	p.EnterRecursionRule(localctx, 556, asn1ParserRULE_ruleTypeConstraints, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2232)
		p.RuleNamedConstraint()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2239)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 145, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewRuleTypeConstraintsContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, asn1ParserRULE_ruleTypeConstraints)
			p.SetState(2234)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(2235)
				p.Match(asn1ParserCOMMA)
			}
			{
				p.SetState(2236)
				p.RuleNamedConstraint()
			}

		}
		p.SetState(2241)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 145, p.GetParserRuleContext())
	}

	return localctx
}

// IRuleFullSpecificationContext is an interface to support dynamic dispatch.
type IRuleFullSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleFullSpecificationContext differentiates from other interfaces.
	IsRuleFullSpecificationContext()
}

type RuleFullSpecificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleFullSpecificationContext() *RuleFullSpecificationContext {
	var p = new(RuleFullSpecificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleFullSpecification
	return p
}

func (*RuleFullSpecificationContext) IsRuleFullSpecificationContext() {}

func NewRuleFullSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleFullSpecificationContext {
	var p = new(RuleFullSpecificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleFullSpecification

	return p
}

func (s *RuleFullSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleFullSpecificationContext) CURLY_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_START, 0)
}

func (s *RuleFullSpecificationContext) RuleTypeConstraints() IRuleTypeConstraintsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeConstraintsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeConstraintsContext)
}

func (s *RuleFullSpecificationContext) CURLY_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_END, 0)
}

func (s *RuleFullSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleFullSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleFullSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleFullSpecification(s)
	}
}

func (s *RuleFullSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleFullSpecification(s)
	}
}

func (s *RuleFullSpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleFullSpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleFullSpecification() (localctx IRuleFullSpecificationContext) {
	this := p
	_ = this

	localctx = NewRuleFullSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 558, asn1ParserRULE_ruleFullSpecification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2242)
		p.Match(asn1ParserCURLY_START)
	}
	{
		p.SetState(2243)
		p.ruleTypeConstraints(0)
	}
	{
		p.SetState(2244)
		p.Match(asn1ParserCURLY_END)
	}

	return localctx
}

// IRulePartialSpecificationContext is an interface to support dynamic dispatch.
type IRulePartialSpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRulePartialSpecificationContext differentiates from other interfaces.
	IsRulePartialSpecificationContext()
}

type RulePartialSpecificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRulePartialSpecificationContext() *RulePartialSpecificationContext {
	var p = new(RulePartialSpecificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_rulePartialSpecification
	return p
}

func (*RulePartialSpecificationContext) IsRulePartialSpecificationContext() {}

func NewRulePartialSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RulePartialSpecificationContext {
	var p = new(RulePartialSpecificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_rulePartialSpecification

	return p
}

func (s *RulePartialSpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *RulePartialSpecificationContext) CURLY_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_START, 0)
}

func (s *RulePartialSpecificationContext) ELLIPSIS() antlr.TerminalNode {
	return s.GetToken(asn1ParserELLIPSIS, 0)
}

func (s *RulePartialSpecificationContext) COMMA() antlr.TerminalNode {
	return s.GetToken(asn1ParserCOMMA, 0)
}

func (s *RulePartialSpecificationContext) RuleTypeConstraints() IRuleTypeConstraintsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeConstraintsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeConstraintsContext)
}

func (s *RulePartialSpecificationContext) CURLY_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_END, 0)
}

func (s *RulePartialSpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RulePartialSpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RulePartialSpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRulePartialSpecification(s)
	}
}

func (s *RulePartialSpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRulePartialSpecification(s)
	}
}

func (s *RulePartialSpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRulePartialSpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RulePartialSpecification() (localctx IRulePartialSpecificationContext) {
	this := p
	_ = this

	localctx = NewRulePartialSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 560, asn1ParserRULE_rulePartialSpecification)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2246)
		p.Match(asn1ParserCURLY_START)
	}
	{
		p.SetState(2247)
		p.Match(asn1ParserELLIPSIS)
	}
	{
		p.SetState(2248)
		p.Match(asn1ParserCOMMA)
	}
	{
		p.SetState(2249)
		p.ruleTypeConstraints(0)
	}
	{
		p.SetState(2250)
		p.Match(asn1ParserCURLY_END)
	}

	return localctx
}

// IRuleMultipleTypeConstraintsContext is an interface to support dynamic dispatch.
type IRuleMultipleTypeConstraintsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleMultipleTypeConstraintsContext differentiates from other interfaces.
	IsRuleMultipleTypeConstraintsContext()
}

type RuleMultipleTypeConstraintsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleMultipleTypeConstraintsContext() *RuleMultipleTypeConstraintsContext {
	var p = new(RuleMultipleTypeConstraintsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleMultipleTypeConstraints
	return p
}

func (*RuleMultipleTypeConstraintsContext) IsRuleMultipleTypeConstraintsContext() {}

func NewRuleMultipleTypeConstraintsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleMultipleTypeConstraintsContext {
	var p = new(RuleMultipleTypeConstraintsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleMultipleTypeConstraints

	return p
}

func (s *RuleMultipleTypeConstraintsContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleMultipleTypeConstraintsContext) RuleFullSpecification() IRuleFullSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleFullSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleFullSpecificationContext)
}

func (s *RuleMultipleTypeConstraintsContext) RulePartialSpecification() IRulePartialSpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRulePartialSpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRulePartialSpecificationContext)
}

func (s *RuleMultipleTypeConstraintsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleMultipleTypeConstraintsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleMultipleTypeConstraintsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleMultipleTypeConstraints(s)
	}
}

func (s *RuleMultipleTypeConstraintsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleMultipleTypeConstraints(s)
	}
}

func (s *RuleMultipleTypeConstraintsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleMultipleTypeConstraints(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleMultipleTypeConstraints() (localctx IRuleMultipleTypeConstraintsContext) {
	this := p
	_ = this

	localctx = NewRuleMultipleTypeConstraintsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 562, asn1ParserRULE_ruleMultipleTypeConstraints)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2254)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 146, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2252)
			p.RuleFullSpecification()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2253)
			p.RulePartialSpecification()
		}

	}

	return localctx
}

// IRuleSimpleStringContext is an interface to support dynamic dispatch.
type IRuleSimpleStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleSimpleStringContext differentiates from other interfaces.
	IsRuleSimpleStringContext()
}

type RuleSimpleStringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleSimpleStringContext() *RuleSimpleStringContext {
	var p = new(RuleSimpleStringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleSimpleString
	return p
}

func (*RuleSimpleStringContext) IsRuleSimpleStringContext() {}

func NewRuleSimpleStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleSimpleStringContext {
	var p = new(RuleSimpleStringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleSimpleString

	return p
}

func (s *RuleSimpleStringContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleSimpleStringContext) CHAR_STRING() antlr.TerminalNode {
	return s.GetToken(asn1ParserCHAR_STRING, 0)
}

func (s *RuleSimpleStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleSimpleStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleSimpleStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleSimpleString(s)
	}
}

func (s *RuleSimpleStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleSimpleString(s)
	}
}

func (s *RuleSimpleStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleSimpleString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleSimpleString() (localctx IRuleSimpleStringContext) {
	this := p
	_ = this

	localctx = NewRuleSimpleStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 564, asn1ParserRULE_ruleSimpleString)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2256)
		p.Match(asn1ParserCHAR_STRING)
	}

	return localctx
}

// IRuleSingleValueContext is an interface to support dynamic dispatch.
type IRuleSingleValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleSingleValueContext differentiates from other interfaces.
	IsRuleSingleValueContext()
}

type RuleSingleValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleSingleValueContext() *RuleSingleValueContext {
	var p = new(RuleSingleValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleSingleValue
	return p
}

func (*RuleSingleValueContext) IsRuleSingleValueContext() {}

func NewRuleSingleValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleSingleValueContext {
	var p = new(RuleSingleValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleSingleValue

	return p
}

func (s *RuleSingleValueContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleSingleValueContext) RuleValue() IRuleValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueContext)
}

func (s *RuleSingleValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleSingleValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleSingleValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleSingleValue(s)
	}
}

func (s *RuleSingleValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleSingleValue(s)
	}
}

func (s *RuleSingleValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleSingleValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleSingleValue() (localctx IRuleSingleValueContext) {
	this := p
	_ = this

	localctx = NewRuleSingleValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 566, asn1ParserRULE_ruleSingleValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2258)
		p.RuleValue()
	}

	return localctx
}

// IRuleContainedSubtypeContext is an interface to support dynamic dispatch.
type IRuleContainedSubtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleContainedSubtypeContext differentiates from other interfaces.
	IsRuleContainedSubtypeContext()
}

type RuleContainedSubtypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleContainedSubtypeContext() *RuleContainedSubtypeContext {
	var p = new(RuleContainedSubtypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleContainedSubtype
	return p
}

func (*RuleContainedSubtypeContext) IsRuleContainedSubtypeContext() {}

func NewRuleContainedSubtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleContainedSubtypeContext {
	var p = new(RuleContainedSubtypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleContainedSubtype

	return p
}

func (s *RuleContainedSubtypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleContainedSubtypeContext) RuleIncludes() IRuleIncludesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleIncludesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleIncludesContext)
}

func (s *RuleContainedSubtypeContext) RuleType() IRuleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeContext)
}

func (s *RuleContainedSubtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleContainedSubtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleContainedSubtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleContainedSubtype(s)
	}
}

func (s *RuleContainedSubtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleContainedSubtype(s)
	}
}

func (s *RuleContainedSubtypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleContainedSubtype(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleContainedSubtype() (localctx IRuleContainedSubtypeContext) {
	this := p
	_ = this

	localctx = NewRuleContainedSubtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 568, asn1ParserRULE_ruleContainedSubtype)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2260)
		p.RuleIncludes()
	}
	{
		p.SetState(2261)
		p.RuleType()
	}

	return localctx
}

// IRuleValueRangeContext is an interface to support dynamic dispatch.
type IRuleValueRangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleValueRangeContext differentiates from other interfaces.
	IsRuleValueRangeContext()
}

type RuleValueRangeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleValueRangeContext() *RuleValueRangeContext {
	var p = new(RuleValueRangeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleValueRange
	return p
}

func (*RuleValueRangeContext) IsRuleValueRangeContext() {}

func NewRuleValueRangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleValueRangeContext {
	var p = new(RuleValueRangeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleValueRange

	return p
}

func (s *RuleValueRangeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleValueRangeContext) RuleLowerEndpoint() IRuleLowerEndpointContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleLowerEndpointContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleLowerEndpointContext)
}

func (s *RuleValueRangeContext) RANGE() antlr.TerminalNode {
	return s.GetToken(asn1ParserRANGE, 0)
}

func (s *RuleValueRangeContext) RuleUpperEndpoint() IRuleUpperEndpointContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleUpperEndpointContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleUpperEndpointContext)
}

func (s *RuleValueRangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleValueRangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleValueRangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleValueRange(s)
	}
}

func (s *RuleValueRangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleValueRange(s)
	}
}

func (s *RuleValueRangeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleValueRange(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleValueRange() (localctx IRuleValueRangeContext) {
	this := p
	_ = this

	localctx = NewRuleValueRangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 570, asn1ParserRULE_ruleValueRange)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2263)
		p.RuleLowerEndpoint()
	}
	{
		p.SetState(2264)
		p.Match(asn1ParserRANGE)
	}
	{
		p.SetState(2265)
		p.RuleUpperEndpoint()
	}

	return localctx
}

// IRulePermittedAlphabetContext is an interface to support dynamic dispatch.
type IRulePermittedAlphabetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRulePermittedAlphabetContext differentiates from other interfaces.
	IsRulePermittedAlphabetContext()
}

type RulePermittedAlphabetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRulePermittedAlphabetContext() *RulePermittedAlphabetContext {
	var p = new(RulePermittedAlphabetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_rulePermittedAlphabet
	return p
}

func (*RulePermittedAlphabetContext) IsRulePermittedAlphabetContext() {}

func NewRulePermittedAlphabetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RulePermittedAlphabetContext {
	var p = new(RulePermittedAlphabetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_rulePermittedAlphabet

	return p
}

func (s *RulePermittedAlphabetContext) GetParser() antlr.Parser { return s.parser }

func (s *RulePermittedAlphabetContext) FROM_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserFROM_SYM, 0)
}

func (s *RulePermittedAlphabetContext) RuleConstraint() IRuleConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleConstraintContext)
}

func (s *RulePermittedAlphabetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RulePermittedAlphabetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RulePermittedAlphabetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRulePermittedAlphabet(s)
	}
}

func (s *RulePermittedAlphabetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRulePermittedAlphabet(s)
	}
}

func (s *RulePermittedAlphabetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRulePermittedAlphabet(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RulePermittedAlphabet() (localctx IRulePermittedAlphabetContext) {
	this := p
	_ = this

	localctx = NewRulePermittedAlphabetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 572, asn1ParserRULE_rulePermittedAlphabet)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2267)
		p.Match(asn1ParserFROM_SYM)
	}
	{
		p.SetState(2268)
		p.RuleConstraint()
	}

	return localctx
}

// IRuleSizeConstraintContext is an interface to support dynamic dispatch.
type IRuleSizeConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleSizeConstraintContext differentiates from other interfaces.
	IsRuleSizeConstraintContext()
}

type RuleSizeConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleSizeConstraintContext() *RuleSizeConstraintContext {
	var p = new(RuleSizeConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleSizeConstraint
	return p
}

func (*RuleSizeConstraintContext) IsRuleSizeConstraintContext() {}

func NewRuleSizeConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleSizeConstraintContext {
	var p = new(RuleSizeConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleSizeConstraint

	return p
}

func (s *RuleSizeConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleSizeConstraintContext) SIZE_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserSIZE_SYM, 0)
}

func (s *RuleSizeConstraintContext) RuleConstraint() IRuleConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleConstraintContext)
}

func (s *RuleSizeConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleSizeConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleSizeConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleSizeConstraint(s)
	}
}

func (s *RuleSizeConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleSizeConstraint(s)
	}
}

func (s *RuleSizeConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleSizeConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleSizeConstraint() (localctx IRuleSizeConstraintContext) {
	this := p
	_ = this

	localctx = NewRuleSizeConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 574, asn1ParserRULE_ruleSizeConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2270)
		p.Match(asn1ParserSIZE_SYM)
	}
	{
		p.SetState(2271)
		p.RuleConstraint()
	}

	return localctx
}

// IRuleInnerTypeConstraintsContext is an interface to support dynamic dispatch.
type IRuleInnerTypeConstraintsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleInnerTypeConstraintsContext differentiates from other interfaces.
	IsRuleInnerTypeConstraintsContext()
}

type RuleInnerTypeConstraintsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleInnerTypeConstraintsContext() *RuleInnerTypeConstraintsContext {
	var p = new(RuleInnerTypeConstraintsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleInnerTypeConstraints
	return p
}

func (*RuleInnerTypeConstraintsContext) IsRuleInnerTypeConstraintsContext() {}

func NewRuleInnerTypeConstraintsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleInnerTypeConstraintsContext {
	var p = new(RuleInnerTypeConstraintsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleInnerTypeConstraints

	return p
}

func (s *RuleInnerTypeConstraintsContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleInnerTypeConstraintsContext) WITH_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserWITH_SYM, 0)
}

func (s *RuleInnerTypeConstraintsContext) COMPONENT_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserCOMPONENT_SYM, 0)
}

func (s *RuleInnerTypeConstraintsContext) RuleSingleTypeConstraint() IRuleSingleTypeConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSingleTypeConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSingleTypeConstraintContext)
}

func (s *RuleInnerTypeConstraintsContext) COMPONENTS_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserCOMPONENTS_SYM, 0)
}

func (s *RuleInnerTypeConstraintsContext) RuleMultipleTypeConstraints() IRuleMultipleTypeConstraintsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleMultipleTypeConstraintsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleMultipleTypeConstraintsContext)
}

func (s *RuleInnerTypeConstraintsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleInnerTypeConstraintsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleInnerTypeConstraintsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleInnerTypeConstraints(s)
	}
}

func (s *RuleInnerTypeConstraintsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleInnerTypeConstraints(s)
	}
}

func (s *RuleInnerTypeConstraintsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleInnerTypeConstraints(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleInnerTypeConstraints() (localctx IRuleInnerTypeConstraintsContext) {
	this := p
	_ = this

	localctx = NewRuleInnerTypeConstraintsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 576, asn1ParserRULE_ruleInnerTypeConstraints)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2279)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 147, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2273)
			p.Match(asn1ParserWITH_SYM)
		}
		{
			p.SetState(2274)
			p.Match(asn1ParserCOMPONENT_SYM)
		}
		{
			p.SetState(2275)
			p.RuleSingleTypeConstraint()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2276)
			p.Match(asn1ParserWITH_SYM)
		}
		{
			p.SetState(2277)
			p.Match(asn1ParserCOMPONENTS_SYM)
		}
		{
			p.SetState(2278)
			p.RuleMultipleTypeConstraints()
		}

	}

	return localctx
}

// IRulePatternConstraintContext is an interface to support dynamic dispatch.
type IRulePatternConstraintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRulePatternConstraintContext differentiates from other interfaces.
	IsRulePatternConstraintContext()
}

type RulePatternConstraintContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRulePatternConstraintContext() *RulePatternConstraintContext {
	var p = new(RulePatternConstraintContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_rulePatternConstraint
	return p
}

func (*RulePatternConstraintContext) IsRulePatternConstraintContext() {}

func NewRulePatternConstraintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RulePatternConstraintContext {
	var p = new(RulePatternConstraintContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_rulePatternConstraint

	return p
}

func (s *RulePatternConstraintContext) GetParser() antlr.Parser { return s.parser }

func (s *RulePatternConstraintContext) PATTERN_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserPATTERN_SYM, 0)
}

func (s *RulePatternConstraintContext) RuleValue() IRuleValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueContext)
}

func (s *RulePatternConstraintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RulePatternConstraintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RulePatternConstraintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRulePatternConstraint(s)
	}
}

func (s *RulePatternConstraintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRulePatternConstraint(s)
	}
}

func (s *RulePatternConstraintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRulePatternConstraint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RulePatternConstraint() (localctx IRulePatternConstraintContext) {
	this := p
	_ = this

	localctx = NewRulePatternConstraintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 578, asn1ParserRULE_rulePatternConstraint)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2281)
		p.Match(asn1ParserPATTERN_SYM)
	}
	{
		p.SetState(2282)
		p.RuleValue()
	}

	return localctx
}

// IRulePropertySettingsContext is an interface to support dynamic dispatch.
type IRulePropertySettingsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRulePropertySettingsContext differentiates from other interfaces.
	IsRulePropertySettingsContext()
}

type RulePropertySettingsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRulePropertySettingsContext() *RulePropertySettingsContext {
	var p = new(RulePropertySettingsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_rulePropertySettings
	return p
}

func (*RulePropertySettingsContext) IsRulePropertySettingsContext() {}

func NewRulePropertySettingsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RulePropertySettingsContext {
	var p = new(RulePropertySettingsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_rulePropertySettings

	return p
}

func (s *RulePropertySettingsContext) GetParser() antlr.Parser { return s.parser }

func (s *RulePropertySettingsContext) SETTINGS_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserSETTINGS_SYM, 0)
}

func (s *RulePropertySettingsContext) RuleSimpleString() IRuleSimpleStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSimpleStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSimpleStringContext)
}

func (s *RulePropertySettingsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RulePropertySettingsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RulePropertySettingsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRulePropertySettings(s)
	}
}

func (s *RulePropertySettingsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRulePropertySettings(s)
	}
}

func (s *RulePropertySettingsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRulePropertySettings(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RulePropertySettings() (localctx IRulePropertySettingsContext) {
	this := p
	_ = this

	localctx = NewRulePropertySettingsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 580, asn1ParserRULE_rulePropertySettings)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2284)
		p.Match(asn1ParserSETTINGS_SYM)
	}
	{
		p.SetState(2285)
		p.RuleSimpleString()
	}

	return localctx
}

// IRuleDurationRangeContext is an interface to support dynamic dispatch.
type IRuleDurationRangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleDurationRangeContext differentiates from other interfaces.
	IsRuleDurationRangeContext()
}

type RuleDurationRangeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleDurationRangeContext() *RuleDurationRangeContext {
	var p = new(RuleDurationRangeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleDurationRange
	return p
}

func (*RuleDurationRangeContext) IsRuleDurationRangeContext() {}

func NewRuleDurationRangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleDurationRangeContext {
	var p = new(RuleDurationRangeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleDurationRange

	return p
}

func (s *RuleDurationRangeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleDurationRangeContext) RuleValueRange() IRuleValueRangeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueRangeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueRangeContext)
}

func (s *RuleDurationRangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleDurationRangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleDurationRangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleDurationRange(s)
	}
}

func (s *RuleDurationRangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleDurationRange(s)
	}
}

func (s *RuleDurationRangeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleDurationRange(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleDurationRange() (localctx IRuleDurationRangeContext) {
	this := p
	_ = this

	localctx = NewRuleDurationRangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 582, asn1ParserRULE_ruleDurationRange)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2287)
		p.RuleValueRange()
	}

	return localctx
}

// IRuleTimePointRangeContext is an interface to support dynamic dispatch.
type IRuleTimePointRangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleTimePointRangeContext differentiates from other interfaces.
	IsRuleTimePointRangeContext()
}

type RuleTimePointRangeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleTimePointRangeContext() *RuleTimePointRangeContext {
	var p = new(RuleTimePointRangeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleTimePointRange
	return p
}

func (*RuleTimePointRangeContext) IsRuleTimePointRangeContext() {}

func NewRuleTimePointRangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleTimePointRangeContext {
	var p = new(RuleTimePointRangeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleTimePointRange

	return p
}

func (s *RuleTimePointRangeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleTimePointRangeContext) RuleValueRange() IRuleValueRangeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueRangeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueRangeContext)
}

func (s *RuleTimePointRangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleTimePointRangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleTimePointRangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleTimePointRange(s)
	}
}

func (s *RuleTimePointRangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleTimePointRange(s)
	}
}

func (s *RuleTimePointRangeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleTimePointRange(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleTimePointRange() (localctx IRuleTimePointRangeContext) {
	this := p
	_ = this

	localctx = NewRuleTimePointRangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 584, asn1ParserRULE_ruleTimePointRange)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2289)
		p.RuleValueRange()
	}

	return localctx
}

// IRuleRecurrenceRangeContext is an interface to support dynamic dispatch.
type IRuleRecurrenceRangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleRecurrenceRangeContext differentiates from other interfaces.
	IsRuleRecurrenceRangeContext()
}

type RuleRecurrenceRangeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleRecurrenceRangeContext() *RuleRecurrenceRangeContext {
	var p = new(RuleRecurrenceRangeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleRecurrenceRange
	return p
}

func (*RuleRecurrenceRangeContext) IsRuleRecurrenceRangeContext() {}

func NewRuleRecurrenceRangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleRecurrenceRangeContext {
	var p = new(RuleRecurrenceRangeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleRecurrenceRange

	return p
}

func (s *RuleRecurrenceRangeContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleRecurrenceRangeContext) RuleValueRange() IRuleValueRangeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueRangeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueRangeContext)
}

func (s *RuleRecurrenceRangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleRecurrenceRangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleRecurrenceRangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleRecurrenceRange(s)
	}
}

func (s *RuleRecurrenceRangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleRecurrenceRange(s)
	}
}

func (s *RuleRecurrenceRangeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleRecurrenceRange(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleRecurrenceRange() (localctx IRuleRecurrenceRangeContext) {
	this := p
	_ = this

	localctx = NewRuleRecurrenceRangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 586, asn1ParserRULE_ruleRecurrenceRange)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2291)
		p.RuleValueRange()
	}

	return localctx
}

// IRuleSubtypeElementsContext is an interface to support dynamic dispatch.
type IRuleSubtypeElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleSubtypeElementsContext differentiates from other interfaces.
	IsRuleSubtypeElementsContext()
}

type RuleSubtypeElementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleSubtypeElementsContext() *RuleSubtypeElementsContext {
	var p = new(RuleSubtypeElementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleSubtypeElements
	return p
}

func (*RuleSubtypeElementsContext) IsRuleSubtypeElementsContext() {}

func NewRuleSubtypeElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleSubtypeElementsContext {
	var p = new(RuleSubtypeElementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleSubtypeElements

	return p
}

func (s *RuleSubtypeElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleSubtypeElementsContext) RuleSingleValue() IRuleSingleValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSingleValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSingleValueContext)
}

func (s *RuleSubtypeElementsContext) RuleContainedSubtype() IRuleContainedSubtypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleContainedSubtypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleContainedSubtypeContext)
}

func (s *RuleSubtypeElementsContext) RuleValueRange() IRuleValueRangeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueRangeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueRangeContext)
}

func (s *RuleSubtypeElementsContext) RulePermittedAlphabet() IRulePermittedAlphabetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRulePermittedAlphabetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRulePermittedAlphabetContext)
}

func (s *RuleSubtypeElementsContext) RuleSizeConstraint() IRuleSizeConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSizeConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSizeConstraintContext)
}

func (s *RuleSubtypeElementsContext) RuleInnerTypeConstraints() IRuleInnerTypeConstraintsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleInnerTypeConstraintsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleInnerTypeConstraintsContext)
}

func (s *RuleSubtypeElementsContext) RulePatternConstraint() IRulePatternConstraintContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRulePatternConstraintContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRulePatternConstraintContext)
}

func (s *RuleSubtypeElementsContext) RulePropertySettings() IRulePropertySettingsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRulePropertySettingsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRulePropertySettingsContext)
}

func (s *RuleSubtypeElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleSubtypeElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleSubtypeElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleSubtypeElements(s)
	}
}

func (s *RuleSubtypeElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleSubtypeElements(s)
	}
}

func (s *RuleSubtypeElementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleSubtypeElements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleSubtypeElements() (localctx IRuleSubtypeElementsContext) {
	this := p
	_ = this

	localctx = NewRuleSubtypeElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 588, asn1ParserRULE_ruleSubtypeElements)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2301)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 148, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2293)
			p.RuleSingleValue()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2294)
			p.RuleContainedSubtype()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2295)
			p.RuleValueRange()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2296)
			p.RulePermittedAlphabet()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2297)
			p.RuleSizeConstraint()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2298)
			p.RuleInnerTypeConstraints()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2299)
			p.RulePatternConstraint()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2300)
			p.RulePropertySettings()
		}

	}

	return localctx
}

// IRuleObjectSetElementsContext is an interface to support dynamic dispatch.
type IRuleObjectSetElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleObjectSetElementsContext differentiates from other interfaces.
	IsRuleObjectSetElementsContext()
}

type RuleObjectSetElementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleObjectSetElementsContext() *RuleObjectSetElementsContext {
	var p = new(RuleObjectSetElementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleObjectSetElements
	return p
}

func (*RuleObjectSetElementsContext) IsRuleObjectSetElementsContext() {}

func NewRuleObjectSetElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleObjectSetElementsContext {
	var p = new(RuleObjectSetElementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleObjectSetElements

	return p
}

func (s *RuleObjectSetElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleObjectSetElementsContext) RuleObject() IRuleObjectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectContext)
}

func (s *RuleObjectSetElementsContext) RuleDefinedObjectSet() IRuleDefinedObjectSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinedObjectSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinedObjectSetContext)
}

func (s *RuleObjectSetElementsContext) RuleObjectSetFromObjects() IRuleObjectSetFromObjectsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectSetFromObjectsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectSetFromObjectsContext)
}

func (s *RuleObjectSetElementsContext) RuleParameterizedObjectSet() IRuleParameterizedObjectSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleParameterizedObjectSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleParameterizedObjectSetContext)
}

func (s *RuleObjectSetElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleObjectSetElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleObjectSetElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleObjectSetElements(s)
	}
}

func (s *RuleObjectSetElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleObjectSetElements(s)
	}
}

func (s *RuleObjectSetElementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleObjectSetElements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleObjectSetElements() (localctx IRuleObjectSetElementsContext) {
	this := p
	_ = this

	localctx = NewRuleObjectSetElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 590, asn1ParserRULE_ruleObjectSetElements)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2307)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 149, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2303)
			p.RuleObject()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2304)
			p.RuleDefinedObjectSet()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2305)
			p.RuleObjectSetFromObjects()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2306)
			p.RuleParameterizedObjectSet()
		}

	}

	return localctx
}

// IRuleElementsContext is an interface to support dynamic dispatch.
type IRuleElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleElementsContext differentiates from other interfaces.
	IsRuleElementsContext()
}

type RuleElementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleElementsContext() *RuleElementsContext {
	var p = new(RuleElementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleElements
	return p
}

func (*RuleElementsContext) IsRuleElementsContext() {}

func NewRuleElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleElementsContext {
	var p = new(RuleElementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleElements

	return p
}

func (s *RuleElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleElementsContext) RuleSubtypeElements() IRuleSubtypeElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSubtypeElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSubtypeElementsContext)
}

func (s *RuleElementsContext) RuleObjectSetElements() IRuleObjectSetElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectSetElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectSetElementsContext)
}

func (s *RuleElementsContext) ROUND_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserROUND_START, 0)
}

func (s *RuleElementsContext) RuleElementSetSpec() IRuleElementSetSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleElementSetSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleElementSetSpecContext)
}

func (s *RuleElementsContext) ROUND_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserROUND_END, 0)
}

func (s *RuleElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleElements(s)
	}
}

func (s *RuleElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleElements(s)
	}
}

func (s *RuleElementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleElements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleElements() (localctx IRuleElementsContext) {
	this := p
	_ = this

	localctx = NewRuleElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 592, asn1ParserRULE_ruleElements)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2315)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 150, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2309)
			p.RuleSubtypeElements()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2310)
			p.RuleObjectSetElements()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2311)
			p.Match(asn1ParserROUND_START)
		}
		{
			p.SetState(2312)
			p.RuleElementSetSpec()
		}
		{
			p.SetState(2313)
			p.Match(asn1ParserROUND_END)
		}

	}

	return localctx
}

// IRuleElemsContext is an interface to support dynamic dispatch.
type IRuleElemsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleElemsContext differentiates from other interfaces.
	IsRuleElemsContext()
}

type RuleElemsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleElemsContext() *RuleElemsContext {
	var p = new(RuleElemsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleElems
	return p
}

func (*RuleElemsContext) IsRuleElemsContext() {}

func NewRuleElemsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleElemsContext {
	var p = new(RuleElemsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleElems

	return p
}

func (s *RuleElemsContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleElemsContext) RuleElements() IRuleElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleElementsContext)
}

func (s *RuleElemsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleElemsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleElemsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleElems(s)
	}
}

func (s *RuleElemsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleElems(s)
	}
}

func (s *RuleElemsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleElems(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleElems() (localctx IRuleElemsContext) {
	this := p
	_ = this

	localctx = NewRuleElemsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 594, asn1ParserRULE_ruleElems)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2317)
		p.RuleElements()
	}

	return localctx
}

// IRuleIntersectionElementsContext is an interface to support dynamic dispatch.
type IRuleIntersectionElementsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleIntersectionElementsContext differentiates from other interfaces.
	IsRuleIntersectionElementsContext()
}

type RuleIntersectionElementsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleIntersectionElementsContext() *RuleIntersectionElementsContext {
	var p = new(RuleIntersectionElementsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleIntersectionElements
	return p
}

func (*RuleIntersectionElementsContext) IsRuleIntersectionElementsContext() {}

func NewRuleIntersectionElementsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleIntersectionElementsContext {
	var p = new(RuleIntersectionElementsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleIntersectionElements

	return p
}

func (s *RuleIntersectionElementsContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleIntersectionElementsContext) RuleElements() IRuleElementsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleElementsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleElementsContext)
}

func (s *RuleIntersectionElementsContext) RuleElems() IRuleElemsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleElemsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleElemsContext)
}

func (s *RuleIntersectionElementsContext) RuleExclusions() IRuleExclusionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleExclusionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleExclusionsContext)
}

func (s *RuleIntersectionElementsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleIntersectionElementsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleIntersectionElementsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleIntersectionElements(s)
	}
}

func (s *RuleIntersectionElementsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleIntersectionElements(s)
	}
}

func (s *RuleIntersectionElementsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleIntersectionElements(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleIntersectionElements() (localctx IRuleIntersectionElementsContext) {
	this := p
	_ = this

	localctx = NewRuleIntersectionElementsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 596, asn1ParserRULE_ruleIntersectionElements)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2323)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 151, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2319)
			p.RuleElements()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2320)
			p.RuleElems()
		}
		{
			p.SetState(2321)
			p.RuleExclusions()
		}

	}

	return localctx
}

// IRuleIElemsContext is an interface to support dynamic dispatch.
type IRuleIElemsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleIElemsContext differentiates from other interfaces.
	IsRuleIElemsContext()
}

type RuleIElemsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleIElemsContext() *RuleIElemsContext {
	var p = new(RuleIElemsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleIElems
	return p
}

func (*RuleIElemsContext) IsRuleIElemsContext() {}

func NewRuleIElemsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleIElemsContext {
	var p = new(RuleIElemsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleIElems

	return p
}

func (s *RuleIElemsContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleIElemsContext) RuleIntersections() IRuleIntersectionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleIntersectionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleIntersectionsContext)
}

func (s *RuleIElemsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleIElemsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleIElemsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleIElems(s)
	}
}

func (s *RuleIElemsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleIElems(s)
	}
}

func (s *RuleIElemsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleIElems(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleIElems() (localctx IRuleIElemsContext) {
	this := p
	_ = this

	localctx = NewRuleIElemsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 598, asn1ParserRULE_ruleIElems)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2325)
		p.ruleIntersections(0)
	}

	return localctx
}

// IRuleIntersectionMarkContext is an interface to support dynamic dispatch.
type IRuleIntersectionMarkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleIntersectionMarkContext differentiates from other interfaces.
	IsRuleIntersectionMarkContext()
}

type RuleIntersectionMarkContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleIntersectionMarkContext() *RuleIntersectionMarkContext {
	var p = new(RuleIntersectionMarkContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleIntersectionMark
	return p
}

func (*RuleIntersectionMarkContext) IsRuleIntersectionMarkContext() {}

func NewRuleIntersectionMarkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleIntersectionMarkContext {
	var p = new(RuleIntersectionMarkContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleIntersectionMark

	return p
}

func (s *RuleIntersectionMarkContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleIntersectionMarkContext) CARAT() antlr.TerminalNode {
	return s.GetToken(asn1ParserCARAT, 0)
}

func (s *RuleIntersectionMarkContext) INTERSECTION_SYM() antlr.TerminalNode {
	return s.GetToken(asn1ParserINTERSECTION_SYM, 0)
}

func (s *RuleIntersectionMarkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleIntersectionMarkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleIntersectionMarkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleIntersectionMark(s)
	}
}

func (s *RuleIntersectionMarkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleIntersectionMark(s)
	}
}

func (s *RuleIntersectionMarkContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleIntersectionMark(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleIntersectionMark() (localctx IRuleIntersectionMarkContext) {
	this := p
	_ = this

	localctx = NewRuleIntersectionMarkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 600, asn1ParserRULE_ruleIntersectionMark)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2327)
		_la = p.GetTokenStream().LA(1)

		if !(_la == asn1ParserINTERSECTION_SYM || _la == asn1ParserCARAT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IRuleSimpleDefinedValueContext is an interface to support dynamic dispatch.
type IRuleSimpleDefinedValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleSimpleDefinedValueContext differentiates from other interfaces.
	IsRuleSimpleDefinedValueContext()
}

type RuleSimpleDefinedValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleSimpleDefinedValueContext() *RuleSimpleDefinedValueContext {
	var p = new(RuleSimpleDefinedValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleSimpleDefinedValue
	return p
}

func (*RuleSimpleDefinedValueContext) IsRuleSimpleDefinedValueContext() {}

func NewRuleSimpleDefinedValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleSimpleDefinedValueContext {
	var p = new(RuleSimpleDefinedValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleSimpleDefinedValue

	return p
}

func (s *RuleSimpleDefinedValueContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleSimpleDefinedValueContext) RuleExternalValueReference() IRuleExternalValueReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleExternalValueReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleExternalValueReferenceContext)
}

func (s *RuleSimpleDefinedValueContext) RuleValueReference() IRuleValueReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueReferenceContext)
}

func (s *RuleSimpleDefinedValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleSimpleDefinedValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleSimpleDefinedValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleSimpleDefinedValue(s)
	}
}

func (s *RuleSimpleDefinedValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleSimpleDefinedValue(s)
	}
}

func (s *RuleSimpleDefinedValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleSimpleDefinedValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleSimpleDefinedValue() (localctx IRuleSimpleDefinedValueContext) {
	this := p
	_ = this

	localctx = NewRuleSimpleDefinedValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 602, asn1ParserRULE_ruleSimpleDefinedValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2331)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 152, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2329)
			p.RuleExternalValueReference()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2330)
			p.RuleValueReference()
		}

	}

	return localctx
}

// IRuleActualParameterListContext is an interface to support dynamic dispatch.
type IRuleActualParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleActualParameterListContext differentiates from other interfaces.
	IsRuleActualParameterListContext()
}

type RuleActualParameterListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleActualParameterListContext() *RuleActualParameterListContext {
	var p = new(RuleActualParameterListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleActualParameterList
	return p
}

func (*RuleActualParameterListContext) IsRuleActualParameterListContext() {}

func NewRuleActualParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleActualParameterListContext {
	var p = new(RuleActualParameterListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleActualParameterList

	return p
}

func (s *RuleActualParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleActualParameterListContext) CURLY_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_START, 0)
}

func (s *RuleActualParameterListContext) RuleActualParameters() IRuleActualParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleActualParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleActualParametersContext)
}

func (s *RuleActualParameterListContext) CURLY_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_END, 0)
}

func (s *RuleActualParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleActualParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleActualParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleActualParameterList(s)
	}
}

func (s *RuleActualParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleActualParameterList(s)
	}
}

func (s *RuleActualParameterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleActualParameterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleActualParameterList() (localctx IRuleActualParameterListContext) {
	this := p
	_ = this

	localctx = NewRuleActualParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 604, asn1ParserRULE_ruleActualParameterList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2333)
		p.Match(asn1ParserCURLY_START)
	}
	{
		p.SetState(2334)
		p.ruleActualParameters(0)
	}
	{
		p.SetState(2335)
		p.Match(asn1ParserCURLY_END)
	}

	return localctx
}

// IRuleActualParametersContext is an interface to support dynamic dispatch.
type IRuleActualParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleActualParametersContext differentiates from other interfaces.
	IsRuleActualParametersContext()
}

type RuleActualParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleActualParametersContext() *RuleActualParametersContext {
	var p = new(RuleActualParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleActualParameters
	return p
}

func (*RuleActualParametersContext) IsRuleActualParametersContext() {}

func NewRuleActualParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleActualParametersContext {
	var p = new(RuleActualParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleActualParameters

	return p
}

func (s *RuleActualParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleActualParametersContext) RuleActualParameter() IRuleActualParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleActualParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleActualParameterContext)
}

func (s *RuleActualParametersContext) RuleActualParameters() IRuleActualParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleActualParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleActualParametersContext)
}

func (s *RuleActualParametersContext) COMMA() antlr.TerminalNode {
	return s.GetToken(asn1ParserCOMMA, 0)
}

func (s *RuleActualParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleActualParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleActualParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleActualParameters(s)
	}
}

func (s *RuleActualParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleActualParameters(s)
	}
}

func (s *RuleActualParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleActualParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleActualParameters() (localctx IRuleActualParametersContext) {
	return p.ruleActualParameters(0)
}

func (p *asn1Parser) ruleActualParameters(_p int) (localctx IRuleActualParametersContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRuleActualParametersContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRuleActualParametersContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 606
	p.EnterRecursionRule(localctx, 606, asn1ParserRULE_ruleActualParameters, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2338)
		p.RuleActualParameter()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2345)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 153, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewRuleActualParametersContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, asn1ParserRULE_ruleActualParameters)
			p.SetState(2340)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(2341)
				p.Match(asn1ParserCOMMA)
			}
			{
				p.SetState(2342)
				p.RuleActualParameter()
			}

		}
		p.SetState(2347)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 153, p.GetParserRuleContext())
	}

	return localctx
}

// IRuleActualParameterContext is an interface to support dynamic dispatch.
type IRuleActualParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleActualParameterContext differentiates from other interfaces.
	IsRuleActualParameterContext()
}

type RuleActualParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleActualParameterContext() *RuleActualParameterContext {
	var p = new(RuleActualParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleActualParameter
	return p
}

func (*RuleActualParameterContext) IsRuleActualParameterContext() {}

func NewRuleActualParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleActualParameterContext {
	var p = new(RuleActualParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleActualParameter

	return p
}

func (s *RuleActualParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleActualParameterContext) RuleType() IRuleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeContext)
}

func (s *RuleActualParameterContext) RuleValue() IRuleValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueContext)
}

func (s *RuleActualParameterContext) RuleValueSet() IRuleValueSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueSetContext)
}

func (s *RuleActualParameterContext) RuleDefinedObjectClass() IRuleDefinedObjectClassContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinedObjectClassContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinedObjectClassContext)
}

func (s *RuleActualParameterContext) RuleObject() IRuleObjectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectContext)
}

func (s *RuleActualParameterContext) RuleObjectSet() IRuleObjectSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectSetContext)
}

func (s *RuleActualParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleActualParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleActualParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleActualParameter(s)
	}
}

func (s *RuleActualParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleActualParameter(s)
	}
}

func (s *RuleActualParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleActualParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleActualParameter() (localctx IRuleActualParameterContext) {
	this := p
	_ = this

	localctx = NewRuleActualParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 608, asn1ParserRULE_ruleActualParameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2354)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 154, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2348)
			p.RuleType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2349)
			p.RuleValue()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2350)
			p.RuleValueSet()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2351)
			p.RuleDefinedObjectClass()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2352)
			p.RuleObject()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2353)
			p.RuleObjectSet()
		}

	}

	return localctx
}

// IRuleParameterizedObjectSetContext is an interface to support dynamic dispatch.
type IRuleParameterizedObjectSetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleParameterizedObjectSetContext differentiates from other interfaces.
	IsRuleParameterizedObjectSetContext()
}

type RuleParameterizedObjectSetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleParameterizedObjectSetContext() *RuleParameterizedObjectSetContext {
	var p = new(RuleParameterizedObjectSetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleParameterizedObjectSet
	return p
}

func (*RuleParameterizedObjectSetContext) IsRuleParameterizedObjectSetContext() {}

func NewRuleParameterizedObjectSetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleParameterizedObjectSetContext {
	var p = new(RuleParameterizedObjectSetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleParameterizedObjectSet

	return p
}

func (s *RuleParameterizedObjectSetContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleParameterizedObjectSetContext) RuleDefinedObjectSet() IRuleDefinedObjectSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinedObjectSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinedObjectSetContext)
}

func (s *RuleParameterizedObjectSetContext) RuleActualParameterList() IRuleActualParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleActualParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleActualParameterListContext)
}

func (s *RuleParameterizedObjectSetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleParameterizedObjectSetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleParameterizedObjectSetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleParameterizedObjectSet(s)
	}
}

func (s *RuleParameterizedObjectSetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleParameterizedObjectSet(s)
	}
}

func (s *RuleParameterizedObjectSetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleParameterizedObjectSet(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleParameterizedObjectSet() (localctx IRuleParameterizedObjectSetContext) {
	this := p
	_ = this

	localctx = NewRuleParameterizedObjectSetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 610, asn1ParserRULE_ruleParameterizedObjectSet)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2356)
		p.RuleDefinedObjectSet()
	}
	{
		p.SetState(2357)
		p.RuleActualParameterList()
	}

	return localctx
}

// IRuleParameterizedValueContext is an interface to support dynamic dispatch.
type IRuleParameterizedValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleParameterizedValueContext differentiates from other interfaces.
	IsRuleParameterizedValueContext()
}

type RuleParameterizedValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleParameterizedValueContext() *RuleParameterizedValueContext {
	var p = new(RuleParameterizedValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleParameterizedValue
	return p
}

func (*RuleParameterizedValueContext) IsRuleParameterizedValueContext() {}

func NewRuleParameterizedValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleParameterizedValueContext {
	var p = new(RuleParameterizedValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleParameterizedValue

	return p
}

func (s *RuleParameterizedValueContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleParameterizedValueContext) RuleSimpleDefinedValue() IRuleSimpleDefinedValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleSimpleDefinedValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleSimpleDefinedValueContext)
}

func (s *RuleParameterizedValueContext) RuleActualParameterList() IRuleActualParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleActualParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleActualParameterListContext)
}

func (s *RuleParameterizedValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleParameterizedValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleParameterizedValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleParameterizedValue(s)
	}
}

func (s *RuleParameterizedValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleParameterizedValue(s)
	}
}

func (s *RuleParameterizedValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleParameterizedValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleParameterizedValue() (localctx IRuleParameterizedValueContext) {
	this := p
	_ = this

	localctx = NewRuleParameterizedValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 612, asn1ParserRULE_ruleParameterizedValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2359)
		p.RuleSimpleDefinedValue()
	}
	{
		p.SetState(2360)
		p.RuleActualParameterList()
	}

	return localctx
}

// IRuleParameterizedTypeAssignmentContext is an interface to support dynamic dispatch.
type IRuleParameterizedTypeAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleParameterizedTypeAssignmentContext differentiates from other interfaces.
	IsRuleParameterizedTypeAssignmentContext()
}

type RuleParameterizedTypeAssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleParameterizedTypeAssignmentContext() *RuleParameterizedTypeAssignmentContext {
	var p = new(RuleParameterizedTypeAssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleParameterizedTypeAssignment
	return p
}

func (*RuleParameterizedTypeAssignmentContext) IsRuleParameterizedTypeAssignmentContext() {}

func NewRuleParameterizedTypeAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleParameterizedTypeAssignmentContext {
	var p = new(RuleParameterizedTypeAssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleParameterizedTypeAssignment

	return p
}

func (s *RuleParameterizedTypeAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleParameterizedTypeAssignmentContext) RuleTypeReference() IRuleTypeReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeReferenceContext)
}

func (s *RuleParameterizedTypeAssignmentContext) RuleParameterList() IRuleParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleParameterListContext)
}

func (s *RuleParameterizedTypeAssignmentContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(asn1ParserASSIGNMENT, 0)
}

func (s *RuleParameterizedTypeAssignmentContext) RuleType() IRuleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeContext)
}

func (s *RuleParameterizedTypeAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleParameterizedTypeAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleParameterizedTypeAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleParameterizedTypeAssignment(s)
	}
}

func (s *RuleParameterizedTypeAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleParameterizedTypeAssignment(s)
	}
}

func (s *RuleParameterizedTypeAssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleParameterizedTypeAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleParameterizedTypeAssignment() (localctx IRuleParameterizedTypeAssignmentContext) {
	this := p
	_ = this

	localctx = NewRuleParameterizedTypeAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 614, asn1ParserRULE_ruleParameterizedTypeAssignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2362)
		p.RuleTypeReference()
	}
	{
		p.SetState(2363)
		p.RuleParameterList()
	}
	{
		p.SetState(2364)
		p.Match(asn1ParserASSIGNMENT)
	}
	{
		p.SetState(2365)
		p.RuleType()
	}

	return localctx
}

// IRuleParameterizedValueAssignmentContext is an interface to support dynamic dispatch.
type IRuleParameterizedValueAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleParameterizedValueAssignmentContext differentiates from other interfaces.
	IsRuleParameterizedValueAssignmentContext()
}

type RuleParameterizedValueAssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleParameterizedValueAssignmentContext() *RuleParameterizedValueAssignmentContext {
	var p = new(RuleParameterizedValueAssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleParameterizedValueAssignment
	return p
}

func (*RuleParameterizedValueAssignmentContext) IsRuleParameterizedValueAssignmentContext() {}

func NewRuleParameterizedValueAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleParameterizedValueAssignmentContext {
	var p = new(RuleParameterizedValueAssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleParameterizedValueAssignment

	return p
}

func (s *RuleParameterizedValueAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleParameterizedValueAssignmentContext) RuleValueReference() IRuleValueReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueReferenceContext)
}

func (s *RuleParameterizedValueAssignmentContext) RuleParameterList() IRuleParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleParameterListContext)
}

func (s *RuleParameterizedValueAssignmentContext) RuleType() IRuleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeContext)
}

func (s *RuleParameterizedValueAssignmentContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(asn1ParserASSIGNMENT, 0)
}

func (s *RuleParameterizedValueAssignmentContext) RuleValue() IRuleValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueContext)
}

func (s *RuleParameterizedValueAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleParameterizedValueAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleParameterizedValueAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleParameterizedValueAssignment(s)
	}
}

func (s *RuleParameterizedValueAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleParameterizedValueAssignment(s)
	}
}

func (s *RuleParameterizedValueAssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleParameterizedValueAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleParameterizedValueAssignment() (localctx IRuleParameterizedValueAssignmentContext) {
	this := p
	_ = this

	localctx = NewRuleParameterizedValueAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 616, asn1ParserRULE_ruleParameterizedValueAssignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2367)
		p.RuleValueReference()
	}
	{
		p.SetState(2368)
		p.RuleParameterList()
	}
	{
		p.SetState(2369)
		p.RuleType()
	}
	{
		p.SetState(2370)
		p.Match(asn1ParserASSIGNMENT)
	}
	{
		p.SetState(2371)
		p.RuleValue()
	}

	return localctx
}

// IRuleParameterizedValueSetTypeAssignmentContext is an interface to support dynamic dispatch.
type IRuleParameterizedValueSetTypeAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleParameterizedValueSetTypeAssignmentContext differentiates from other interfaces.
	IsRuleParameterizedValueSetTypeAssignmentContext()
}

type RuleParameterizedValueSetTypeAssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleParameterizedValueSetTypeAssignmentContext() *RuleParameterizedValueSetTypeAssignmentContext {
	var p = new(RuleParameterizedValueSetTypeAssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleParameterizedValueSetTypeAssignment
	return p
}

func (*RuleParameterizedValueSetTypeAssignmentContext) IsRuleParameterizedValueSetTypeAssignmentContext() {
}

func NewRuleParameterizedValueSetTypeAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleParameterizedValueSetTypeAssignmentContext {
	var p = new(RuleParameterizedValueSetTypeAssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleParameterizedValueSetTypeAssignment

	return p
}

func (s *RuleParameterizedValueSetTypeAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleParameterizedValueSetTypeAssignmentContext) RuleTypeReference() IRuleTypeReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeReferenceContext)
}

func (s *RuleParameterizedValueSetTypeAssignmentContext) RuleParameterList() IRuleParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleParameterListContext)
}

func (s *RuleParameterizedValueSetTypeAssignmentContext) RuleType() IRuleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeContext)
}

func (s *RuleParameterizedValueSetTypeAssignmentContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(asn1ParserASSIGNMENT, 0)
}

func (s *RuleParameterizedValueSetTypeAssignmentContext) RuleValueSet() IRuleValueSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleValueSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleValueSetContext)
}

func (s *RuleParameterizedValueSetTypeAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleParameterizedValueSetTypeAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleParameterizedValueSetTypeAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleParameterizedValueSetTypeAssignment(s)
	}
}

func (s *RuleParameterizedValueSetTypeAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleParameterizedValueSetTypeAssignment(s)
	}
}

func (s *RuleParameterizedValueSetTypeAssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleParameterizedValueSetTypeAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleParameterizedValueSetTypeAssignment() (localctx IRuleParameterizedValueSetTypeAssignmentContext) {
	this := p
	_ = this

	localctx = NewRuleParameterizedValueSetTypeAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 618, asn1ParserRULE_ruleParameterizedValueSetTypeAssignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2373)
		p.RuleTypeReference()
	}
	{
		p.SetState(2374)
		p.RuleParameterList()
	}
	{
		p.SetState(2375)
		p.RuleType()
	}
	{
		p.SetState(2376)
		p.Match(asn1ParserASSIGNMENT)
	}
	{
		p.SetState(2377)
		p.RuleValueSet()
	}

	return localctx
}

// IRuleParameterizedObjectClassAssignmentContext is an interface to support dynamic dispatch.
type IRuleParameterizedObjectClassAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleParameterizedObjectClassAssignmentContext differentiates from other interfaces.
	IsRuleParameterizedObjectClassAssignmentContext()
}

type RuleParameterizedObjectClassAssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleParameterizedObjectClassAssignmentContext() *RuleParameterizedObjectClassAssignmentContext {
	var p = new(RuleParameterizedObjectClassAssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleParameterizedObjectClassAssignment
	return p
}

func (*RuleParameterizedObjectClassAssignmentContext) IsRuleParameterizedObjectClassAssignmentContext() {
}

func NewRuleParameterizedObjectClassAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleParameterizedObjectClassAssignmentContext {
	var p = new(RuleParameterizedObjectClassAssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleParameterizedObjectClassAssignment

	return p
}

func (s *RuleParameterizedObjectClassAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleParameterizedObjectClassAssignmentContext) RuleObjectClassReference() IRuleObjectClassReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectClassReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectClassReferenceContext)
}

func (s *RuleParameterizedObjectClassAssignmentContext) RuleParameterList() IRuleParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleParameterListContext)
}

func (s *RuleParameterizedObjectClassAssignmentContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(asn1ParserASSIGNMENT, 0)
}

func (s *RuleParameterizedObjectClassAssignmentContext) RuleObjectClass() IRuleObjectClassContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectClassContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectClassContext)
}

func (s *RuleParameterizedObjectClassAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleParameterizedObjectClassAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleParameterizedObjectClassAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleParameterizedObjectClassAssignment(s)
	}
}

func (s *RuleParameterizedObjectClassAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleParameterizedObjectClassAssignment(s)
	}
}

func (s *RuleParameterizedObjectClassAssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleParameterizedObjectClassAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleParameterizedObjectClassAssignment() (localctx IRuleParameterizedObjectClassAssignmentContext) {
	this := p
	_ = this

	localctx = NewRuleParameterizedObjectClassAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 620, asn1ParserRULE_ruleParameterizedObjectClassAssignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2379)
		p.RuleObjectClassReference()
	}
	{
		p.SetState(2380)
		p.RuleParameterList()
	}
	{
		p.SetState(2381)
		p.Match(asn1ParserASSIGNMENT)
	}
	{
		p.SetState(2382)
		p.RuleObjectClass()
	}

	return localctx
}

// IRuleParameterizedObjectAssignmentContext is an interface to support dynamic dispatch.
type IRuleParameterizedObjectAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleParameterizedObjectAssignmentContext differentiates from other interfaces.
	IsRuleParameterizedObjectAssignmentContext()
}

type RuleParameterizedObjectAssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleParameterizedObjectAssignmentContext() *RuleParameterizedObjectAssignmentContext {
	var p = new(RuleParameterizedObjectAssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleParameterizedObjectAssignment
	return p
}

func (*RuleParameterizedObjectAssignmentContext) IsRuleParameterizedObjectAssignmentContext() {}

func NewRuleParameterizedObjectAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleParameterizedObjectAssignmentContext {
	var p = new(RuleParameterizedObjectAssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleParameterizedObjectAssignment

	return p
}

func (s *RuleParameterizedObjectAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleParameterizedObjectAssignmentContext) RuleObjectReference() IRuleObjectReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectReferenceContext)
}

func (s *RuleParameterizedObjectAssignmentContext) RuleParameterList() IRuleParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleParameterListContext)
}

func (s *RuleParameterizedObjectAssignmentContext) RuleDefinedObjectClass() IRuleDefinedObjectClassContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinedObjectClassContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinedObjectClassContext)
}

func (s *RuleParameterizedObjectAssignmentContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(asn1ParserASSIGNMENT, 0)
}

func (s *RuleParameterizedObjectAssignmentContext) RuleObject() IRuleObjectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectContext)
}

func (s *RuleParameterizedObjectAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleParameterizedObjectAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleParameterizedObjectAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleParameterizedObjectAssignment(s)
	}
}

func (s *RuleParameterizedObjectAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleParameterizedObjectAssignment(s)
	}
}

func (s *RuleParameterizedObjectAssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleParameterizedObjectAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleParameterizedObjectAssignment() (localctx IRuleParameterizedObjectAssignmentContext) {
	this := p
	_ = this

	localctx = NewRuleParameterizedObjectAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 622, asn1ParserRULE_ruleParameterizedObjectAssignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2384)
		p.RuleObjectReference()
	}
	{
		p.SetState(2385)
		p.RuleParameterList()
	}
	{
		p.SetState(2386)
		p.RuleDefinedObjectClass()
	}
	{
		p.SetState(2387)
		p.Match(asn1ParserASSIGNMENT)
	}
	{
		p.SetState(2388)
		p.RuleObject()
	}

	return localctx
}

// IRuleParameterizedObjectSetAssignmentContext is an interface to support dynamic dispatch.
type IRuleParameterizedObjectSetAssignmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleParameterizedObjectSetAssignmentContext differentiates from other interfaces.
	IsRuleParameterizedObjectSetAssignmentContext()
}

type RuleParameterizedObjectSetAssignmentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleParameterizedObjectSetAssignmentContext() *RuleParameterizedObjectSetAssignmentContext {
	var p = new(RuleParameterizedObjectSetAssignmentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleParameterizedObjectSetAssignment
	return p
}

func (*RuleParameterizedObjectSetAssignmentContext) IsRuleParameterizedObjectSetAssignmentContext() {}

func NewRuleParameterizedObjectSetAssignmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleParameterizedObjectSetAssignmentContext {
	var p = new(RuleParameterizedObjectSetAssignmentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleParameterizedObjectSetAssignment

	return p
}

func (s *RuleParameterizedObjectSetAssignmentContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleParameterizedObjectSetAssignmentContext) RuleObjectSetReference() IRuleObjectSetReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectSetReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectSetReferenceContext)
}

func (s *RuleParameterizedObjectSetAssignmentContext) RuleParameterList() IRuleParameterListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleParameterListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleParameterListContext)
}

func (s *RuleParameterizedObjectSetAssignmentContext) RuleDefinedObjectClass() IRuleDefinedObjectClassContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinedObjectClassContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinedObjectClassContext)
}

func (s *RuleParameterizedObjectSetAssignmentContext) ASSIGNMENT() antlr.TerminalNode {
	return s.GetToken(asn1ParserASSIGNMENT, 0)
}

func (s *RuleParameterizedObjectSetAssignmentContext) RuleObjectSet() IRuleObjectSetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleObjectSetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleObjectSetContext)
}

func (s *RuleParameterizedObjectSetAssignmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleParameterizedObjectSetAssignmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleParameterizedObjectSetAssignmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleParameterizedObjectSetAssignment(s)
	}
}

func (s *RuleParameterizedObjectSetAssignmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleParameterizedObjectSetAssignment(s)
	}
}

func (s *RuleParameterizedObjectSetAssignmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleParameterizedObjectSetAssignment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleParameterizedObjectSetAssignment() (localctx IRuleParameterizedObjectSetAssignmentContext) {
	this := p
	_ = this

	localctx = NewRuleParameterizedObjectSetAssignmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 624, asn1ParserRULE_ruleParameterizedObjectSetAssignment)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2390)
		p.RuleObjectSetReference()
	}
	{
		p.SetState(2391)
		p.RuleParameterList()
	}
	{
		p.SetState(2392)
		p.RuleDefinedObjectClass()
	}
	{
		p.SetState(2393)
		p.Match(asn1ParserASSIGNMENT)
	}
	{
		p.SetState(2394)
		p.RuleObjectSet()
	}

	return localctx
}

// IRuleParameterListContext is an interface to support dynamic dispatch.
type IRuleParameterListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleParameterListContext differentiates from other interfaces.
	IsRuleParameterListContext()
}

type RuleParameterListContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleParameterListContext() *RuleParameterListContext {
	var p = new(RuleParameterListContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleParameterList
	return p
}

func (*RuleParameterListContext) IsRuleParameterListContext() {}

func NewRuleParameterListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleParameterListContext {
	var p = new(RuleParameterListContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleParameterList

	return p
}

func (s *RuleParameterListContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleParameterListContext) CURLY_START() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_START, 0)
}

func (s *RuleParameterListContext) RuleParameters() IRuleParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleParametersContext)
}

func (s *RuleParameterListContext) CURLY_END() antlr.TerminalNode {
	return s.GetToken(asn1ParserCURLY_END, 0)
}

func (s *RuleParameterListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleParameterListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleParameterListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleParameterList(s)
	}
}

func (s *RuleParameterListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleParameterList(s)
	}
}

func (s *RuleParameterListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleParameterList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleParameterList() (localctx IRuleParameterListContext) {
	this := p
	_ = this

	localctx = NewRuleParameterListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 626, asn1ParserRULE_ruleParameterList)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2396)
		p.Match(asn1ParserCURLY_START)
	}
	{
		p.SetState(2397)
		p.ruleParameters(0)
	}
	{
		p.SetState(2398)
		p.Match(asn1ParserCURLY_END)
	}

	return localctx
}

// IRuleParametersContext is an interface to support dynamic dispatch.
type IRuleParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleParametersContext differentiates from other interfaces.
	IsRuleParametersContext()
}

type RuleParametersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleParametersContext() *RuleParametersContext {
	var p = new(RuleParametersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleParameters
	return p
}

func (*RuleParametersContext) IsRuleParametersContext() {}

func NewRuleParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleParametersContext {
	var p = new(RuleParametersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleParameters

	return p
}

func (s *RuleParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleParametersContext) RuleParameter() IRuleParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleParameterContext)
}

func (s *RuleParametersContext) RuleParameters() IRuleParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleParametersContext)
}

func (s *RuleParametersContext) COMMA() antlr.TerminalNode {
	return s.GetToken(asn1ParserCOMMA, 0)
}

func (s *RuleParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleParameters(s)
	}
}

func (s *RuleParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleParameters(s)
	}
}

func (s *RuleParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleParameters() (localctx IRuleParametersContext) {
	return p.ruleParameters(0)
}

func (p *asn1Parser) ruleParameters(_p int) (localctx IRuleParametersContext) {
	this := p
	_ = this

	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewRuleParametersContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IRuleParametersContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 628
	p.EnterRecursionRule(localctx, 628, asn1ParserRULE_ruleParameters, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2401)
		p.RuleParameter()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(2408)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 155, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewRuleParametersContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, asn1ParserRULE_ruleParameters)
			p.SetState(2403)

			if !(p.Precpred(p.GetParserRuleContext(), 2)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
			}
			{
				p.SetState(2404)
				p.Match(asn1ParserCOMMA)
			}
			{
				p.SetState(2405)
				p.RuleParameter()
			}

		}
		p.SetState(2410)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 155, p.GetParserRuleContext())
	}

	return localctx
}

// IRuleParameterContext is an interface to support dynamic dispatch.
type IRuleParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleParameterContext differentiates from other interfaces.
	IsRuleParameterContext()
}

type RuleParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleParameterContext() *RuleParameterContext {
	var p = new(RuleParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleParameter
	return p
}

func (*RuleParameterContext) IsRuleParameterContext() {}

func NewRuleParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleParameterContext {
	var p = new(RuleParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleParameter

	return p
}

func (s *RuleParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleParameterContext) RuleParamGovernor() IRuleParamGovernorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleParamGovernorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleParamGovernorContext)
}

func (s *RuleParameterContext) COLON() antlr.TerminalNode {
	return s.GetToken(asn1ParserCOLON, 0)
}

func (s *RuleParameterContext) RuleDummyReference() IRuleDummyReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDummyReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDummyReferenceContext)
}

func (s *RuleParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleParameter(s)
	}
}

func (s *RuleParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleParameter(s)
	}
}

func (s *RuleParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleParameter() (localctx IRuleParameterContext) {
	this := p
	_ = this

	localctx = NewRuleParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 630, asn1ParserRULE_ruleParameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2416)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 156, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2411)
			p.RuleParamGovernor()
		}
		{
			p.SetState(2412)
			p.Match(asn1ParserCOLON)
		}
		{
			p.SetState(2413)
			p.RuleDummyReference()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2415)
			p.RuleDummyReference()
		}

	}

	return localctx
}

// IRuleParamGovernorContext is an interface to support dynamic dispatch.
type IRuleParamGovernorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleParamGovernorContext differentiates from other interfaces.
	IsRuleParamGovernorContext()
}

type RuleParamGovernorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleParamGovernorContext() *RuleParamGovernorContext {
	var p = new(RuleParamGovernorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleParamGovernor
	return p
}

func (*RuleParamGovernorContext) IsRuleParamGovernorContext() {}

func NewRuleParamGovernorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleParamGovernorContext {
	var p = new(RuleParamGovernorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleParamGovernor

	return p
}

func (s *RuleParamGovernorContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleParamGovernorContext) RuleGovernor() IRuleGovernorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleGovernorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleGovernorContext)
}

func (s *RuleParamGovernorContext) RuleDummyGovernor() IRuleDummyGovernorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDummyGovernorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDummyGovernorContext)
}

func (s *RuleParamGovernorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleParamGovernorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleParamGovernorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleParamGovernor(s)
	}
}

func (s *RuleParamGovernorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleParamGovernor(s)
	}
}

func (s *RuleParamGovernorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleParamGovernor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleParamGovernor() (localctx IRuleParamGovernorContext) {
	this := p
	_ = this

	localctx = NewRuleParamGovernorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 632, asn1ParserRULE_ruleParamGovernor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2420)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 157, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2418)
			p.RuleGovernor()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2419)
			p.RuleDummyGovernor()
		}

	}

	return localctx
}

// IRuleDummyReferenceContext is an interface to support dynamic dispatch.
type IRuleDummyReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleDummyReferenceContext differentiates from other interfaces.
	IsRuleDummyReferenceContext()
}

type RuleDummyReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleDummyReferenceContext() *RuleDummyReferenceContext {
	var p = new(RuleDummyReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleDummyReference
	return p
}

func (*RuleDummyReferenceContext) IsRuleDummyReferenceContext() {}

func NewRuleDummyReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleDummyReferenceContext {
	var p = new(RuleDummyReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleDummyReference

	return p
}

func (s *RuleDummyReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleDummyReferenceContext) RuleReference() IRuleReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleReferenceContext)
}

func (s *RuleDummyReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleDummyReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleDummyReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleDummyReference(s)
	}
}

func (s *RuleDummyReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleDummyReference(s)
	}
}

func (s *RuleDummyReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleDummyReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleDummyReference() (localctx IRuleDummyReferenceContext) {
	this := p
	_ = this

	localctx = NewRuleDummyReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 634, asn1ParserRULE_ruleDummyReference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2422)
		p.RuleReference()
	}

	return localctx
}

// IRuleGovernorContext is an interface to support dynamic dispatch.
type IRuleGovernorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleGovernorContext differentiates from other interfaces.
	IsRuleGovernorContext()
}

type RuleGovernorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleGovernorContext() *RuleGovernorContext {
	var p = new(RuleGovernorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleGovernor
	return p
}

func (*RuleGovernorContext) IsRuleGovernorContext() {}

func NewRuleGovernorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleGovernorContext {
	var p = new(RuleGovernorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleGovernor

	return p
}

func (s *RuleGovernorContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleGovernorContext) RuleType() IRuleTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleTypeContext)
}

func (s *RuleGovernorContext) RuleDefinedObjectClass() IRuleDefinedObjectClassContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDefinedObjectClassContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDefinedObjectClassContext)
}

func (s *RuleGovernorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleGovernorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleGovernorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleGovernor(s)
	}
}

func (s *RuleGovernorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleGovernor(s)
	}
}

func (s *RuleGovernorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleGovernor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleGovernor() (localctx IRuleGovernorContext) {
	this := p
	_ = this

	localctx = NewRuleGovernorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 636, asn1ParserRULE_ruleGovernor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2426)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 158, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2424)
			p.RuleType()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2425)
			p.RuleDefinedObjectClass()
		}

	}

	return localctx
}

// IRuleDummyGovernorContext is an interface to support dynamic dispatch.
type IRuleDummyGovernorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleDummyGovernorContext differentiates from other interfaces.
	IsRuleDummyGovernorContext()
}

type RuleDummyGovernorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleDummyGovernorContext() *RuleDummyGovernorContext {
	var p = new(RuleDummyGovernorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleDummyGovernor
	return p
}

func (*RuleDummyGovernorContext) IsRuleDummyGovernorContext() {}

func NewRuleDummyGovernorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleDummyGovernorContext {
	var p = new(RuleDummyGovernorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleDummyGovernor

	return p
}

func (s *RuleDummyGovernorContext) GetParser() antlr.Parser { return s.parser }

func (s *RuleDummyGovernorContext) RuleDummyReference() IRuleDummyReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuleDummyReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuleDummyReferenceContext)
}

func (s *RuleDummyGovernorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleDummyGovernorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleDummyGovernorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleDummyGovernor(s)
	}
}

func (s *RuleDummyGovernorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleDummyGovernor(s)
	}
}

func (s *RuleDummyGovernorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleDummyGovernor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleDummyGovernor() (localctx IRuleDummyGovernorContext) {
	this := p
	_ = this

	localctx = NewRuleDummyGovernorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 638, asn1ParserRULE_ruleDummyGovernor)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2428)
		p.RuleDummyReference()
	}

	return localctx
}

// IRuleEncodingControlSectionsContext is an interface to support dynamic dispatch.
type IRuleEncodingControlSectionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRuleEncodingControlSectionsContext differentiates from other interfaces.
	IsRuleEncodingControlSectionsContext()
}

type RuleEncodingControlSectionsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRuleEncodingControlSectionsContext() *RuleEncodingControlSectionsContext {
	var p = new(RuleEncodingControlSectionsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = asn1ParserRULE_ruleEncodingControlSections
	return p
}

func (*RuleEncodingControlSectionsContext) IsRuleEncodingControlSectionsContext() {}

func NewRuleEncodingControlSectionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuleEncodingControlSectionsContext {
	var p = new(RuleEncodingControlSectionsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = asn1ParserRULE_ruleEncodingControlSections

	return p
}

func (s *RuleEncodingControlSectionsContext) GetParser() antlr.Parser { return s.parser }
func (s *RuleEncodingControlSectionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuleEncodingControlSectionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuleEncodingControlSectionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.EnterRuleEncodingControlSections(s)
	}
}

func (s *RuleEncodingControlSectionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(asn1Listener); ok {
		listenerT.ExitRuleEncodingControlSections(s)
	}
}

func (s *RuleEncodingControlSectionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case asn1Visitor:
		return t.VisitRuleEncodingControlSections(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *asn1Parser) RuleEncodingControlSections() (localctx IRuleEncodingControlSectionsContext) {
	this := p
	_ = this

	localctx = NewRuleEncodingControlSectionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 640, asn1ParserRULE_ruleEncodingControlSections)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)

	return localctx
}

func (p *asn1Parser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 1:
		var t *RuleModulesContext = nil
		if localctx != nil {
			t = localctx.(*RuleModulesContext)
		}
		return p.RuleModules_Sempred(t, predIndex)

	case 7:
		var t *RuleDefinitiveObjIdComponentListContext = nil
		if localctx != nil {
			t = localctx.(*RuleDefinitiveObjIdComponentListContext)
		}
		return p.RuleDefinitiveObjIdComponentList_Sempred(t, predIndex)

	case 22:
		var t *RuleSymbolListContext = nil
		if localctx != nil {
			t = localctx.(*RuleSymbolListContext)
		}
		return p.RuleSymbolList_Sempred(t, predIndex)

	case 45:
		var t *RuleSymbolsFromModuleListContext = nil
		if localctx != nil {
			t = localctx.(*RuleSymbolsFromModuleListContext)
		}
		return p.RuleSymbolsFromModuleList_Sempred(t, predIndex)

	case 49:
		var t *RuleAssignmentListContext = nil
		if localctx != nil {
			t = localctx.(*RuleAssignmentListContext)
		}
		return p.RuleAssignmentList_Sempred(t, predIndex)

	case 60:
		var t *RuleObjIdComponentsListContext = nil
		if localctx != nil {
			t = localctx.(*RuleObjIdComponentsListContext)
		}
		return p.RuleObjIdComponentsList_Sempred(t, predIndex)

	case 66:
		var t *RuleNamedBitListContext = nil
		if localctx != nil {
			t = localctx.(*RuleNamedBitListContext)
		}
		return p.RuleNamedBitList_Sempred(t, predIndex)

	case 69:
		var t *RuleAlternativeTypeListContext = nil
		if localctx != nil {
			t = localctx.(*RuleAlternativeTypeListContext)
		}
		return p.RuleAlternativeTypeList_Sempred(t, predIndex)

	case 74:
		var t *RuleExtensionAdditionAlternativesListContext = nil
		if localctx != nil {
			t = localctx.(*RuleExtensionAdditionAlternativesListContext)
		}
		return p.RuleExtensionAdditionAlternativesList_Sempred(t, predIndex)

	case 77:
		var t *RuleEnumerationContext = nil
		if localctx != nil {
			t = localctx.(*RuleEnumerationContext)
		}
		return p.RuleEnumeration_Sempred(t, predIndex)

	case 83:
		var t *RuleNamedNumberListContext = nil
		if localctx != nil {
			t = localctx.(*RuleNamedNumberListContext)
		}
		return p.RuleNamedNumberList_Sempred(t, predIndex)

	case 87:
		var t *RuleComponentTypeListContext = nil
		if localctx != nil {
			t = localctx.(*RuleComponentTypeListContext)
		}
		return p.RuleComponentTypeList_Sempred(t, predIndex)

	case 88:
		var t *RuleExtensionAdditionListContext = nil
		if localctx != nil {
			t = localctx.(*RuleExtensionAdditionListContext)
		}
		return p.RuleExtensionAdditionList_Sempred(t, predIndex)

	case 145:
		var t *RuleIdentifierListContext = nil
		if localctx != nil {
			t = localctx.(*RuleIdentifierListContext)
		}
		return p.RuleIdentifierList_Sempred(t, predIndex)

	case 147:
		var t *RuleCharSymsContext = nil
		if localctx != nil {
			t = localctx.(*RuleCharSymsContext)
		}
		return p.RuleCharSyms_Sempred(t, predIndex)

	case 162:
		var t *RuleRelativeOIDComponentsListContext = nil
		if localctx != nil {
			t = localctx.(*RuleRelativeOIDComponentsListContext)
		}
		return p.RuleRelativeOIDComponentsList_Sempred(t, predIndex)

	case 163:
		var t *RuleComponentValueListContext = nil
		if localctx != nil {
			t = localctx.(*RuleComponentValueListContext)
		}
		return p.RuleComponentValueList_Sempred(t, predIndex)

	case 164:
		var t *RuleValueListContext = nil
		if localctx != nil {
			t = localctx.(*RuleValueListContext)
		}
		return p.RuleValueList_Sempred(t, predIndex)

	case 166:
		var t *RuleNamedValueListContext = nil
		if localctx != nil {
			t = localctx.(*RuleNamedValueListContext)
		}
		return p.RuleNamedValueList_Sempred(t, predIndex)

	case 202:
		var t *RuleDefinedSyntaxTokenListContext = nil
		if localctx != nil {
			t = localctx.(*RuleDefinedSyntaxTokenListContext)
		}
		return p.RuleDefinedSyntaxTokenList_Sempred(t, predIndex)

	case 206:
		var t *RuleFieldSettingListContext = nil
		if localctx != nil {
			t = localctx.(*RuleFieldSettingListContext)
		}
		return p.RuleFieldSettingList_Sempred(t, predIndex)

	case 213:
		var t *RuleFieldNameContext = nil
		if localctx != nil {
			t = localctx.(*RuleFieldNameContext)
		}
		return p.RuleFieldName_Sempred(t, predIndex)

	case 217:
		var t *RuleFieldSpecListContext = nil
		if localctx != nil {
			t = localctx.(*RuleFieldSpecListContext)
		}
		return p.RuleFieldSpecList_Sempred(t, predIndex)

	case 234:
		var t *RuleTokenOrGroupSpecListContext = nil
		if localctx != nil {
			t = localctx.(*RuleTokenOrGroupSpecListContext)
		}
		return p.RuleTokenOrGroupSpecList_Sempred(t, predIndex)

	case 245:
		var t *RuleUnionsContext = nil
		if localctx != nil {
			t = localctx.(*RuleUnionsContext)
		}
		return p.RuleUnions_Sempred(t, predIndex)

	case 247:
		var t *RuleIntersectionsContext = nil
		if localctx != nil {
			t = localctx.(*RuleIntersectionsContext)
		}
		return p.RuleIntersections_Sempred(t, predIndex)

	case 256:
		var t *RuleComponentIdListContext = nil
		if localctx != nil {
			t = localctx.(*RuleComponentIdListContext)
		}
		return p.RuleComponentIdList_Sempred(t, predIndex)

	case 258:
		var t *RuleAtNotationListContext = nil
		if localctx != nil {
			t = localctx.(*RuleAtNotationListContext)
		}
		return p.RuleAtNotationList_Sempred(t, predIndex)

	case 260:
		var t *RuleUserDefinedConstraintParameterListContext = nil
		if localctx != nil {
			t = localctx.(*RuleUserDefinedConstraintParameterListContext)
		}
		return p.RuleUserDefinedConstraintParameterList_Sempred(t, predIndex)

	case 278:
		var t *RuleTypeConstraintsContext = nil
		if localctx != nil {
			t = localctx.(*RuleTypeConstraintsContext)
		}
		return p.RuleTypeConstraints_Sempred(t, predIndex)

	case 303:
		var t *RuleActualParametersContext = nil
		if localctx != nil {
			t = localctx.(*RuleActualParametersContext)
		}
		return p.RuleActualParameters_Sempred(t, predIndex)

	case 314:
		var t *RuleParametersContext = nil
		if localctx != nil {
			t = localctx.(*RuleParametersContext)
		}
		return p.RuleParameters_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *asn1Parser) RuleModules_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *asn1Parser) RuleDefinitiveObjIdComponentList_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *asn1Parser) RuleSymbolList_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 2:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *asn1Parser) RuleSymbolsFromModuleList_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 3:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *asn1Parser) RuleAssignmentList_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 4:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *asn1Parser) RuleObjIdComponentsList_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 5:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *asn1Parser) RuleNamedBitList_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 6:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *asn1Parser) RuleAlternativeTypeList_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 7:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *asn1Parser) RuleExtensionAdditionAlternativesList_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 8:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *asn1Parser) RuleEnumeration_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 9:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *asn1Parser) RuleNamedNumberList_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 10:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *asn1Parser) RuleComponentTypeList_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 11:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *asn1Parser) RuleExtensionAdditionList_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 12:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *asn1Parser) RuleIdentifierList_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 13:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *asn1Parser) RuleCharSyms_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 14:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *asn1Parser) RuleRelativeOIDComponentsList_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 15:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *asn1Parser) RuleComponentValueList_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 16:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *asn1Parser) RuleValueList_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 17:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *asn1Parser) RuleNamedValueList_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 18:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *asn1Parser) RuleDefinedSyntaxTokenList_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 19:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *asn1Parser) RuleFieldSettingList_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 20:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *asn1Parser) RuleFieldName_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 21:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *asn1Parser) RuleFieldSpecList_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 22:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *asn1Parser) RuleTokenOrGroupSpecList_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 23:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *asn1Parser) RuleUnions_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 24:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *asn1Parser) RuleIntersections_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 25:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *asn1Parser) RuleComponentIdList_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 26:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *asn1Parser) RuleAtNotationList_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 27:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *asn1Parser) RuleUserDefinedConstraintParameterList_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 28:
		return p.Precpred(p.GetParserRuleContext(), 3)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *asn1Parser) RuleTypeConstraints_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 29:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *asn1Parser) RuleActualParameters_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 30:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *asn1Parser) RuleParameters_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	this := p
	_ = this

	switch predIndex {
	case 31:
		return p.Precpred(p.GetParserRuleContext(), 2)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
